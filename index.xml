<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hshsh&#39;s little site</title>
    <link>http://hshsh.me/</link>
    <description>Recent content on hshsh&#39;s little site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 07 Sep 2016 10:00:00 +0800</lastBuildDate>
    <atom:link href="http://hshsh.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>解决Fedora24上Pycharm中中文显示方块的问题</title>
      <link>http://hshsh.me/post/2016-09-07-fedora-24-pycharm-chinese-fonts/</link>
      <pubDate>Wed, 07 Sep 2016 10:00:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-09-07-fedora-24-pycharm-chinese-fonts/</guid>
      <description>&lt;p&gt;先说说在Ubuntu上遇到的奇怪的TCP连接失败问题，在升级到Ubuntu16.04后，电脑突然连不上阿里云上的一台Ubuntu服务器了（所有TCP端口都无法连接），连接另外一台Windows服务器正常，办公室里另外一台Ubuntu16.04电脑也无法连接到这台Ubuntu服务器，但是其他Windows系统的电脑访问一切正常，另外还有两台Ubuntu14.04的工作站连接正常。后来又有一个同事的Ubuntu14.04也出现了连接不上的问题。而且还是有时候一连几个小时连接不上，有时候又一切正常的。&lt;/p&gt;

&lt;p&gt;莫名其妙的问题，研(sou)究(suo)两天之后（Google关键字：&lt;a href=&#34;https://www.google.com/?q=ubuntu+tcp+retransmission&#34;&gt;ubuntu tcp retransmission&lt;/a&gt;），发现这个问题好像是Debian系列发行版的毛病，又好像会针对虚拟机才会出现，网上也有很多报告这个问题的，但是都没有合适的解决方案。所以决定换个发行版咯，就试试Fedora呗～&lt;/p&gt;

&lt;p&gt;Fedora Workstation 24安装不复杂，一路next就高定了，dnf命令用起来跟apt-get也差不多。&lt;/p&gt;

&lt;p&gt;但是用Pycharm编辑Markdown文件时候，发现预览页面很多中文字符都变成方块了，理论上这个是字体的问题，但是不知道需要的是哪一个字体，在&lt;a href=&#34;https://www.zhukun.net/archives/6614&#34;&gt;Fedora 21安装以后的优化&lt;/a&gt;这篇文章中提到一些常用的字体，先装上试试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dnf install google-droid-sans-fonts
sudo dnf install wqy-zenhei-fonts
sudo dnf install adobe-source-han-sans-cn-fonts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，安装字体的时候，我还安装了LibreOffice的中文语言支持包，不知道里面有没有甬道的字体：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dnf install libreoffice-langpack-zh-Hans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完字体，关掉所有已经打开的Pycharm程序，重新启动Pycharm，所有中文字体显示就正常了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu14.04上DNS引发的血案</title>
      <link>http://hshsh.me/post/2016-08-09-ubuntu-14.04-dnsmasq/</link>
      <pubDate>Tue, 09 Aug 2016 11:03:30 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-08-09-ubuntu-14.04-dnsmasq/</guid>
      <description>&lt;p&gt;作为技术备忘，为了纪念为此死去的千千万万脑细胞，先说问题：&lt;/p&gt;

&lt;p&gt;公司搬家后，一台工作站上的爬虫程序突然莫名其妙的变慢，从一天20多万条数据萎缩到了14W-20W条不稳定，因为新办公室里所有部门共用一条网线，起初还以为是网络拥挤，属于正常情况，后来居然夸张的变成了每天3W条数据，经过跟踪发现这个爬虫全天候不分时间段的慢，这就很不对了。然后开始一系列的排查。&lt;/p&gt;

&lt;p&gt;后来把爬虫里面用域名访问的代码改成使用IP地址访问，发现速度连接速度不慢，但是一使用域名就变龟速了，很明显域名解析出问题了，作为临时方案，我居然手写了一段IP地址缓存的代码，:(&amp;lt;&lt;/p&gt;

&lt;p&gt;吐槽一下：Ubuntu系统配置DNS一点都不方便！！&lt;/p&gt;

&lt;p&gt;发现工作站上的DNS服务器被配置成了8.8.8.8，然而这段时间Google的DNS抽风了，经常连接不上，所以解决办法就很简单了。&lt;/p&gt;

&lt;p&gt;研究配置DNS的过程中，被灌输了一堆新名词：dnsmasq, resolv.conf, NetworkManager, resolvconf &amp;hellip;&lt;/p&gt;

&lt;p&gt;没看全部的文档，根据查阅的部分资料，Ubuntu的DNS机制大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;NetworkManager管理DNS配置，图形界面“编辑连接”弹出来的就是这货，这里配置的DNS存储在&lt;code&gt;/run/resolvconf/interface/NetworkManager&lt;/code&gt;文件中。&lt;/li&gt;
&lt;li&gt;系统范围DNS的基本配置在&lt;code&gt;/etc/resolvconf/resolv.conf.d/&lt;/code&gt;这个目录下面，这里有三个文件：&lt;code&gt;base&lt;/code&gt;中是基本配置，系统动态生成&lt;code&gt;resolv.conf&lt;/code&gt;文件时要包含的内容；&lt;code&gt;head&lt;/code&gt;也是要包含在&lt;code&gt;resolv.conf&lt;/code&gt;文件中的，里面主要包含一些说明，比如不要修改我会被覆盖之类的；&lt;code&gt;tail&lt;/code&gt;里是要追加到动态生成的&lt;code&gt;resolv.conf&lt;/code&gt;文件末尾的内容。&lt;/li&gt;
&lt;li&gt;从Ubuntu 12.04开始，系统默认都会安装一个阉割版的dnsmasq服务（dnsmasq-base包，不是dnsmasq包），主要是为了解决DNS和VPN之间的什么什么暧昧问题的，监听在127.0.1.1:53地址上，系统DNS请求都会发到这个监听地址上。&lt;/li&gt;
&lt;li&gt;系统启动或者执行&lt;code&gt;resolvconf -u&lt;/code&gt;命令的时候，会根据配置动态生成DNS配置文件&lt;code&gt;/ete/resolv.conf&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个理解必然是不全面的，甚至有些完全就是错的，留待下次再搞DNS问题的时候研究吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关的解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装完整功能的Dnsmasq：&lt;code&gt;sudo apt-get install dnsmasq&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置Dnsmasq上游DNS服务器和本地监听地址，修改&lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;listen-address=127.0.0.1,127.0.1.1
resolv-file=/etc/resolv.dnsmasq
conf-dir=/etc/dnsmasq.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/resolv.dnsmasq&lt;/code&gt;文件里面写上游DNS服务器地址：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;nameserver 114.114.114.114
nameserver 223.5.5.5
nameserver 114.114.115.115
nameserver 223.6.6.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他dnsmasq配置自由发挥就好啦～&lt;/p&gt;

&lt;p&gt;修改系统DNS解析配置&lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;nameserver 127.0.0.1
nameserver 114.114.114.114
nameserver 223.5.5.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动dnsmasq服务：&lt;code&gt;sudo service dnsmasq restart&lt;/code&gt;，更新DNS动态配置：&lt;code&gt;sudo resolvconf -u&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上步骤&lt;strong&gt;可能&lt;/strong&gt;就解决问题了，也可能还会有问题，也可能会引入新的问题，比如参考资料4中提到的系统启动时候服务启动顺序的问题～～&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dnsmasq扩展阅读&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;Dnsmasq提供DNS缓存和DHCP服务功能。作为域名解析服务器(DNS)，dnsmasq可以通过缓存DNS请求来提高对访问过的网址的连接速度。作为DHCP服务器，dnsmasq可以用于为局域网电脑分配内网ip地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。此外它还自带了一个PXE服务器。&lt;a href=&#34;https://wiki.archlinux.org/index.php/Dnsmasq&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不使用Dnsmasq直接设置系统的DNS服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt;文件中DNS配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;nameserver 114.114.114.114
nameserver 223.5.5.5
nameserver 114.114.115.115
nameserver 223.6.6.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.ubuntu.org.cn/%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0DNS%E5%8A%A0%E9%80%9F%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE&#34;&gt;使用本地DNS加速网络访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://unix.stackexchange.com/questions/128220/how-do-i-set-my-dns-when-resolv-conf-is-being-overwritten&#34;&gt;How do I set my DNS when resolv.conf is being overwritten?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://superuser.com/questions/681993/using-dnsmasq-with-networkmanager&#34;&gt;Using dnsmasq with NetworkManager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/magnetikonline/6236150&#34;&gt;Using Dnsmasq with Ubuntu for VM web application testing&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>升级Windows导致Postgresql服务无法启动问题</title>
      <link>http://hshsh.me/post/2016-08-06-fix-postgresql-permission-issue-again/</link>
      <pubDate>Sat, 06 Aug 2016 10:17:25 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-08-06-fix-postgresql-permission-issue-again/</guid>
      <description>&lt;p&gt;这两天升级系统到了Windows 10.1，结果Postgresql数据库又起不来了，之前重做Windows 7的时候就遇到过这个问题，但是不记得是怎么搞定的了。&lt;/p&gt;

&lt;p&gt;查了一堆资料，基本断定问题是由于升级操作系统后，Windows建立新用户，用户SID改变导致的。可是网上始终也没有找到个有效的解决方法。记得上次就是这样，最后只能再次祭出大招，下载EnterpriseDB的安装包，重装一遍，查看它的服务进程登录用户和文件目录权限。&lt;/p&gt;

&lt;p&gt;这里记录一下，以免下次又忘了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务进程登录用户：&amp;rdquo;NT AUTHORITY\NetworkService&amp;rdquo;&lt;/li&gt;
&lt;li&gt;服务进程启动命令：C:/path/to/pg_ctl.exe runservice -N &amp;ldquo;pgsql&amp;rdquo; -D &amp;ldquo;E:/path/to/data&amp;rdquo; -w&lt;/li&gt;
&lt;li&gt;数据目录OWNER：Administrators (COMPUTER\Administrators)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外数据目录上要确保下面两个权限：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NETWORK SERVICE：完全控制&lt;/li&gt;
&lt;li&gt;本地登录用户（COMPUTER\username）：完全控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他的权限系统默认就行了，具体权限设置就不记录了，从Cygwin开始就对着权限搞来搞去，现在Postgresql又搞权限问题，已经是轻车熟路了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>遭遇时间不同步引起的BUG</title>
      <link>http://hshsh.me/post/2016-07-30-fix-bug-caused-by-un-synced-time/</link>
      <pubDate>Sat, 30 Jul 2016 07:30:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-07-30-fix-bug-caused-by-un-synced-time/</guid>
      <description>&lt;p&gt;前段时间遇到一个诡异的bug，后端代码有使用到一个数据服务API，接口有时间戳验证。API服务跑在云服务器上，程序后台跑在本地Ubuntu服务器上。&lt;/p&gt;

&lt;p&gt;两个服务都是我写的，API服务升级了时间戳验证功能后重新部署，本地服务器上的程序后台服务居然挂掉了，开发电脑上各种测试都正常，只好开启调试日志检查。结果发现是本地服务器上时间比API服务的时间快了两分钟多。&lt;/p&gt;

&lt;p&gt;查看服务器配置，发现Ubuntu Server发行版默认居然没有安装NTP服务，Server版居然不开启时间同步服务？？？一万匹草泥马奔腾而过……&lt;/p&gt;

&lt;p&gt;找到问题，解决就简单了，安装NTP服务，顺便把时间服务器配置到国内某云的时间服务器~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点强调&lt;/strong&gt;：部署Server服务器后一定要检查NTP服务起了没？一定要起时间同步服务，并且要配置速度比较快的时间同步服务器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 14.04 使用阿里云源</title>
      <link>http://hshsh.me/post/2016-07-30-using-aliyun-mirror-for-ubuntu-14.04/</link>
      <pubDate>Sat, 30 Jul 2016 07:20:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-07-30-using-aliyun-mirror-for-ubuntu-14.04/</guid>
      <description>&lt;p&gt;Ubuntu的官方源也是慢的不行不行的，怎么办？换阿里云的源，速度杠杠的！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak  # 备份
sudo vim /etc/apt/sources.list  # 修改配置
sudo apt-get clean &amp;amp;&amp;amp; sudo apt-get update  # 更新列表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改源配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse

## Uncomment the following two lines to add software from Canonical&#39;s
## &#39;partner&#39; repository.
## This software is not part of Ubuntu, but is offered by Canonical and the
## respective vendors as a service to Ubuntu users.
# deb http://archive.canonical.com/ubuntu trusty partner
# deb-src http://archive.canonical.com/ubuntu trusty partner

## This software is not part of Ubuntu, but is offered by third-party
## developers who want to ship their latest software.
deb http://extras.ubuntu.com/ubuntu trusty main
deb-src http://extras.ubuntu.com/ubuntu trusty main
deb http://packagecloud.io/grafana/testing/debian/ wheezy main
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用清华大学Anaconda镜像</title>
      <link>http://hshsh.me/post/2016-07-30-using-tsinghua-anaconda-mirror/</link>
      <pubDate>Sat, 30 Jul 2016 07:00:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-07-30-using-tsinghua-anaconda-mirror/</guid>
      <description>&lt;p&gt;Python的Anaconda发行版用起来真是舒服，可是官方源的速度真可谓是龟速，一直也没找到国内的镜像源。
早上看到IPython更新到5.0LTS版本，看起来很爽，不死心的又查了一下，发现&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/news/#alpine-anaconda&#34;&gt;清华大学2016年4月27日新增了Anaconda的镜像&lt;/a&gt;，果断切换。&lt;/p&gt;

&lt;p&gt;看这里：&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;conda config --add channels &#39;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;
conda config --set show_channel_urls yes
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu &amp; Linux 常用命令笔记</title>
      <link>http://hshsh.me/post/2016-04-27-ubuntu-linux-shell-commands-notes/</link>
      <pubDate>Wed, 27 Apr 2016 12:00:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-27-ubuntu-linux-shell-commands-notes/</guid>
      <description>

&lt;h2 id=&#34;系统配置&#34;&gt;系统配置&lt;/h2&gt;

&lt;h3 id=&#34;安装-oracle-jdk&#34;&gt;安装 Oracle JDK&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo add-apt-repository ppa:webupd8team/java
$ sudo apt-get update
$ sudo apt-get install oracle-java8-installer
$ sudo apt-get install oracle-java8-set-default
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;永久性修改系统dns&#34;&gt;永久性修改系统DNS&lt;/h3&gt;

&lt;p&gt;编辑&lt;code&gt;/etc/network/interfaces&lt;/code&gt;文件，在最后添加一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;dns-nameservers 8.8.8.8 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者可以修改&lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt;文件，默认为空，在其中插入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;nameserver 8.8.8.8
nameserver 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有多个DNS，就每行添加一个。&lt;/p&gt;

&lt;p&gt;NOTE：亲测，以上设置，需要重启系统后生效！&lt;/p&gt;

&lt;h2 id=&#34;常用命令行工具&#34;&gt;常用命令行工具&lt;/h2&gt;

&lt;h3 id=&#34;查看进程&#34;&gt;查看进程&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ps ax
$ ps aux
$ ps ax | less
$ ps ax | grep ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看端口&#34;&gt;查看端口&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ netstat -tap | grep ...
$ netstat -na | grep ...
$ ss -tln | grep ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看指定进程占用的端口号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ps -ef | grep &amp;quot;process name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据进程ID查看招用端口号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# redhat
$ netstat -nltp | grep pid
# ubuntu
$ netstat -anp | grep pid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看占用某个端口的进程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ lsof -i:port
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;监控日志文件&#34;&gt;监控日志文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ tail -f /path/to/file.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重启-x-server&#34;&gt;重启 X Server&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cat /etc/X11/default-display-manager
$ sudo restart {DISPLAY_MANAGER}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;输出重定向&#34;&gt;输出重定向&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cat foo &amp;gt; foo.txt  # 重定向标准输出到文件
$ cat foo 2&amp;gt; foo.txt  # 重定向错误输出到文件
$ cat foo 2&amp;gt;&amp;amp;1  # 重定向错误输出到标准输出
$ cat foo &amp;gt; foo.txt 2&amp;gt;&amp;amp;1  # 重定向标准输出和错误输出到文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要写入的文件权限不够，可以这样（&lt;code&gt;-a&lt;/code&gt;选项表示追加内容到文件）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo sh -c &amp;quot;echo &#39;xxx&#39;&amp;quot; &amp;gt; /path/to/somefile
$ echo &#39;xxx&#39; | sudo tee -a /path/to/somefile
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MySQL &amp; SQL 常用命令笔记</title>
      <link>http://hshsh.me/post/2016-04-27-mysql-sql-commands-notes/</link>
      <pubDate>Wed, 27 Apr 2016 11:42:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-27-mysql-sql-commands-notes/</guid>
      <description>

&lt;h2 id=&#34;查看数据库和数据表结构&#34;&gt;查看数据库和数据表结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u user -p
mysql&amp;gt; show databases;
mysql&amp;gt; show tables;
mysql&amp;gt; use {DATABASE_NAME};
mysql&amp;gt; show columns from {TABLE_NAME};
mysql&amp;gt; show create table {TABLE_NAME};
mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;变更数据表结构&#34;&gt;变更数据表结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 重命名字段并可选修改字段类型
alter table {TABLE_NAME} change {OLD_COLUMN} {NEW_COLUMN} {COLUMN_TYPE};
# 修改字段类型不重命名字段
alter table {TABLE_NAME} modify {COLUMN_NAME} {COLUMN_TYPE};
# 增加字段
alter table {TABLE_NAME} add column {COLUMN_NAME} {COLUMN_TYPE};
# 删除字段
alter table {TABLE_NAME} drop column {COLUMN_NAME};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;快速批量加载数据到数据库&#34;&gt;快速批量加载数据到数据库&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: 下面命令中&lt;code&gt;{...}&lt;/code&gt;表示必填参数，&lt;code&gt;[...]&lt;/code&gt;表示选项参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 逗号分隔的 csv 文件, 字段列表可选
load data local infile &amp;quot;/path/to/file.csv&amp;quot; into table {TABLE_NAME}
fileds terminated by &#39;,&#39; [(field1, field2, field3, ...)];
# 制表符分隔的 txt 文件, 字段列表可选
laod data local infile &amp;quot;/path/to/file.txt&amp;quot; into table {TABLE_NAME}
[(field1, field2, field3, ...)];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能会遇到&lt;code&gt;ERROR 1148 (42000): The used command is not allowed with this
MySQL version&lt;/code&gt;的错误提示，错误原因是编译安装&lt;code&gt;mysql&lt;/code&gt;的时候没有指定&lt;code&gt;--enable-local-infile&lt;/code&gt;
选项，除了重新编译安装加上上面的参数外，还可以直接使用命令行执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u user -p {DATABASE_NAME} --local-infile=1 -e &#39;load data local \
  infile &amp;quot;/path/to/file.txt&amp;quot; into {TABLE_NAME} [(field1, field2, field3, ...)];&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数据库导出操作&#34;&gt;数据库导出操作&lt;/h2&gt;

&lt;p&gt;导出全部数据库备份到本地目录:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysqldump -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --routines \
  --default-character-set=utf8 --locak-all-tables --add-drop-database -A \
  &amp;gt; db.all.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出指定数据库到本地目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysqldump -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --routines \
  --default-character-set=utf8 --databases {DATABASE_NAME} &amp;gt; db.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出某个数据库的表到本地目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysqldump -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --routines \
  --default-character-set=utf8 --tables {DATABASE_NAME} {TABLE_NAME} \
  &amp;gt; db.table.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出指定数据库的表（仅数据，可带过滤条件）到本地目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysqldump -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --routines \
  --default-character-set=utf8 --no-create-db --no-create-info \
  --tables {DATABASE_NAME} {TABLE_NAME} \
  [--where=&amp;quot;host=&#39;localhost&#39;&amp;quot;] &amp;gt; db.table.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出数据库的所有表结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysqldump -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --routines \
  --default-character-set=utf8 --no-data --databases {DATABASE_NAME} \
  &amp;gt; db.nodata.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出某个查询SQL的数据为 txt 格式文件到本地目录，各数据值之间用制表符分隔：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --default-character-set=utf8 \
  --skip-column-names -B -e &#39;select ... from ... ;&#39; &amp;gt; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出某个查询SQL的数据为 csv 格式文件到服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --default-character-set=UTF8
mysql&amp;gt; select ... from ... into outfile &#39;/path/to/file.csv&#39; fields terminated by &#39;,&#39;;
mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数据库导入操作&#34;&gt;数据库导入操作&lt;/h2&gt;

&lt;p&gt;恢复全库数据到MySQL，因为包含mysql库的权限表，导入完成后需要执行
&lt;code&gt;FLUSH PRIVILEGES;&lt;/code&gt;命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h127.0.0.1 -P3306 \
  --default-character-set=UTF8 &amp;lt; db.all.sql

# 方法二
$ mysql -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --default-=character-set=UTF8
mysql&amp;gt; source /path/to/db.all.sql
mysql&amp;gt; flush privileges;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复某个数据库：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h$HOST -P$PORT --default-character-set=UTF8 \
  {DATABASE_NAME} &amp;lt; db.table.sql

# 方法二
$ mysql -u$USER -p$PASSWORD -h$HOST -P$PORT --default-character-set=UTF8
mysql&amp;gt; use {DATABASE_NAME};
mysql&amp;gt; source /path/to/db.table.sql;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复MySQL服务器上面的 txt 格式文件（需要FILE权限，数据值之间用制表符分隔）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h$HOST -P$PORT --default-character-set=UTF8
mysql&amp;gt; use {DATABASE_NAME};
mysql&amp;gt; load data infile &#39;/path/to/file.txt&#39; into table {TABLE_NAME};
mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复MySQL服务器上的 csv 格式文件（需要FILE权限，数据值之间用逗号分隔）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h$HOST -P$PORT --default-character-set=UTF8
mysql&amp;gt; use {DATABASE_NAME};
mysql&amp;gt; load data infile &#39;/path/to/file.csv&#39; into table {TABLE_NAME}
mysql&amp;gt; fields terminated by &#39;,&#39;;
mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复本地的 txt 或 csv 文件到MySQL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mysql -u$USER -p$PASSWORD -h$HOST -P$PORT --default-character-set=UTF8
mysql&amp;gt; use {DATABASE_NAME};
mysql&amp;gt; load data local infile &#39;/path/to/file.txt&#39; into table {TABLE_NAME};
mysql&amp;gt; load data local infile &#39;/path/to/file.csv&#39; into table {TABLE_NAME}
mysql&amp;gt; fields terminated by &#39;,&#39;;
mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常用命令参数说明&#34;&gt;常用命令参数说明&lt;/h2&gt;

&lt;p&gt;mysqldump参数说明：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;-A&lt;/strong&gt;: 全库备份&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;routines&lt;/strong&gt;: 备份存储过程和函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;default-character-set=utf8&lt;/strong&gt;: 设置连接字符集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;lock-all-tables&lt;/strong&gt;: 全局一致性锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;add-drop-database&lt;/strong&gt;: 在每次执行建表语句之前，先执行&lt;code&gt;drop table if exist&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;no-create-db&lt;/strong&gt;: 不输出&lt;code&gt;create database&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;no-create-info&lt;/strong&gt;: 不输出&lt;code&gt;create table&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;databases&lt;/strong&gt;: 将后面的参数都解析为数据库名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;tables&lt;/strong&gt;: 第一个参数为数据库名，后续参数为数据表名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mysql参数说明：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&amp;ndash;skip-column-names&lt;/strong&gt;: 不显示数据列的名字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-B&lt;/strong&gt;: 以批处理的方式运行mysql程序，查询结果将显示为制表符间隔格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-e&lt;/strong&gt;: 执行命令后退出&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;LOAD DATA&lt;/code&gt;语法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;LOAD DATA&lt;/code&gt;语句不带&lt;code&gt;LOCAL&lt;/code&gt;关键字，就在MySQL的服务器上直接读取文件，
需要具有FILE权限&lt;/li&gt;
&lt;li&gt;如果带有&lt;code&gt;LOCAL&lt;/code&gt;关键字，就在客户端本地读取数据文件，通过网络传输到MySQL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOAD DATA&lt;/code&gt;语句，同样会被记录到&lt;code&gt;binlog&lt;/code&gt;，不过是MySQL内部的机制&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;设置默认使用utf8编码&#34;&gt;设置默认使用utf8编码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# configuration in file /etc/mysql/my.cnf
[client]
# 客户端连接
default-character-set = utf8
[mysql]
# 命令行工具
default-character-set = utf8
[mysqld]
# 服务器默认字符集
character-set-server = utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mysqld-服务管理&#34;&gt;mysqld 服务管理&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo service mysql {start | stop | restart}
$ sudo /etc/init.d/mysql {start | stop | restart}

# safe 模式启动
$ sudo safe_mysqld &amp;amp;

# mysqld 守护进程管理程序.
$ mysqladmin shutdown
$ mysqladmin --help
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>XtraBackup热备份MySQL主从同步笔记</title>
      <link>http://hshsh.me/post/2016-04-26-mysql-hot-backup-with-xtrabackup/</link>
      <pubDate>Tue, 26 Apr 2016 18:30:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-26-mysql-hot-backup-with-xtrabackup/</guid>
      <description>

&lt;p&gt;公司的MySQL数据库单实例裸跑了一个多月，今天终于做了主从同步，暂时主要起备份作用，庆幸这段时间没有发生意外。&lt;/p&gt;

&lt;p&gt;先说主要的参考资料，强烈推荐阅读：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wsgzao.github.io/post/xtrabackup/&#34;&gt;XtraBackup不停机不锁表搭建MySQL主从同步实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://seanlook.com/2015/12/14/mysql-replicas/&#34;&gt;使用 Xtrabackup 在线对MySQL做主从复制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000002575399&#34;&gt;通过XtraBackup实现不停机不锁表搭建主从同步&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;更新历史&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;2016-04-26: 初稿.&lt;/p&gt;

&lt;p&gt;2016-12-19:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;修复 innobackupex 命令错误: &amp;ldquo;xtrabackup: Error: &amp;ndash;defaults-file must be specified first on the command line&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;添加 &amp;ldquo;主从复制心跳和连接超时&amp;rdquo; 内容.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;转载一下主从同步和XtraBackup的简介：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MySQL主从同步原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL主从同步是在MySQL主从复制(Master-Slave Replication)基础上实现的，通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I/O线程从Master MySQL上读取binlog，然后传输到Slave MySQL的中继日志中，然后Slave MySQL的SQL线程从中继日志中读取中继日志，然后应用到Slave MySQL的数据库中。这样实现了主从数据同步功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;XtraBackup备份原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;innobackupex在后台线程不断追踪InnoDB的日志文件，然后复制InnoDB的数据文件。数据文件复制完成之后，日志的复制线程也会结束。这样就得到了不在同一时间点的数据副本和开始备份以后的事务日志。完成上面的步骤之后，就可以使用InnoDB崩溃恢复代码执行事务日志（redo log），以达到数据的一致性。&lt;/p&gt;

&lt;p&gt;备份分为两个过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;backup，备份阶段，追踪事务日志和复制数据文件（物理备份）。&lt;/li&gt;
&lt;li&gt;preparing，重放事务日志，使所有的数据处于同一个时间点，达到一致性状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;XtraBackup的优点&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可以快速可靠的完成数据备份（复制数据文件和追踪事务日志）&lt;/li&gt;
&lt;li&gt;数据备份过程中不会中断事务的处理（热备份）&lt;/li&gt;
&lt;li&gt;节约磁盘空间和网络带宽&lt;/li&gt;
&lt;li&gt;自动完成备份鉴定&lt;/li&gt;
&lt;li&gt;因更快的恢复时间而提高在线时间&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;操作笔记&#34;&gt;操作笔记&lt;/h2&gt;

&lt;p&gt;参考的两篇文章里面说的挺详细的，但是有部分命令和命令执行顺序写的不大明白，这里简单记录以下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;完整的步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主、从服务器上都搭好MySQL服务，从服务器上MySQL版本大于等于主服务器，最好完全一致&lt;/li&gt;
&lt;li&gt;在要做主从同步的服务器上分别安装XtraBackup&lt;/li&gt;
&lt;li&gt;如果从服务器上有MySQL实例，停掉服务，备份删除数据库内容，保留数据库目录&lt;/li&gt;
&lt;li&gt;配置主从服务器打开主从同步功能&lt;/li&gt;
&lt;li&gt;主服务器上执行备份&lt;/li&gt;
&lt;li&gt;传输备份文件到从服务器，并同步数据文件（apply-log）&lt;/li&gt;
&lt;li&gt;从服务器上恢复备份&lt;/li&gt;
&lt;li&gt;主服务器上授权同步帐号&lt;/li&gt;
&lt;li&gt;从服务器上设置MASTER并开启同步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完成，可以检查同步状态了！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体操作过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NOTE：以下命令以普通用户权限运行，如果需要ROOT权限，均使用&lt;code&gt;sudo&lt;/code&gt;执行。默认均使用Ubuntu发行版仓库中的MySQL，版本比较旧，如果使用官方发行版本，需要注意相关选项、目录等配置。&lt;/p&gt;

&lt;p&gt;一、主从服务器上搭建MySQL服务，并检查MySQL版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# master &amp;amp; slave
sudo apt-get install mysql-server
mysql --version
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;mysql  Ver 14.14 Distrib 5.5.49, for debian-linux-gnu (x86_64) using readline 6.3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;二、主从服务器上分别安装XtraBackup，根据官方网站指导使用打包好的二进制，选择最新的稳定版2.4：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# master &amp;amp; slave
wget https://repo.percona.com/apt/percona-release_0.1-3.$(lsb_release -sc)_all.deb
sudo dpkg -i percona-release_0.1-3.$(lsb_release -sc)_all.deb
sudo apt-get update
sudo apt-get install percona-xtrabackup-24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、停掉从服务器上MySQL服务，备份原有数据库，并删除原有数据库内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysqldump -u$USER -p$PASSWORD -h127.0.0.1 -P3306 --routines \
  --default-character-set=utf8 --locak-all-tables --add-drop-database -A \
  db.all.sql
sudo service mysql stop
sudo cd /var/lib/mysql
# 下面这句千万别打错了，后果会很严重
sudo rm -rf ./*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;四、配置MySQL打开主从同步功能&lt;/p&gt;

&lt;p&gt;主服务器上编辑&lt;code&gt;/etc/mysql/my.conf&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;[mysqld]
# 注意主从之间的server-id不能相同
server-id    = 1
log_bin      = /var/log/mysql/mysql-bin.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果主服务器上MySQL是已经上线的系统，需要重启一下（实测&lt;code&gt;/etc/init.d/mysql reload&lt;/code&gt;不起作用）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service mysql restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从服务器上编辑&lt;code&gt;/etc/mysql/my.conf&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;[mysqld]
# 注意主从之间的server-id不能相同
server-id    = 2
# 最好设置从服务器为只读
# 注意：即使这里设置了只读，使用具有super权限的用户登录，也还是可以做写操作的
read_only    = ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询主从服务器状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql -u USER -p PASSWD -e &amp;quot;show global variables like &#39;server-id&#39;;&amp;quot;
    +---------------+-------+
    | Variable_name | Value |
    +---------------+-------+
    | server_id     | 1     |
    +---------------+-------+

mysql -u USER -p PASSWD -e &amp;quot;show global variables like &#39;log_bin&#39;;&amp;quot;
    +---------------+-------+
    | Variable_name | Value |
    +---------------+-------+
    | log_bin       | ON    |
    +---------------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;五、主服务器上执行备份操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo innobackupex --defaults-file=/etc/mysql/my.cnf --user=USER --password \
  --parallel=4 /tmp/mybackup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令输出的最后几行通常类似这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;innobackupex: Backup created in directory &#39;/tmp/mybackup/2016-04-26_17-41-51&#39;
innobackupex: MySQL binlog position: filename &#39;mysql-bin.000003&#39;, position 1946
111225 00:00:53 innobackupex: completed OK!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令执行完在&lt;code&gt;/tmp/mybackup&lt;/code&gt;目录下生成的&lt;code&gt;2016-04-26_17-41-51&lt;/code&gt;目录，里面存储的是备份的数据，下一步要传输到从服务器上的即是这个文件夹。&lt;/p&gt;

&lt;p&gt;输出中的&lt;code&gt;MySQL binlog position: filename &#39;mysql-bin.000003&#39;, position 1946&lt;/code&gt;里面的两个数字，要记录以下，后面恢复到从服务器上的时候要用到。&lt;/p&gt;

&lt;p&gt;六、传输并同步备份数据&lt;/p&gt;

&lt;p&gt;读取备份数据需要ROOT权限，下面的命令需要使用sudo执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /tmp/mybackup
sudo scp -r /tmp/mybackup/2016-04-26_17-44-49 USER@SLAVE:/tmp/mybackup/2016-04-26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在从服务器上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo innobackupex --apply-log /tmp/mybackup/2016-04-26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;七、从服务器上恢复备份数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 恢复数据
sudo innobackupex --defaults-file=/etc/mysql/my.cnf --user=USER --password \
  --copy-back /tmp/mybackup/2016-04-26/
# 需要恢复权限给mysql
sudo chown -R mysql:mysql /var/lib/mysql
# 启动MySQL
sudo service mysql start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: 如果从数据库存在多个MySQL，执行命令有所不同，请另行查阅相关资料。&lt;/p&gt;

&lt;p&gt;八、主服务器上授权同步帐号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql -u USER -p PASSWD -h HOST -P PORT
&amp;gt; grant replication slave on *.* to &#39;slave&#39;@&#39;10.10.16.24&#39; identified by &#39;slave_passport&#39;;
&amp;gt; flush privileges;
&amp;gt;
&amp;gt; select distinct concat(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) as query from mysql.user;
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一条语句查询当前数据库中的用户信息，检查&lt;code&gt;slave_passport&lt;/code&gt;是否在其中。&lt;/p&gt;

&lt;p&gt;九、配置从服务器开启同步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql -u USER -p PASSWD -h HOST -p PORT
&amp;gt; change master to
&amp;gt; master_host = &#39;10.10.16.51&#39;,
&amp;gt; master_user = &#39;slave&#39;,
&amp;gt; master_password = &#39;slave_password&#39;,
&amp;gt; master_port = 3306,
&amp;gt; master_log_file = &#39;mysql-bin.000003&#39;,
&amp;gt; master_log_pos = 1946;
&amp;gt;
&amp;gt; start slave;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看主库同步状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql -u USER -p PASSWD -h MASTER_HOST -P MASTER_PORT \
  -e &amp;quot;show master status \G;&amp;quot;
mysql -u USER -p PASSWD -h SLAVE_HOST -P SLAVE_PORT \
  -e &amp;quot;show processlist \G;&amp;quot; | grep -i &#39;master&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查第二条命令输出是否类似“State: Master has sent all binlog to slave; waiting for binlog to be updated”这样。&lt;/p&gt;

&lt;p&gt;查看从库同步状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql -u USER -p PASSWD -h SLAVE_HOST -P SLAVE_PORT \
  -e &amp;quot;show slave status \G;&amp;quot;
mysql -u USER -p PASSWD -h SLAVE_HOST -P SLAVE_PORT \
  -e &amp;quot;show processlist \G;&amp;quot; | egrep -i &#39;(master|slave)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查命令输出是否包含类似下面这样的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Slave_IO_State: Waiting for master to send event
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it

State: Waiting for master to send event
State: Slave has read all relay log; waiting for the slave I/O thread to update it
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mysql主从切换&#34;&gt;MySQL主从切换&lt;/h2&gt;

&lt;p&gt;这里暂时还没有用到主从切换，不过参考资料&lt;a href=&#34;http://wsgzao.github.io/post/xtrabackup/&#34;&gt;XtraBackup不停机不锁表搭建MySQL主从同步实践&lt;/a&gt;中有写到主从切换的过程，复制粘贴一下以后好找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;#查看主库状态
show processlist;
Master has sent all binlog to slave; waiting for binlog to be updated
show master status \G

#从库停止 IO_THREAD 线程
stop slave IO_THREAD;
show processlist;
Slave has read all relay log; waiting for the slave I/O thread to update it
show slave status \G

#从库切换为主库
stop slave;
reset master;
reset slave all;
show master status \G

#激活帐户
SELECT DISTINCT CONCAT(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) AS query FROM mysql.user;
GRANT REPLICATION SLAVE ON *.* TO &#39;slave_passport&#39;@&#39;10.10.16.51&#39; IDENTIFIED BY &#39;slave_passport&#39;;
FLUSH PRIVILEGES;

#切换原有主库为从库
reset master;
reset slave all;

CHANGE MASTER TO
MASTER_HOST=&#39;10.10.16.24&#39;,
MASTER_USER=&#39;slave_passport&#39;,
MASTER_PASSWORD=&#39;slave_passport&#39;,
MASTER_PORT=3306,
MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,
MASTER_LOG_POS=804497686;

#检查主库
SHOW PROCESSLIST;
show master status \G

#启动从库
SHOW PROCESSLIST;
start slave;
show slave status \G
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2016-12-19更新-主从复制心跳和连接超时&#34;&gt;2016-12-19更新: 主从复制心跳和连接超时&lt;/h2&gt;

&lt;p&gt;实际运行过程中, 由于没有专门的人做运维, 从服务器也只是起备份作用, 偶尔发现从服务器已经没有跟主服务器同步, 数据滞后了很长时间了, 估计是跟公司网络环境不大稳定有关系.&lt;/p&gt;

&lt;p&gt;在网上了解到MySQL 5.5以上版本的主从复制还有一个心跳功能, 参考这里: &lt;a href=&#34;http://blog.csdn.net/JesseYoung/article/details/42914577&#34;&gt;MySQL运维-主从复制心跳&lt;/a&gt;. 果断打开心跳功能.&lt;/p&gt;

&lt;p&gt;连接从服务器, 执行下面指令配置心跳周期和连接超时:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; stop slave;
mysql&amp;gt; change master to master_heartbeat_period = 10;
mysql&amp;gt; set global slave_net_timeout = 25;
mysql&amp;gt; start slave;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过以下命令检查心跳状态:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql -uUSER -pPASSWORD -hHOST -PPORT -e &amp;quot;show status like &#39;slave%&#39;;&amp;quot;
    +----------------------------+--------+
    | Variable_name              | Value  |
    +----------------------------+--------+
    | Slave_heartbeat_period     | 10.000 |
    | Slave_last_heartbeat       |        |
    | Slave_open_temp_tables     | 0      |
    | Slave_received_heartbeats  | 0      |
    | Slave_retried_transactions | 0      |
    | Slave_running              | ON     |
    +----------------------------+--------+
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>[转载] 专栏：RabbitMQ从入门到精通</title>
      <link>http://hshsh.me/post/2016-04-24-rabbitmq-topic-articles/</link>
      <pubDate>Sun, 24 Apr 2016 22:48:11 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-24-rabbitmq-topic-articles/</guid>
      <description>

&lt;p&gt;最近有用到RabbitMQ，在网上搜到几篇介绍文章，除去CSDN的排版不说，文章内容还是很好的。&lt;/p&gt;

&lt;p&gt;原文网址：&lt;a href=&#34;http://blog.csdn.net/column/details/rabbitmq.html&#34;&gt;http://blog.csdn.net/column/details/rabbitmq.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是几篇文章的摘要，详情请跳转原文阅读。&lt;/p&gt;

&lt;h2 id=&#34;文章摘要&#34;&gt;文章摘要&lt;/h2&gt;

&lt;p&gt;RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-一-detailed-introduction-详细介绍-http-blog-csdn-net-anzhsoft-article-details-19563091&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19563091&#34;&gt;RabbitMQ消息队列（一）: Detailed Introduction 详细介绍&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？&lt;/li&gt;
&lt;li&gt;如何降低发送者和接收者的耦合度？&lt;/li&gt;
&lt;li&gt;如何让Priority高的接收者先接到数据？&lt;/li&gt;
&lt;li&gt;如何做到load balance？有效均衡接收者的负载？&lt;/li&gt;
&lt;li&gt;如何有效的将数据发送到相关的接收者？也就是说让接收者subscribe不同的数据，如何做有效的filter。&lt;/li&gt;
&lt;li&gt;如何做到可扩展，甚至将这个通信模块发到cluster上？&lt;/li&gt;
&lt;li&gt;如何保证接收者接收到了完整，正确的数据？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-二-hello-world-http-blog-csdn-net-anzhsoft-article-details-19570187&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19570187&#34;&gt;RabbitMQ消息队列（二）：“Hello, World”&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;首先复习一下上篇所学：RabbitMQ实现了AMQP定义的消息队列。它实现的功能“非常简单”：从Producer接收数据然后传递到Consumer。它能保证多并发，数据安全传递，可扩展。&lt;/p&gt;

&lt;p&gt;和任何的Hello World一样，它们都不复杂。我们将会设计两个程序，一个发送Hello world，另一个接收这个数据并且打印到屏幕。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-三-任务分发机制-http-blog-csdn-net-anzhsoft-article-details-19607841&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19607841&#34;&gt;RabbitMQ消息队列（三）：任务分发机制&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在上篇文章中，我们解决了从发送端（Producer）向接收端（Consumer）发送“Hello World”的问题。在实际的应用场景中，这是远远不够的。从本篇文章开始，我们将结合更加实际的应用场景来讲解更多的高级用法。&lt;/p&gt;

&lt;p&gt;当有Consumer需要大量的运算时，RabbitMQ Server需要一定的分发机制来balance每个Consumer的load。试想一下，对于web application来说，在一个很多的HTTP request里是没有时间来处理复杂的运算的，只能通过后台的一些工作线程来完成。接下来我们分别讲解。&lt;/p&gt;

&lt;p&gt;应用场景就是RabbitMQ Server会将queue的Message分发给不同的Consumer以处理计算密集型的任务。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-四-分发到多consumer-publish-subscribe-http-blog-csdn-net-anzhsoft-article-details-19617305&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19617305&#34;&gt;RabbitMQ消息队列（四）：分发到多Consumer（Publish/Subscribe）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这篇文章中，我们将创建一个日志系统，它包含两个部分：第一个部分是发出log（Producer），第二个部分接收到并打印（Consumer）。我们将构建两个Consumer，第一个将log写到物理磁盘上；第二个将log输出的屏幕。&lt;/p&gt;

&lt;p&gt;RabbitMQ 的Messaging Model就是Producer并不会直接发送Message到queue。实际上，Producer并不知道它发送的Message是否已经到达queue。&lt;/p&gt;

&lt;p&gt;Producer发送的Message实际上是发到了Exchange中。它的功能也很简单：从Producer接收Message，然后投递到queue中。Exchange需要知道如何处理Message，是把它放到那个queue中，还是放到多个queue中？这个rule是通过Exchange的类型定义的。&lt;/p&gt;

&lt;p&gt;我们知道有三种类型的Exchange：direct, topic 和fanout。fanout就是广播模式，会将所有的Message都放到它所知道的queue中。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-五-routing-消息路由-http-blog-csdn-net-anzhsoft-article-details-19630147&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19630147&#34;&gt;RabbitMQ消息队列（五）：Routing 消息路由&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;上篇文章中，我们构建了一个简单的日志系统。接下来，我们将丰富它：能够使用不同的severity来监听不同等级的log。比如我们希望只有error的log才保存到磁盘上。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-六-使用主题进行消息分发-http-blog-csdn-net-anzhsoft-article-details-19633079&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19633079&#34;&gt;RabbitMQ消息队列（六）：使用主题进行消息分发&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在上篇文章中，我们实现了一个简单的日志系统。Consumer可以监听不同severity的log。但是，这也是它之所以叫做简单日志系统的原因，因为是仅仅能够通过severity设定。不支持更多的标准。&lt;/p&gt;

&lt;p&gt;比如syslog unix的日志工具，它可以通过severity (info/warn/crit&amp;hellip;) 和模块(auth/cron/kern&amp;hellip;)。这可能更是我们想要的：我们可以仅仅需要cron模块的log。&lt;/p&gt;

&lt;p&gt;为了实现类似的功能，我们需要用到topic exchange。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-七-适用于云计算集群的远程调用-rpc-http-blog-csdn-net-anzhsoft-article-details-19633107&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19633107&#34;&gt;RabbitMQ消息队列（七）：适用于云计算集群的远程调用（RPC）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在云计算环境中，很多时候需要用它其他机器的计算资源，我们有可能会在接收到Message进行处理时，会把一部分计算任务分配到其他节点来完成。那么，RabbitMQ如何使用RPC呢？在本篇文章中，我们将会通过其它节点来求斐波纳契完成示例。&lt;/p&gt;

&lt;p&gt;为了展示一个RPC服务是如何使用的，我们将创建一段很简单的客户端class。它将会向外提供名字为call的函数，这个call会发送RPC请求并且阻塞知道收到RPC运算的结果。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列的小伙伴-protobuf-google-protocol-buffer-http-blog-csdn-net-anzhsoft-article-details-19771671&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19771671&#34;&gt;RabbitMQ消息队列的小伙伴: ProtoBuf（Google Protocol Buffer）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;什么是ProtoBuf？&lt;/p&gt;

&lt;p&gt;一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。&lt;/p&gt;

&lt;p&gt;它可以作为RabbitMQ的Message的数据格式进行传输，由于是结构化的数据，这样就极大的方便了Consumer的数据高效处理。当然了你可能说使用XML不也可以吗？与XML相比，ProtoBuf有以下优势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;size小了3-10倍&lt;/li&gt;
&lt;li&gt;速度快了20-100倍&lt;/li&gt;
&lt;li&gt;易于编程&lt;/li&gt;
&lt;li&gt;减小了语义的歧义&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;rabbitmq消息队列-九-publisher的消息确认机制-http-blog-csdn-net-anzhsoft-article-details-21603479&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/21603479&#34;&gt;RabbitMQ消息队列（九）：Publisher的消息确认机制&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在前面的文章中提到了queue和consumer之间的消息确认机制：通过设置ack。那么Publisher能不到知道他post的Message有没有到达queue，甚至更近一步，是否被某个Consumer处理呢？毕竟对于一些非常重要的数据，可能Publisher需要确认某个消息已经被正确处理。&lt;/p&gt;

&lt;p&gt;在我们的系统中，我们没有是实现这种确认，也就是说，不管Message是否被Consume了，Publisher不会去关心。他只是将自己的状态publish给上层，由上层的逻辑去处理。如果Message没有被正确处理，可能会导致某些状态丢失。但是由于提供了其他强制刷新全部状态的机制，因此这种异常情况的影响也就可以忽略不计了。&lt;/p&gt;

&lt;p&gt;对于某些异步操作，比如客户端需要创建一个FileSystem，这个可能需要比较长的时间，甚至要数秒钟。这时候通过RPC可以解决这个问题。因此也就不存在Publisher端的确认机制了。&lt;/p&gt;

&lt;p&gt;那么，有没有一种机制能保证Publisher能够感知它的Message有没有被处理的？答案肯定的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>welcome to my hugo blog</title>
      <link>http://hshsh.me/post/2016-04-24-welcome-to-my-hugo-blog/</link>
      <pubDate>Sun, 24 Apr 2016 11:36:14 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-24-welcome-to-my-hugo-blog/</guid>
      <description>

&lt;p&gt;Welcome to my new &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; blog.&lt;/p&gt;

&lt;h2 id=&#34;为什么又建一个博客&#34;&gt;为什么又建一个博客&lt;/h2&gt;

&lt;p&gt;其实在07年开始的时候就建立了自己的博客，当时是在百度空间，内容主要是网上转载的学习资料。百度空间的排版真心费劲。后来百度空间倒下了，内容也都没有了。&lt;/p&gt;

&lt;p&gt;后来，GAE开始流行，作为Google忠实的粉丝和一个不折腾会死星人，当然得尝试尝试了。博客搭建好了，但是却没写出什么东西来，一两年时间里，也只有寥寥数篇生活杂记。这时候，我还买了一个自己的域名。&lt;/p&gt;

&lt;p&gt;时间大概是08年。又后来，Google退出中国，服务越来越难访问，也就没管那个站了，甚至现在都想不起来GAE上的那个二级域名是什么了。&lt;/p&gt;

&lt;p&gt;然后，Github很火，很多人开始在Github Pages上搭建博客。了解之后，一下子又被吸引了，用Markdown书写的感觉特别爽，排版也漂亮，对代码高亮等扩展功能的支持也好。大概是13年的时候使用Jekyll在Github Pages上又搭建了一个博客，还把以前的一些乱七八糟的文字整理了过去，并且绑定了之前买的域名。这个网站现在还能访问：&lt;a href=&#34;http://www.imwsh.net&#34;&gt;http://www.imwsh.net&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;（号外：要是有人喜欢&lt;code&gt;imwsh.net&lt;/code&gt;这个域名，联系我哈，便宜出售~ ~）&lt;/p&gt;

&lt;p&gt;Github Pages上的博客搭好了，但是我却是跟IT越走越远，工作在传统行业，又跑去拉萨野了一趟，人又懒得很，也就不了了之了。&lt;/p&gt;

&lt;p&gt;今年过完春节，贼心不死的我又在纠结工作的事情，最终在老婆和朋友的鼓励下，成功的找到了一份后端程序员的工作。于是乎又开始学习恶补，又惦记起来博客的事情，翻翻硬盘，那个博客的源码都已经被删了，而且对Ruby也不熟悉。当时正在学习Flask Web开发，干脆自己用Python写一个得了。&lt;/p&gt;

&lt;p&gt;于是乎，互联网上便又多了一个博客程序：&lt;a href=&#34;https://github.com/jxskiss/meblog&#34;&gt;meblog&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这个博客程序简单漂亮，也非常好用，代码高亮、标签、分类什么的都支持，我自己对这个博客程序也很满意，还写了一个命令行推送发布工具，然后爽歪歪的把博客部署到SAE上去了，好事不长久，还不到一个月，在新浪云上充值的豆子就用完了，于是乎，拉倒吧……不过，这个meblog却真的是麻雀很小，五脏俱全，如果有人需要一个Python写的博客程序的话，我强烈推荐！如果还能打开的话，你可以看看她长什么样：&lt;a href=&#34;http://hshsh.applinzi.com&#34;&gt;http://hshsh.applinzi.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后，了解到了hugo这个静态博客生成器，markdown书写、单文件执行、没有依赖，同样可以方便的部署到Github Pages。看起来就很好用啊，官方网站做的还很漂亮，干脆再搭一个博客算了。这便是现在这个博客了，轻车熟路整理markdown文件，生成网站，调整CSS样式，绑定域名，半天时间，网站就上线了。&lt;/p&gt;

&lt;p&gt;另外，我还简单写了一个&lt;a href=&#34;https://github.com/jxskiss/hshsh.me/blob/master/fabfile.py&#34;&gt;自动部署脚本&lt;/a&gt;，可以自动转换发布Jupyter Notebook文件哦。用Jupyter Notebook写笔记，然后自动发布称漂亮的网站，简直爽的不要不要的 ~ ~&lt;/p&gt;

&lt;p&gt;至于搭建博客的过程，并不复杂，这里就不复制粘贴了，直接看下面的参考资料吧。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hugo - Hosting on GitHub Pages&lt;/a&gt;：这个是主要参考资料&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ulricqin.com/post/how-to-use-hugo/&#34;&gt;使用Hugo搭建免费个人Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jianshu.com/p/b66754c0baa6&#34;&gt;使用Hugo + Github搭建个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hugo安装问题&#34;&gt;Hugo安装问题&lt;/h2&gt;

&lt;p&gt;Hugo官网上有编译好的二进制包发布，如果能直接下载到，最好不过了，放到执行文件路径里就可以了。&lt;/p&gt;

&lt;p&gt;很可能的情况是根本下载不下来！！！这时候可以选择使用源码安装，也就是GO GET命令了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上没有代理你是完不成这条命令的，有了代理，还需要设置GIT和WGET等工具使用这个代理，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global http.proxy http://127.0.0.1:7777
# 如果在Windows上，下面这条命令中的export换成set
export HTTP_PROXY=http://127.0.0.1:7777
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pandas学习笔记（二）：基本数据结构</title>
      <link>http://hshsh.me/post/2016-04-13-python-pandas-notes-02/</link>
      <pubDate>Wed, 13 Apr 2016 18:02:04 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-13-python-pandas-notes-02/</guid>
      <description>

&lt;p&gt;Pandas的开发者是：&lt;a href=&#34;http://wesmckinney.com&#34;&gt;Wes McKinney&lt;/a&gt;，这位大牛工作的时候没有顺手的工具，就决定自己顺手写一个出来。&lt;/p&gt;

&lt;p&gt;Pandas具有但不限于一下特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;具备按轴自动或显式数据对齐功能的数据结构，这可以防止许多由于数据没有对齐以及来自不同数据源（索引方式不同）的数据而导致的常见错误；&lt;/li&gt;
&lt;li&gt;集成时间序列功能；&lt;/li&gt;
&lt;li&gt;既能处理时间序列数据也能处理非时间序列数据的数据结构；&lt;/li&gt;
&lt;li&gt;数学运算和约简（比如对某个轴求和）可以根据不同的元数据（轴编号）执行；&lt;/li&gt;
&lt;li&gt;可以灵活处理缺失数据；&lt;/li&gt;
&lt;li&gt;合并及其他出现在常见数据库（例如基于SQL的）中的关系型运算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pandas的导入约定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pandas import Series, DataFrame
import pandas as pd
import numpy as np
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;series&#34;&gt;Series&lt;/h2&gt;

&lt;p&gt;Series可以使用列表初始化，初始化时还可以指定索引名称。&lt;/p&gt;

&lt;p&gt;Series可以被看成时一个定长的有序字典，因为它时索引值到数据值的一个映射，它可以用在许多原本需要字典参数的函数中。&lt;/p&gt;

&lt;p&gt;如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series。通过指定 &lt;code&gt;index&lt;/code&gt; 可以只选择需要的对象，缺失值使用NaN自动填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj = Series([4, 7, -5, 3])
obj, obj.values, obj.index

obj = Series([4, 7, -5, 3], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])

obj[obj &amp;gt; 0]
obj * 2
np.exp(obj)

&#39;b&#39; in obj

sdata = {&#39;Ohio&#39;: 35000, &#39;Texas&#39;: 71000, &#39;Oregon&#39;: 16000, &#39;Utah&#39;: 5000}
sdata = Series(sdata)
sdata
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;states = [&#39;California&#39;, &#39;Ohio&#39;, &#39;Oregon&#39;, &#39;Texas&#39;]
obj = Series(sdata, index=states)
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对很多应用而言，Series最重要的一个功能是：在算数运算中会自动对齐不同索引的数据。&lt;/p&gt;

&lt;p&gt;Series对象本身及其索引都有一个 &lt;code&gt;name&lt;/code&gt; 属性，该属性跟Pandas其他的关键功能关系非常密切。&lt;/p&gt;

&lt;p&gt;Series的索引可以通过赋值的方式就地修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sdata + obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj.name = &#39;population&#39;
obj.index.name = &#39;state&#39;
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj.index = [&#39;Tibet&#39;, &#39;Beijing&#39;, &#39;Tianjin&#39;, &#39;Henan&#39;]
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Tibet          NaN
Beijing    35000.0
Tianjin    16000.0
Henan      71000.0
Name: population, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dataframe&#34;&gt;DataFrame&lt;/h2&gt;

&lt;p&gt;DataFrame是一个表格型的数据结构，含有一组有序的列，每列可以时不同的值类型（数值、字符串、布尔值等）。&lt;/p&gt;

&lt;p&gt;DataFrame既有行索引也有列索引，它可以被看成由Series组成的字典（共用同一个索引）。&lt;/p&gt;

&lt;p&gt;跟其他类似的数据结构相比（如R的 &lt;code&gt;data.frame&lt;/code&gt;），DataFrame中面向行和面向列的操作基本上时平衡的。&lt;/p&gt;

&lt;p&gt;构建DataFrame的办法有很多种，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典，DataFrame会自动加上索引，且所有列会被有序排列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = {&#39;state&#39;: [&#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Nevada&#39;, &#39;Nevada&#39;],
            &#39;year&#39;: [2000, 2001, 2002, 2001, 2002],
            &#39;pop&#39;: [1.5, 1.7, 3.6, 2.4, 2.9]}
frame = DataFrame(data)
frame
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列，如果传入的列在数据中找不到，则会产生NaN值。&lt;/p&gt;

&lt;p&gt;除了指定列序列，还可以指定行索引序列，而不是使用默认的数字索引。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2 = DataFrame(data, columns=[&#39;year&#39;, &#39;state&#39;, &#39;pop&#39;, &#39;debt&#39;],
                   index=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;])
frame2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;debt&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;one&lt;/th&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;two&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;three&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;four&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;five&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。&lt;/p&gt;

&lt;p&gt;返回的Series拥有原DataFrame相同的索引，而且其 &lt;code&gt;name&lt;/code&gt; 属性也已经被相应的设置好狼（抽取的列名）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2[&#39;state&#39;]  # or frame2.state
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
Name: state, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行也可以通过位置或名称的方式进行获取，比如用索引字段 &lt;code&gt;ix&lt;/code&gt; 获取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2.ix[&#39;three&#39;]  # or frame2.ix[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列可以通过赋值的方式进行修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用标量赋值会赋值给整列；&lt;/li&gt;
&lt;li&gt;使用列表或数组给某个列赋值时，其长度必须跟DataFrame的长度相匹配（如果不匹配，会抛出ValueError异常）；&lt;/li&gt;
&lt;li&gt;如果赋值的是一个Series，会精确匹配DataFrame的索引，所有空位都将被填上缺失值 &lt;code&gt;NaN&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;为不存在的列赋值会创建出一个新列；&lt;/li&gt;
&lt;li&gt;关键字 &lt;code&gt;del&lt;/code&gt; 用于删除列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，任何对返回的Series的就地修改全部会反应到源DataFrame上。通过Series的 &lt;code&gt;copy&lt;/code&gt; 方法可以显式的复制列。&lt;/p&gt;

&lt;p&gt;除了接受由数组组成的字典外，DataFrame还可以接受其他很多中数据输入：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;嵌套字典，如：{&amp;lsquo;Nevada&amp;rsquo;: {2001: 2.4, 2002: 2.9}, &amp;lsquo;Ohio&amp;rsquo;: {2000: 1.5, 2001: 1.7, 2002: 3.6}}&lt;/li&gt;
&lt;li&gt;二维ndarray：数据矩阵，还可以传入行标和列标&lt;/li&gt;
&lt;li&gt;由数组、列表或元组组成的字典：每个序列会变成DataFrame的一列，所有序列的长度必须相同&lt;/li&gt;
&lt;li&gt;NumPy的结构化／记录数组：类似于“由数组组成的字典”&lt;/li&gt;
&lt;li&gt;由Series组成的字典：每个Series会成为一列，如果没有显式指定索引，则各Series的索引会被合并成结果的行索引&lt;/li&gt;
&lt;li&gt;字典或Series的列表：各项将会成为DataFrame的一行，字典键或Series索引的并集将会成为DataFrame的列标&lt;/li&gt;
&lt;li&gt;由列表或元组组成的列表：类似于“二维ndarray“&lt;/li&gt;
&lt;li&gt;另一个DataFrame：该DataFrame的索引将会被沿用，除非显式的指定列其他索引&lt;/li&gt;
&lt;li&gt;NumPy的MaskedArray：类似于“二维ndarray”的情况，只是掩码值在结果DataFrame中会变成NA/缺失值&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;索引对象&#34;&gt;索引对象&lt;/h2&gt;

&lt;p&gt;Index对象是Pandas数据模型的重要组成部分。&lt;/p&gt;

&lt;p&gt;Pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index对象。&lt;/p&gt;

&lt;p&gt;Index对象是不可修改的（immutable），因此用户不能对其进行修改。Index对象的不可修改性非常重要，因为这样才能使Index对象在多个数据结构之间安全共享。&lt;/p&gt;

&lt;p&gt;Pandas库中内置了一些常用的Index类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Index：最泛化的Index对象，将轴标签表示为一个由Python对象组成的NumPy数组，&lt;/li&gt;
&lt;li&gt;Int64Index：针对整数的特殊Index，&lt;/li&gt;
&lt;li&gt;MultiIndex：“层次化”索引对象，表示单个轴上的多层索引，可以看作由元组组成的数组，&lt;/li&gt;
&lt;li&gt;DatetimeIndex：存储纳秒级的时间戳（用NumPy的 &lt;code&gt;datetime64&lt;/code&gt; 类型表示），&lt;/li&gt;
&lt;li&gt;PeriodIndex：针对Period数据（时间间隔）的特殊Index&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这些常用的Index类型，Index甚至还可以被继承从而实现特别的轴索引功能。&lt;/p&gt;

&lt;p&gt;Index对象长得很像数组，功能也很类似一个固定大小的集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2.index.name = &#39;number&#39;
frame2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;debt&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;number&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;one&lt;/th&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;two&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;three&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;four&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;five&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;state&#39; in frame2.columns or &#39;one&#39; in frame2.index
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。下面是一些比较常用的函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;append：连接另一个Index对象，产生一个新的 Index&lt;/li&gt;
&lt;li&gt;diff：计算差集，并得到一个新的 Index&lt;/li&gt;
&lt;li&gt;intersection：计算交集&lt;/li&gt;
&lt;li&gt;union：计算并集&lt;/li&gt;
&lt;li&gt;isin：计算一个指示各值是否都包含在参数集合中的布尔型数组&lt;/li&gt;
&lt;li&gt;delete：删除指定索引处的元素，并得到新的 Index&lt;/li&gt;
&lt;li&gt;drop：删除传入的值，并得到新的 Index&lt;/li&gt;
&lt;li&gt;insert：将元素插入到索引处，并得到新的 Index&lt;/li&gt;
&lt;li&gt;is_monotonic：当各元素均大于等于前一个元素时，返回 True&lt;/li&gt;
&lt;li&gt;is_unique：当Index没有重复值时，返回 True&lt;/li&gt;
&lt;li&gt;unique：计算Index中唯一值的数组&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pandas学习笔记（一）：CSV数据加载保存</title>
      <link>http://hshsh.me/post/2016-04-12-python-pandas-notes-01/</link>
      <pubDate>Tue, 12 Apr 2016 18:52:25 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-12-python-pandas-notes-01/</guid>
      <description>

&lt;h2 id=&#34;加载csv数据&#34;&gt;加载CSV数据&lt;/h2&gt;

&lt;p&gt;很多数据都存储在CSV文件中，Pandas 为读取提供了一个强大的 &lt;code&gt;read_csv&lt;/code&gt; 函数，这个函数接受很多可选参数，通过参数控制数据加载的方式，以及一些基本的清理工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.read_csv(filepath_or_buffer, sep=&#39;,&#39;, delimiter=None, header=&#39;infer&#39;,
    names=None, index_col=None, usecols=None, squeeze=False, prefix=None,
    mangle_dupe_cols=True, dtype=None, engine=None, converters=None,
    true_values=None, false_values=None, skipinitialspace=False,
    skiprows=None, skipfooter=None, nrows=None, na_values=None,
    keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True,
    parse_dates=False, infer_datetime_format=False, keep_date_col=False,
    date_parser=None, dayfirst=False, iterator=False, chunksize=None,
    compression=&#39;infer&#39;, thousands=None, decimal=&#39;.&#39;, lineterminator=None,
    quotechar=&#39;&amp;quot;&#39;, quoting=0, escapechar=None, comment=None, encoding=None,
    dialect=None, tupleize_cols=False, error_bad_lines=True,
    warn_bad_lines=True, skip_footer=0, doublequote=True,
    delim_whitespace=False, as_recarray=False, compact_ints=False,
    use_unsigned=False, low_memory=True, buffer_lines=None, memory_map=False,
    float_precision=None)

Returns
    result : DataFrame or TextParser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多参数都是非常有用的，简要记录一下（详细文档请参考 &lt;code&gt;help(pd.read_csv)&lt;/code&gt; 及官方文档）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;filepath_or_buffer&lt;/code&gt;：参数名字本身反映了功能

&lt;ul&gt;
&lt;li&gt;这里可以接受一个文件名，或者一个URL，&lt;/li&gt;
&lt;li&gt;也可以接受一个打开的文件句柄，&lt;/li&gt;
&lt;li&gt;或者其他任何提供了&lt;code&gt;read&lt;/code&gt;方法的对象，&lt;/li&gt;
&lt;li&gt;举个栗子：某个URL输出CSV，但是需要验证密码，那么就没法让 &lt;code&gt;read_csv&lt;/code&gt; 直接读取URL，但是可以使用 &lt;code&gt;urlopen&lt;/code&gt; 发送附带了验证信息的Request，并把返回的 Response 对象传给 &lt;code&gt;read_csv&lt;/code&gt; 函数，进而通过 Response 对象的 &lt;code&gt;read&lt;/code&gt; 方法加载数据；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sep&lt;/code&gt; 和 &lt;code&gt;delimiter&lt;/code&gt;：这两个参数是一个意思，&lt;code&gt;delimiter&lt;/code&gt;是&lt;code&gt;sep&lt;/code&gt;的别名；如果指定为 &lt;code&gt;\t&lt;/code&gt;（制表符）的话，就可以实现 &lt;code&gt;read_table&lt;/code&gt; 的默认功能；支持使用正则表达式来匹配某些不标准的CSV文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;names&lt;/code&gt;：配合使用指定加载后的列名；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse_dates&lt;/code&gt;：boolean or list of ints or names or list of lists or dict, default False. 这个参数指定对CSV文件中日期序列的处理方式：

&lt;ul&gt;
&lt;li&gt;默认为False，原样加载，不解析日期时间，&lt;/li&gt;
&lt;li&gt;可以为True，尝试解析日期索引，&lt;/li&gt;
&lt;li&gt;可以为数字或 &lt;code&gt;names&lt;/code&gt; 的列表，解析指定的列为时间序列，&lt;/li&gt;
&lt;li&gt;可以为以列表为元素的列表，解析每个子列表中的字段组合为时间序列，&lt;/li&gt;
&lt;li&gt;可以为值为列表的字典，解析每个列表中的字段组合为时间序列，并命名为字典中对应的键值；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date_parser&lt;/code&gt;：可以指定一个自定义函数解析日期；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keep_date_col&lt;/code&gt;：解析出日期序列后，是否保留原来的列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dayfirst&lt;/code&gt;：boolean, default False, DD/MM format dates, international and European format；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterator&lt;/code&gt;：boolean, default False，Return TextFileReader object for iteration or getting chunks with &lt;code&gt;get_chunk()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding&lt;/code&gt;：指定读取或写入CSV文件时使用的字符集，支持 &lt;a href=&#34;https://docs.python.org/3/library/codecs.html#standard-encodings&#34;&gt;codecs 包中的标准字符集&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index_col&lt;/code&gt;：数字、列名或列表，数字或列名指定某一列作为索引，列表制定某几列作为 DataFrame 的层次索引；&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;skip_initialspace&lt;/code&gt;, &lt;code&gt;skiprows&lt;/code&gt;, &lt;code&gt;skipfooter&lt;/code&gt;, &lt;code&gt;comment&lt;/code&gt;, &lt;code&gt;float_precision&lt;/code&gt;等参数做一些基本的清理动作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面举个例子来简单演示一下 &lt;code&gt;parse_dates&lt;/code&gt; 和 &lt;code&gt;data_parser&lt;/code&gt; 的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
from tempfile import TemporaryFile

mycsv = [&amp;quot;date,hour,A1,A2,A3,A4,A5,A6,date2,hour2&amp;quot;,
    &amp;quot;20150102,1,117,85,109,132,166,113,20160102,2&amp;quot;,
    &amp;quot;20150102,2,88,34,82,100,126,85,20160102,3&amp;quot;,
    &amp;quot;20150102,3,48,54,38,50,55,46,20160102,4&amp;quot;,
    &amp;quot;20150102,4,141,120,154,148,175,114,20160102,5&amp;quot;,
    &amp;quot;20150102,5,91,64,74,71,84,70,20160102,6&amp;quot;,
    &amp;quot;20150102,6,45,10,46,20,68,44,20160102,7&amp;quot;]

tmp_csv_file = TemporaryFile()
tmp_csv_file.write(&#39;\n&#39;.join(mycsv))
tmp_csv_file.flush()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;从上面的示例中，可以看到使用默认参数时，&lt;code&gt;read_csv&lt;/code&gt; 函数不会尝试解析日期，这样可以提高文件的加载速度。&lt;/p&gt;

&lt;p&gt;但是第一列日期和第二列小时构成了我们需要的时间戳，加载了CSV后我们需要进行处理，那能不能在加载CSV的时候就直接解析出来呢？我们可以试一试 &lt;code&gt;parse_dates&lt;/code&gt; 参数，把第一列和第二列的索引组成一个列表传给 &lt;code&gt;parse_dates&lt;/code&gt; 参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, parse_dates=[0, 1])
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;我们看到第一列被成功的解析成了日期数据，但是并没有按照我们想象的那样把第一列和第二列一起解析成一个日期时间对象。&lt;/p&gt;

&lt;p&gt;这是因为我们&lt;strong&gt;传递参数的姿势不对&lt;/strong&gt;，正确的应该是这样：&lt;code&gt;parse_dates=[[0, 1]]&lt;/code&gt;，再试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, parse_dates=[[0, 1]])
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date_hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;20150102 1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;20150102 2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;20150102 3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;20150102 4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;20150102 5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;20150102 6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Opps！虽然第一列和第二列合并到一起了，但是并没有成功的解析成日期时间对象。因为这个格式真的没人看得懂是一个日期时间对象啊！！！&lt;/p&gt;

&lt;p&gt;那就没有办法在加载CSV的时候就解析时间序列的方法了吗？&lt;/p&gt;

&lt;p&gt;答案是有的。&lt;code&gt;read_csv&lt;/code&gt; 还有一个参数：&lt;code&gt;date_parser&lt;/code&gt;，我们可以自己写一个日期时间对象解析函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime

def my_date_parser(dt, hour):
    return datetime(int(dt[0:4]), int(dt[4:6]), int(dt[6:8]), int(hour))

tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, date_parser=my_date_parser,
                 parse_dates={&#39;time&#39;: [0, 1], &#39;time2&#39;: [&#39;date2&#39;, &#39;hour2&#39;]},
                 index_col=&#39;time&#39;)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;time2&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;time&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 01:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 02:00:00&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 02:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 03:00:00&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 03:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 04:00:00&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 04:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 05:00:00&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 05:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 06:00:00&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 06:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 07:00:00&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Bingo！是不是搞定了。这样加载并解析时间序列的效率也比加载后使用循环或列表解析处理的效率高的多了。&lt;/p&gt;

&lt;p&gt;上面这段示例代码中，还演示了解析多列时间序列，可以按照列的索引指定要解析的列，也可以按照列名来制定要解析的列，另外，还演示了使用 &lt;code&gt;index_col&lt;/code&gt; 参数指定 DataFrame 索引的用法。&lt;/p&gt;

&lt;h2 id=&#34;保存csv数据&#34;&gt;保存CSV数据&lt;/h2&gt;

&lt;p&gt;除了加载CSV数据很方便之外，Pandas 的 DataFrame 类一个很方便的 &lt;code&gt;to_csv&lt;/code&gt; 方法，可以把数据保存到CSV文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.DataFrame.to_csv(self, path_or_buf=None, sep=&#39;,&#39;, na_rep=&#39;&#39;,
    float_format=None, columns=None, header=True, index=True, index_label=None,
    mode=&#39;w&#39;, encoding=None, compression=None, quoting=None, quotechar=&#39;&amp;quot;&#39;, 
    line_terminator=&#39;\n&#39;, chunksize=None, tupleize_cols=False, date_format=None,
    doublequote=True, escapechar=None, decimal=&#39;.&#39;, **kwds)
    
unbound pandas.core.frame.DataFrame method:
    Write DataFrame to a comma-separated values (csv) file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，默认输出就是标准的逗号分割的CSV文件，跟 &lt;code&gt;read_csv&lt;/code&gt; 函数一样，这个函数同样有很多可选参数控制输出。&lt;/p&gt;

&lt;p&gt;除了输出到CSV外，DataFrame 还有很多输出到其他格式的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[meth for meth in dir(pd.DataFrame) if meth.startswith(&#39;to_&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;to_clipboard&#39;,
 &#39;to_csv&#39;,
 &#39;to_dense&#39;,
 &#39;to_dict&#39;,
 &#39;to_excel&#39;,
 &#39;to_gbq&#39;,
 &#39;to_hdf&#39;,
 &#39;to_html&#39;,
 &#39;to_json&#39;,
 &#39;to_latex&#39;,
 &#39;to_msgpack&#39;,
 &#39;to_panel&#39;,
 &#39;to_period&#39;,
 &#39;to_pickle&#39;,
 &#39;to_records&#39;,
 &#39;to_sparse&#39;,
 &#39;to_sql&#39;,
 &#39;to_stata&#39;,
 &#39;to_string&#39;,
 &#39;to_timestamp&#39;,
 &#39;to_wide&#39;,
 &#39;to_xarray&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路漫漫其修远兮～～我将慢慢去求索～～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python代理类两例</title>
      <link>http://hshsh.me/post/2016-04-10-python-proxy-class-examples/</link>
      <pubDate>Sun, 10 Apr 2016 23:30:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-10-python-proxy-class-examples/</guid>
      <description>

&lt;p&gt;最近遇到MySQL的连接断开，MySQLdb报&amp;rsquo;(2006, MySQL server has gone away.)&amp;lsquo;错误的问题。&lt;/p&gt;

&lt;p&gt;问题发生的环境是，客户端使用了长连接，程序启动的时候使用MySQLdb模块的connect方法建立一个数据库连接，程序运行期间一直使用这个连接。对于请求比较多的服务程序来说，这个方法不会出现问题，因为MySQL默认连接超时的时间设定是8小时，所以连接不会超时断开，也就不会报这个错误了。但是作为一个调试服务，请求频率可能低于8小时，就导致错误了。&lt;/p&gt;

&lt;p&gt;由于不想修改很多具体实现的代码，所以使用&lt;strong&gt;代理类&lt;/strong&gt;的方法对这个程序打了个补丁解决问题。&lt;/p&gt;

&lt;p&gt;另外 SQLAlchemy 中的 &lt;code&gt;scoped_session&lt;/code&gt; 也是一个代理类，实现也很有意思，这里一起分享一下这两个代理类。&lt;/p&gt;

&lt;h2 id=&#34;mysqldb-connection-代理类&#34;&gt;MySQLdb Connection 代理类&lt;/h2&gt;

&lt;p&gt;先看看出问题的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import MySQLdb
conn = MySQLdb.connect(host=&#39;host&#39;, port=&#39;port&#39;,
                       user=&#39;user&#39;, passwd=&#39;passwd&#39;, db=&#39;db&#39;)

def use_mysql():
    cursor = conn.cursor()
    cursor.execute(&#39;do something with mysql database;&#39;)
    cursor.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MySQLdb.connect&lt;/code&gt;函数返回的是一个&lt;code&gt;Connection&lt;/code&gt;对象，当操作频率大于8个小时的时候，MySQL服务器就会关闭连接，然后下一次执行 &lt;code&gt;cursor = conn.cursor()&lt;/code&gt; 的时候，就会报连接丢失的错误。为了既使用长连接，又能避免这个错误，我们可以封装一个&lt;code&gt;Connection&lt;/code&gt;类的代理类，重载 &lt;code&gt;cursor&lt;/code&gt; 方法，当有新的请求的时候，先检查连接是否还在，如果连接丢失的话，就重新连接数据库，然后再调用 &lt;code&gt;Connection&lt;/code&gt; 类的 &lt;code&gt;cursor&lt;/code&gt; 方法并返回结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import MySQLdb
from MySQLdb.connections import Connection

class ProxyConnection(Connection):
    def __init__(self, *args, **kwargs):
        # 保存数据库连接参数以备丢失时候重新连接
        self._proxy_args = args
        self._proxy_kwargs = kwargs
        super(ProxyConnection, self).__init__(*args, **kwargs)

    def cursor(self, cursorclass=None):
        try:
            self.ping()
        except MySQLdb.OperationalError:
            super(ProxyConnection, self).__init__(*self._proxy_args, **self._proxy_kwargs)
        return super(ProxyConnection, self).cursor(cursorclass)

conn = ProxyConnection(host=&#39;host&#39;, port=&#39;port&#39;,
                       user=&#39;user&#39;, passwd=&#39;passwd&#39;, db=&#39;db&#39;)

def use_mysql():
    cursor = conn.cursor()
    cursor.execute(&#39;do something with mysql database;&#39;)
    cursor.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代理类，只重载 &lt;code&gt;cursor()&lt;/code&gt; 这一个方法，其他方法直接继承自父类 &lt;code&gt;Connection&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样就解决了MySQL数据库连接丢失的问题。但是这个方法并不是完美的，主要的缺点是每次处理新的请求时，都要 &lt;code&gt;ping()&lt;/code&gt; 一下，当请求比较多的时候，会增加不必要的开支。不过如果真的请求多的话，也就不会出现这个问题了。作为低请求频次服务的解决方法，这个代理类用起来还是很方便的。&lt;/p&gt;

&lt;p&gt;相对于这种粗糙的方法，SQLAlchemy中 &lt;code&gt;scoped_session&lt;/code&gt; 类对 Session 类的代理实现就精巧的多了，而且它并没有从被代理的 &lt;code&gt;session&lt;/code&gt; 类继承，而是一个完全独立的类（实际上&lt;code&gt;scoped_session&lt;/code&gt;是一种 &lt;a href=&#34;http://martinfowler.com/eaaCatalog/registry.html&#34;&gt;Registry 设计模式&lt;/a&gt;，实现了一些高级功能，不过这里暂时只看它的代理作用）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2016-05-20更新：&lt;/p&gt;

&lt;p&gt;除了每次调用cursor方法获取游标时，都ping一下之外，还可以给MySQL的连接代理类增加一个超时机制，只有超时的时候才触发ping动作，这样可以兼顾道效率。&lt;/p&gt;

&lt;p&gt;下面是实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MySQLConnection(MySQLdb.connections.Connection):
    def __init__(self, *args, **kwargs):
        # set timeout to avoid (2006, &#39;MySQL server has gone away&#39;) problem
        # mysql close connection after 8 hours without activity by default
        self._recycle = kwargs.pop(&#39;recycle&#39;, None) or 7.5 * 3600
        self._last_time = time.time()
        # store connection parameters to reconnect
        self._proxy_args = args
        self._proxy_kwargs = kwargs
        super(MySQL, self).__init__(*args, **kwargs)

    def cursor(self, cursorclass=None):
        if time.time() - self._last_time &amp;gt; self._recycle:
            try:
                self.ping()
            except MySQLdb.OperationalError:
                super(MySQLConnection, self).__init__(*self._proxy_args, **self._proxy_kwargs)
        self._last_time = time.time()
        return super(MySQL, self).cursor(cursorclass)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;sqlalchemy-代理类-scoped-session&#34;&gt;SQLAlchemy 代理类 &lt;code&gt;scoped_session&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 的 Session 类是 SQLAlchemy ORM 模型对数据库操作的主要接口，定义了&lt;code&gt;query&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;, &lt;code&gt;refresh&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;等方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-pyhton&#34;&gt;# file: sqlalchemy/orm/session.py

class Session(_SessionClassMethods):
    &amp;quot;&amp;quot;&amp;quot;Manages persistence operations for ORM-mapped objects.

    The Session&#39;s usage paradigm is described at :doc:`/orm/session`.
    &amp;quot;&amp;quot;&amp;quot;

    public_methods = (
        &#39;__contains__&#39;, &#39;__iter__&#39;, &#39;add&#39;, &#39;add_all&#39;, &#39;begin&#39;, &#39;begin_nested&#39;,
        &#39;close&#39;, &#39;commit&#39;, &#39;connection&#39;, &#39;delete&#39;, &#39;execute&#39;, &#39;expire&#39;,
        &#39;expire_all&#39;, &#39;expunge&#39;, &#39;expunge_all&#39;, &#39;flush&#39;, &#39;get_bind&#39;,
        &#39;is_modified&#39;, &#39;bulk_save_objects&#39;, &#39;bulk_insert_mappings&#39;,
        &#39;bulk_update_mappings&#39;,
        &#39;merge&#39;, &#39;query&#39;, &#39;refresh&#39;, &#39;rollback&#39;,
        &#39;scalar&#39;)

    # def __init__(...):
    #     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Session类的对象可以通过 &lt;code&gt;sessionmaker(bind=engine)()&lt;/code&gt; 建立，由使用数据库的模块建立、使用，并自行管理。&lt;code&gt;scoped_session&lt;/code&gt; 类给 Session 对象提供了一层透明代理，既可以像使用 Session 对象一样使用，又可以对 Session 对象进行统一管理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类的实现代码并不复杂，而且相当的精巧，下面是全部代码（为方便阅读，已删除文档字符串）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file: sqlalchemy/orm/scoping.py

class scoped_session(object):
    session_factory = None

    def __init__(self, session_factory, scopefunc=None):
        self.session_factory = session_factory
        if scopefunc:
            self.registry = ScopedRegistry(session_factory, scopefunc)
        else:
            self.registry = ThreadLocalRegistry(session_factory)

    def __call__(self, **kw):
        if kw:
            scope = kw.pop(&#39;scope&#39;, False)
            if scope is not None:
                if self.registry.has():
                    raise sa_exc.InvalidRequestError(
                        &amp;quot;Scoped session is already present; &amp;quot;
                        &amp;quot;no new arguments may be specified.&amp;quot;)
                else:
                    sess = self.session_factory(**kw)
                    self.registry.set(sess)
                    return sess
            else:
                return self.session_factory(**kw)
        else:
            return self.registry()

    def remove(self):
        if self.registry.has():
            self.registry().close()
        self.registry.clear()

    def configure(self, **kwargs):
        if self.registry.has():
            warn(&#39;At least one scoped session is already present. &#39;
                 &#39; configure() can not affect sessions that have &#39;
                 &#39;already been created.&#39;)

        self.session_factory.configure(**kwargs)

    def query_property(self, query_cls=None):
        class query(object):
            def __get__(s, instance, owner):
                try:
                    mapper = class_mapper(owner)
                    if mapper:
                        if query_cls:
                            # custom query class
                            return query_cls(mapper, session=self.registry())
                        else:
                            # session&#39;s configured query class
                            return self.registry().query(mapper)
                except orm_exc.UnmappedClassError:
                    return None
        return query()

&amp;quot;&amp;quot;&amp;quot;Old name for backwards compatibility.&amp;quot;&amp;quot;&amp;quot;
ScopedSession = scoped_session


def instrument(name):
    def do(self, *args, **kwargs):
        return getattr(self.registry(), name)(*args, **kwargs)
    return do

for meth in Session.public_methods:
    setattr(scoped_session, meth, instrument(meth))


def makeprop(name):
    def set(self, attr):
        setattr(self.registry(), name, attr)

    def get(self):
        return getattr(self.registry(), name)

    return property(get, set)

for prop in (&#39;bind&#39;, &#39;dirty&#39;, &#39;deleted&#39;, &#39;new&#39;, &#39;identity_map&#39;,
             &#39;is_active&#39;, &#39;autoflush&#39;, &#39;no_autoflush&#39;, &#39;info&#39;):
    setattr(scoped_session, prop, makeprop(prop))


def clslevel(name):
    def do(cls, *args, **kwargs):
        return getattr(Session, name)(*args, **kwargs)
    return classmethod(do)

for prop in (&#39;close_all&#39;, &#39;object_session&#39;, &#39;identity_key&#39;):
    setattr(scoped_session, prop, clslevel(prop))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;撇开复杂的部分不说，暂时之看这个类的透明代理性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当程序需要连接数据库的时候，可以使用 &lt;code&gt;scoped_session&lt;/code&gt;，像使用&lt;code&gt;Session&lt;/code&gt;类一样，&lt;code&gt;Session&lt;/code&gt;支持的方法都支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类通过 &lt;code&gt;instrument&lt;/code&gt;, &lt;code&gt;makeprop&lt;/code&gt;, &lt;code&gt;clslevel&lt;/code&gt; 这几个函数把 &lt;code&gt;Session&lt;/code&gt; 类的方法属性“挂接”到自己身上，实现了对 &lt;code&gt;Session&lt;/code&gt; 类的透明代理&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类通过维护 Registry 来实现程序的不同部分可以共用 Session，既节省资源，又方便不同部分共享数据（不知道这样理解对不对？）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_session&lt;/code&gt; 对象的作用域是线程局部的，类内部通过以 &lt;code&gt;threading.local()&lt;/code&gt; 作为 Registry 的键值，来区分不同线程中的对象，不同的线程不共享Session对象，这样就实现了线程安全，写程序的时候只需要使用 &lt;code&gt;scoped_session&lt;/code&gt; 来操作就好了，而不需要再关注线程相关的东西了。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;有时候，代理类用着还是很方便的。我是一个初学者，如果本文中有谬误，请不吝指正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[转载] Python类引入机制</title>
      <link>http://hshsh.me/post/2016-04-08-python-import-schema/</link>
      <pubDate>Fri, 08 Apr 2016 09:27:54 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-08-python-import-schema/</guid>
      <description>

&lt;p&gt;本文转载自&lt;a href=&#34;http://liuchang0812.com&#34;&gt;刘畅的博客&lt;/a&gt;，原文地址：&lt;a href=&#34;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&#34;&gt;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&lt;/a&gt;。本文所涉及到的代码在&lt;a href=&#34;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&#34;&gt;github&lt;/a&gt;上。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Python 是一门优美简单、功能强大的动态语言。在刚刚接触这门语言时，我们会被其优美的格式、简洁的语法和无穷无尽的类库所震撼。在真正的将python应用到实际的项目中，你会遇到一些无法避免的问题。最让人困惑不解的问题有二类，一个 编码问题，另一个则是引用问题。&lt;/p&gt;

&lt;p&gt;本文主要讨论关于Python中import的机制与实现、以及介绍一些有意思的Python Hooks。&lt;/p&gt;

&lt;h2 id=&#34;python-类库引入机制&#34;&gt;Python 类库引入机制&lt;/h2&gt;

&lt;p&gt;首先，看一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
目录结构如下：
├── __init__.py
├── main.py
└── string.py
&amp;quot;&amp;quot;&amp;quot;
# main.py 内容如下
import string
print string.a
# string.py 内容如下
a = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，考虑一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当我们执行main.py的时候，会发生什么事情？&lt;/li&gt;
&lt;li&gt;在main.py文件执行到&lt;code&gt;import string&lt;/code&gt;的时候，解释器导入的string类库是当前文件夹下的string.py还是系统标准库的string.py呢？&lt;/li&gt;
&lt;li&gt;如果明确的指明自己要引用的类库？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了搞清楚上面的问题，我们需要了解关于Python类库引入的机制。&lt;/p&gt;

&lt;h2 id=&#34;python的两种引入机制&#34;&gt;Python的两种引入机制&lt;/h2&gt;

&lt;p&gt;Python 提供了二种引入机制：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;relative import&lt;/li&gt;
&lt;li&gt;absolute import&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;relative-import&#34;&gt;relative import&lt;/h3&gt;

&lt;p&gt;relative import 也叫作相对引入，在Python2.5及之前是默认的引入方法。它的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from .string import a
from ..string import a
from ...string import a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种引入方式使用一个点号来标识引入类库的精确位置。与linux的相对路径表示相似，一个点表示当前目录，每多一个点号则代表向上一层目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
├── __init__.py
├── foo.py
└── main.py
&amp;quot;&amp;quot;&amp;quot;
# foo.py
a = 2
# main.py
print __name__
from .foo import a
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对引入，那么我们需要知道相对什么来引入。相对引入使用被引入文件的&lt;code&gt;__name__&lt;/code&gt;属性来决定该文件在整个包结构的位置。那么如果文件的&lt;code&gt;__name__&lt;/code&gt;没有包含任何包的信息，例如&lt;code&gt;__name__&lt;/code&gt;被设置为了&lt;code&gt;__main__&lt;/code&gt;，则认为其为‘top level script&amp;rsquo;，而不管该文件的位置，这个时候相对引入就没有引入的参考物。如上面的程序所示，当我们执行&lt;code&gt;python main.py&lt;/code&gt;时，Python解释器会抛出 ValueError: Attempted relative import in non-package 的异常。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，&lt;a href=&#34;https://www.python.org/dev/peps/pep-0366/&#34;&gt;PEP 0366 &amp;ndash; Main module explicit relative imports&lt;/a&gt;提出了一个解决方案。允许用户使用&lt;code&gt;python -m ex2.main&lt;/code&gt;的方式,来执行该文件。在这个方案下，引入了一个新的属性&lt;code&gt;__package__&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
╭─liuchang@localhost  ~/Codes/pycon
╰─$ cat ex2/main.py
print __name__
print __package__
from .foo import a
print a
╭─liuchang@localhost  ~/Codes/pycon
╰─$ python -m ex2.main
__main__
ex2
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;absolute-import&#34;&gt;absolute import&lt;/h3&gt;

&lt;p&gt;absolute import 也叫作完全引入，非常类似于Java的引入进制，在Python2.5被完全实现，但是是需要通过&lt;code&gt;from __future__ import absolute_import&lt;/code&gt;来打开该引入进制。在Python2.6之后以及Python3，完全引用成为Python的默认的引入机制。它的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from pkg import foo
from pkg.moduleA import foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，需要从包目录最顶层目录依次写下，而不能从中间开始。&lt;/p&gt;

&lt;p&gt;在使用该引入方式时，我们碰到比较多的问题就是因为位置原因，Python找不到相应的库文件，抛出ImportError的异常。让我们看一个完全引用的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
ex3
├── __init__.py
├── foo.py
└── main.py
&amp;quot;&amp;quot;&amp;quot;
# foo.py
a = 2

# main.py
print __name__
print __package__
from ex2.foo import a
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们尝试着去运行main.py文件，Python解释器会抛出ImportError。那么我们如何解决这个问题呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╰─$ python ex3/main.py
__main__
None
Traceback (most recent call last):
  File &amp;quot;ex3/main.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    from ex2.foo import a
ImportError: No module named ex2.foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，我们也可以使用前文所述的module的方式去运行程序，通过-m参数来告诉解释器&lt;code&gt;__package__&lt;/code&gt;属性。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ python -m ex3.main
__main__
ex3
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们还有一个办法可以解决该问题，在描述之前，我们介绍一个关于Python的非常有用的小知识：&lt;strong&gt;Python解释器会自动将当前工作目录添加到PYTHONPATH&lt;/strong&gt;。如下所示，可以看到我们打印出的&lt;code&gt;sys.path&lt;/code&gt;已经包含了当前工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon/ex4
╰─$ cat main.py
import sys
print sys.path
╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon/ex4
╰─$ python main.py
[&#39;/Users/liuchang/Codes/pycon/ex4&#39;,
&#39;/Library/Python/2.7/site-packages/pip-7.1.0-py2.7.egg&#39;,
&#39;/Library/Python/2.7/site-packages/mesos-_PACKAGE_VERSION_-py2.7.egg&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload&#39;,
&#39;/Users/liuchang/Library/Python/2.7/lib/python/site-packages&#39;,
&#39;/usr/local/lib/python2.7/site-packages&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC&#39;,
&#39;/Library/Python/2.7/site-packages&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;了解了Python解释器的这个特性后，我们就可以解决完全引用的找不到类库的问题：执行的时候，让解释器自动的将类库的目录添加到PYTHONPATH中。&lt;/p&gt;

&lt;p&gt;我们可以在顶层目录中添加一个run_ex3.py的文件，文件内容和运行结果如下，可以看到Python解释器正确的执行了ex3.main文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ cat run_ex3.py
from ex3 import main
╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ python run_ex3.py
ex3.main
None
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一些实践经验&#34;&gt;一些实践经验&lt;/h2&gt;

&lt;h3 id=&#34;相对引用还是绝对引用&#34;&gt;相对引用还是绝对引用？&lt;/h3&gt;

&lt;p&gt;上面介绍了Python的两种引用方式，都可以解决引入歧义的问题。那我们应该使用哪一种呢？&lt;/p&gt;

&lt;p&gt;先说明一下Python的默认引用方式，在Python2.4及之前，Python只有相对引用这一种方式，在Python2.5中实现了绝对引用，但默认没有打开，需要用户自己指定使用该引用方式。在之后的版本和Python3版本，绝对引用已经成为默认的引用方式。&lt;/p&gt;

&lt;p&gt;其次，二种引用方式各有利弊。绝对引用代码更加清晰明了，可以清楚的看到引入的包名和层次，但是，当包名修改的时候，我们需要手动修改所有的引用代码。相对引用则比较精简，不会被包名修改所影响，但是可读性较差，不如完全引用清晰。&lt;/p&gt;

&lt;p&gt;最后，对于两种引用的方式选择，还是有争论的。在PEP8中，Python官方推荐的是绝对引用,详细理由可以参考&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/#imports&#34;&gt;这儿&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Absolute imports are recommended, as they are usually more readable and tend to be better behaved (or at least give better error messages) if the import system is incorrectly configured (such as when a directory inside a package ends up on sys.path ):&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;However, explicit relative imports are an acceptable alternative to absolute imports, especially when dealing with complex package layouts where using absolute imports would be unnecessarily verbose:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import sibling
from .sibling import example
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Standard library code should avoid complex package layouts and always use absolute imports.
Implicit relative imports should never be used and have been removed in Python 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;规范打包发布&#34;&gt;规范打包发布&lt;/h3&gt;

&lt;p&gt;为了别人使用自己代码的方便，应该尽量使用规范的包分发机制。为自己的Python包编写正确的setup.py文件，添加相应的README.md文件。对于提供一些可执行命令的包，则可以使用 console_entrypoint 的机制来提供。因为打包和分发不是本文重点，不再详细叙述，大家可以查看官方文档。&lt;/p&gt;

&lt;h3 id=&#34;使用virtualenv管理包依赖&#34;&gt;使用virtualenv管理包依赖&lt;/h3&gt;

&lt;p&gt;在使用Python的时候，尽量使用virtualenv来管理项目，所有的项目从编写到运行都在特定的virtualenv中。并且为自己的项目生成正确的依赖描述文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于virtualenv的用法，可以参考我之前的一篇文章&lt;a href=&#34;http://lcblog-wordpress.stor.sinaapp.com/uploads/2015/10/virtualenv教程.pdf&#34;&gt;virtualenv教程&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;python-import实现&#34;&gt;Python import实现&lt;/h2&gt;

&lt;p&gt;Python 提供了 import 语句来实现类库的引用，下面我们详细介绍当执行了 import 语句的时候，内部究竟做了些什么事情。&lt;/p&gt;

&lt;p&gt;当我们执行一行 &lt;code&gt;from package import module as mymodule&lt;/code&gt;命令时，Python解释器会查找package这个包的module模块，并将该模块作为mymodule引入到当前的工作空间。所以import语句主要是做了二件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查找相应的module&lt;/li&gt;
&lt;li&gt;加载module到local namespace&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们详细了解python是如何查找模块的。&lt;/p&gt;

&lt;h3 id=&#34;查找module的过程&#34;&gt;查找module的过程&lt;/h3&gt;

&lt;p&gt;在import的第一个阶段，主要是完成了查找要引入模块的功能，这个查找的过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查 sys.modules (保存了之前import的类库的缓存），如果module被找到，则⾛到第二步。&lt;/li&gt;
&lt;li&gt;检查 sys.meta_path。meta_path 是一个 list，⾥面保存着一些 finder 对象，如果找到该module的话，就会返回一个finder对象。&lt;/li&gt;
&lt;li&gt;检查⼀些隐式的finder对象，不同的python实现有不同的隐式finder，但是都会有 sys.path_hooks, sys.path_importer_cache 以及sys.path。&lt;/li&gt;
&lt;li&gt;抛出 ImportError。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;sys-modules&#34;&gt;sys.modules&lt;/h3&gt;

&lt;p&gt;对于第一步中sys.modules，我们可以打开Python来实际的查看一下其内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python 2.7.10 (default, Aug 22 2015, 20:33:39)
[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.1)] on darwin
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.modules
{&#39;copy_reg&#39;: &amp;lt;module &#39;copy_reg&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/copy_reg.pyc&#39;&amp;gt;,
&#39;sre_compile&#39;: &amp;lt;module &#39;sre_compile&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_compile.pyc&#39;&amp;gt;,
&#39;_sre&#39;: &amp;lt;module &#39;_sre&#39; (built-in)&amp;gt;,
&#39;encodings&#39;: &amp;lt;module &#39;encodings&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/__init__.pyc&#39;&amp;gt;,
&#39;site&#39;: &amp;lt;module &#39;site&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site.pyc&#39;&amp;gt;,
&#39;__builtin__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;,
&#39;sysconfig&#39;: &amp;lt;module &#39;sysconfig&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sysconfig.pyc&#39;&amp;gt;,
&#39;encodings.encodings&#39;: None,
&#39;__main__&#39;: &amp;lt;module &#39;__main__&#39; (built-in)&amp;gt;,
&#39;supervisor&#39;: &amp;lt;module &#39;supervisor&#39; (built-in)&amp;gt;,
&#39;abc&#39;: &amp;lt;module &#39;abc&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/abc.pyc&#39;&amp;gt;,
&#39;posixpath&#39;: &amp;lt;module &#39;posixpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/posixpath.pyc&#39;&amp;gt;,
&#39;_weakrefset&#39;: &amp;lt;module &#39;_weakrefset&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_weakrefset.pyc&#39;&amp;gt;,
&#39;errno&#39;: &amp;lt;module &#39;errno&#39; (built-in)&amp;gt;,
&#39;encodings.codecs&#39;: None,
&#39;sre_constants&#39;: &amp;lt;module &#39;sre_constants&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_constants.pyc&#39;&amp;gt;,
&#39;re&#39;: &amp;lt;module &#39;re&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/re.pyc&#39;&amp;gt;,
&#39;_abcoll&#39;: &amp;lt;module &#39;_abcoll&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_abcoll.pyc&#39;&amp;gt;,
&#39;types&#39;: &amp;lt;module &#39;types&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/types.pyc&#39;&amp;gt;,
&#39;_codecs&#39;: &amp;lt;module &#39;_codecs&#39; (built-in)&amp;gt;,
&#39;encodings.__builtin__&#39;: None,
&#39;_warnings&#39;: &amp;lt;module &#39;_warnings&#39; (built-in)&amp;gt;,
&#39;genericpath&#39;: &amp;lt;module &#39;genericpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/genericpath.pyc&#39;&amp;gt;,
&#39;stat&#39;: &amp;lt;module &#39;stat&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/stat.pyc&#39;&amp;gt;,
&#39;zipimport&#39;: &amp;lt;module &#39;zipimport&#39; (built-in)&amp;gt;,
&#39;_sysconfigdata&#39;: &amp;lt;module &#39;_sysconfigdata&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_sysconfigdata.pyc&#39;&amp;gt;,
&#39;mpl_toolkits&#39;: &amp;lt;module &#39;mpl_toolkits&#39; (built-in)&amp;gt;,
&#39;warnings&#39;: &amp;lt;module &#39;warnings&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/warnings.pyc&#39;&amp;gt;,
&#39;UserDict&#39;: &amp;lt;module &#39;UserDict&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/UserDict.pyc&#39;&amp;gt;,
&#39;encodings.utf_8&#39;: &amp;lt;module &#39;encodings.utf_8&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/utf_8.pyc&#39;&amp;gt;,
&#39;sys&#39;: &amp;lt;module &#39;sys&#39; (built-in)&amp;gt;,
&#39;_osx_support&#39;: &amp;lt;module &#39;_osx_support&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_osx_support.pyc&#39;&amp;gt;,
&#39;codecs&#39;: &amp;lt;module &#39;codecs&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.pyc&#39;&amp;gt;,
&#39;readline&#39;: &amp;lt;module &#39;readline&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/readline.so&#39;&amp;gt;,
&#39;os.path&#39;: &amp;lt;module &#39;posixpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/posixpath.pyc&#39;&amp;gt;,
&#39;_locale&#39;: &amp;lt;module &#39;_locale&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/_locale.so&#39;&amp;gt;,
&#39;signal&#39;: &amp;lt;module &#39;signal&#39; (built-in)&amp;gt;,
&#39;traceback&#39;: &amp;lt;module &#39;traceback&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/traceback.pyc&#39;&amp;gt;,
&#39;linecache&#39;: &amp;lt;module &#39;linecache&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/linecache.pyc&#39;&amp;gt;,
&#39;posix&#39;: &amp;lt;module &#39;posix&#39; (built-in)&amp;gt;,
&#39;encodings.aliases&#39;: &amp;lt;module &#39;encodings.aliases&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/aliases.pyc&#39;&amp;gt;,
&#39;exceptions&#39;: &amp;lt;module &#39;exceptions&#39; (built-in)&amp;gt;,
&#39;sre_parse&#39;: &amp;lt;module &#39;sre_parse&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_parse.pyc&#39;&amp;gt;,
&#39;os&#39;: &amp;lt;module &#39;os&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.pyc&#39;&amp;gt;,
&#39;_weakref&#39;: &amp;lt;module &#39;_weakref&#39; (built-in)&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; sys.modules[&#39;zlib&#39;].__file__
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/zlib.so&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到sys.modules已经保存了一些包的信息，由这些信息，我们就可以直接知道要查找的包的位置等信息。&lt;/p&gt;

&lt;h3 id=&#34;finder-loader和importer&#34;&gt;finder、loader和importer&lt;/h3&gt;

&lt;p&gt;在上文中，我们提到了sys.meta_path中保证了一些finder对象。在python中，不仅定义了finder的概念，还定义了loader和importor的概念。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finder的任务是决定自己是否根据名字找到相应的模块，在py2中，finder对象必须实现find_module()方法，在py3中必须要实现find_module()或者find_loader（)方法。如果finder可以查找到模块，则会返回一个loader对象(在py3.4中，修改为返回一个module specs)。&lt;/li&gt;
&lt;li&gt;loader则是负责加载模块，它必须实现一个load_module()的方法。&lt;/li&gt;
&lt;li&gt;importer 则指一个对象，实现了finder和loader的方法。因为Python是duck type，只要实现了方法，就可以认为是该类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sys-meta-path&#34;&gt;sys.meta_path&lt;/h3&gt;

&lt;p&gt;在Python查找的时候，如果在sys.modules没有查找到，就会依次调用sys.meta_path中的finder对象。默认的情况下，sys.meta_path是一个空列表，并没有任何finder对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In [6]: sys.meta_path
Out[6]: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以向sys.meta_path中添加一些定义的finder，来实现对Python加载模块的修改。比如下例，我们实现了一个会将每次加载包的信息打印出来的finder。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import sys

class Watcher(object):
    @classmethod
    def find_module(cls, name, path, target=None):
        print(&amp;quot;Importing&amp;quot;, name, path, target)
        return None

sys.meta_path.insert(0, Watcher)

import socket
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们执行的时候，就可以看到系统加载socket包时所发生的事情。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; ╭─liuchang@localhost  ~/Codes/pycon/ex5_meta_path
 ╰─$ python finder1.py
 Importing socket None None
 Importing _socket None None
 Importing functools None None
 Importing _functools None None
 Importing _ssl None None
 Importing cStringIO None None
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sys-path-hook&#34;&gt;sys.path hook&lt;/h3&gt;

&lt;p&gt;Python import的hook分为二类，一类是上一章节已经描述的meta hook，另一类是 path hook。&lt;/p&gt;

&lt;p&gt;当处理sys.path（或者package.&lt;strong&gt;path&lt;/strong&gt;)时，就会调用对应的一部分的 Pack hook。Path Hook是通过向sys.path_hooks 中添加一个importer生成器来注册的。&lt;/p&gt;

&lt;p&gt;sys.path_hooks 是由可被调用的对象组成，它会顺序的检查以决定他们是否可以处理给定的sys.path的一项。每个对象会使用sys.path项的路径来作为参数被调用。如果它不能处理该路径，就必须抛出ImportError，如果可以，则会返回一个importer对象。之后，不会再尝试其它的sys.path_hooks对象，即使前一个importer出错了。&lt;/p&gt;

&lt;p&gt;详细可以参考&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302/#specification-part-2-registering-hooks&#34;&gt;registering-hooks&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;python-import-hooks&#34;&gt;python import hooks&lt;/h2&gt;

&lt;p&gt;在介绍完Python的引用机制与一些实现方法后，接下来我们介绍一些关于如何根据自己的需求来扩展Python的引用机制。&lt;/p&gt;

&lt;p&gt;在开始详细介绍前，给大家展示一个实用性不高，但是很有意思的例子：&lt;strong&gt;让Python在执行代码的时候自动安装缺失的类库&lt;/strong&gt;。我们会实现一个autoinstall的模块，只要import了该模块，就可以打开该功能。如下所示，我们尝试引入tornado库的时候，iPython会提示我们没有安装。然后，我们引入了autoinstall，再尝试引入tornado，iPython就会自动的安装tornado库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In [1]: import tornado
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
&amp;lt;ipython-input-1-3eac10687b7e&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 import tornado

ImportError: No module named tornado

In [2]: import autoinstall

In [3]: import tornado
Installing tornado

Collecting tornado
  Downloading tornado-4.2.1.tar.gz (434kB)
Collecting backports.ssl-match-hostname (from tornado)
  Downloading http://182.92.2.186:7002/packages/backports.ssl_match_hostname-3.4.0.2-py2-none-any.whl
Collecting certifi (from tornado)
  Downloading certifi-2015.9.6.2-py2.py3-none-any.whl (371kB)
Installing collected packages: backports.ssl-match-hostname, certifi, tornado
  Running setup.py install for tornado
Successfully installed backports.ssl-match-hostname-3.4.0.2 certifi-2015.9.6.2 tornado-4.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个功能的实现其实很简单，利用了sys.meta_path。autoinstall的全部代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import sys
import subprocess


class AutoInstall(object):
    _loaded = set()

    @classmethod
    def find_module(cls, name, path, target=None):
        if path is None and name not in cls._loaded:
            cls._loaded.add(name)
            print(&amp;quot;Installing&amp;quot;, name)
            try:
                out = subprocess.check_output(
                    [&#39;sudo&#39;, sys.executable, &#39;-m&#39;, &#39;pip&#39;, &#39;install&#39;, name])
                print(out)
            except Exception as e:
                print(&amp;quot;Failed&amp;quot; + e.message)
        return None

sys.meta_path.append(AutoInstall)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;import-hook的重要性&#34;&gt;import hook的重要性&lt;/h3&gt;

&lt;p&gt;我们为什么需要Python import的hook呢？使用import的hook可以让我们做到很多事情，比如说当我们的Python包存储在一个非标准的文件中，或者Python程序存储在网络数据库中，或者像py2exe一样将Python程序打包成了一个文件，我们需要一种方法来正确的解析它们。&lt;/p&gt;

&lt;p&gt;其次，我们希望在Python加载类库的时候，可以额外的做一些事情，比如上传审计信息，比如延迟加载，比如自动解决上例的依赖未安装的问题。&lt;/p&gt;

&lt;p&gt;所以，import系统的Hook技术是值的花时间学习的。&lt;/p&gt;

&lt;h3 id=&#34;如何实现import-hooks&#34;&gt;如何实现import hooks&lt;/h3&gt;

&lt;p&gt;Python提供了一些方法，让我们可以在代码中动态的调用import。主要有如下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;__import__ : Python的内置函数&lt;/li&gt;
&lt;li&gt;imputil        : Python的import工具库，在py2.6被声明废弃，py3中彻底移除。&lt;/li&gt;
&lt;li&gt;imp            : Python2 的一个import库，py3中移除&lt;/li&gt;
&lt;li&gt;importlib      : Python3 中最新添加，backport到py2.7，但只有很小的子集（只有一个函数）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python2 所有关于import的库的列表参见&lt;a href=&#34;https://docs.python.org/2/library/modules.html&#34;&gt;Importing Modules&lt;/a&gt;。Python3 的可以参考&lt;a href=&#34;https://docs.python.org/3/library/modules.html&#34;&gt;Importing Modules&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302&#34;&gt;PEP 0302 &amp;ndash; New Import Hooks&lt;/a&gt; 提案详细的描述了importlib的目的、用法。&lt;/p&gt;

&lt;h3 id=&#34;一些hook示例&#34;&gt;一些Hook示例&lt;/h3&gt;

&lt;h3 id=&#34;lazy化库引入&#34;&gt;Lazy化库引入&lt;/h3&gt;

&lt;p&gt;使用Import Hook，我们可以达到Lazy Import的效果，当我们执行import的时候，实际上并没引入该库，只有真正的使用这个库的时候，才会将其引入到当前工作空间。
具体的代码可以参考&lt;a href=&#34;https://github.com/noahmorrison/limp&#34;&gt;github&lt;/a&gt;。
实现的效果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python

import limp  # Lazy imports begin now

import json
import sys

print(&#39;json&#39; in sys.modules)  # False
print(&#39;, &#39;.join(json.loads(&#39;[&amp;quot;Hello&amp;quot;, &amp;quot;World!&amp;quot;]&#39;)))
print(&#39;json&#39; in sys.modules)  # True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的实现也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import imp

_lazy_modules = {}

class LazyModule():
    def __init__(self, name):
        self.name = name

    def __getattr__(self, attr):
        path = _lazy_modules[self.name]
        f, pathname, desc = imp.find_module(self.name, path)

        lf = sys.meta_path.pop()
        imp.load_module(self.name, f, pathname, desc)
        sys.meta_path.append(lf)


        self.__dict__ = sys.modules[self.name].__dict__
        return self.__dict__[attr]

class LazyFinder(object):

    def find_module(self, name, path):
        _lazy_modules[name] = path
        return self

    def load_module(self, name):
        return LazyModule(name)

sys.meta_path.append(LazyFinder())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flask-插件库统一入口&#34;&gt;Flask 插件库统一入口&lt;/h3&gt;

&lt;p&gt;使用过Flask的同学都知道，Flask的对于插件提供了统一的入口。比如说我们安装了Flask_API这个库，然后我们可以直接&lt;code&gt;import flask_api&lt;/code&gt;来使用这个库，同时Flask还允许我们采用&lt;code&gt;import flask.ext.api&lt;/code&gt;的方式来引用该库。&lt;/p&gt;

&lt;p&gt;这里Flask就是使用了import 的hook，当引入flask.ext的包时，就自动的引用相应的库。Flask实现了一个叫ExtensionImporter的类，这个类实现了find_module和load_module代码实现如下&lt;a href=&#34;https://github.com/mitsuhiko/flask/blob/master/flask/exthook.py#L27&#34;&gt;github&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ExtensionImporter(object):
    &amp;quot;&amp;quot;&amp;quot;This importer redirects imports from this submodule to other locations.
    This makes it possible to transition from the old flaskext.name to the
    newer flask_name without people having a hard time.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, module_choices, wrapper_module):
        self.module_choices = module_choices
        self.wrapper_module = wrapper_module
        self.prefix = wrapper_module + &#39;.&#39;
        self.prefix_cutoff = wrapper_module.count(&#39;.&#39;) + 1

    def __eq__(self, other):
        return self.__class__.__module__ == other.__class__.__module__ and \
               self.__class__.__name__ == other.__class__.__name__ and \
               self.wrapper_module == other.wrapper_module and \
               self.module_choices == other.module_choices

    def __ne__(self, other):
        return not self.__eq__(other)

    def install(self):
        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]

    def find_module(self, fullname, path=None):
        if fullname.startswith(self.prefix):
            return self

    def load_module(self, fullname):
        if fullname in sys.modules:
            return sys.modules[fullname]
        modname = fullname.split(&#39;.&#39;, self.prefix_cutoff)[self.prefix_cutoff]
        for path in self.module_choices:
            realname = path % modname
            try:
                __import__(realname)
            except ImportError:
                exc_type, exc_value, tb = sys.exc_info()
                # since we only establish the entry in sys.modules at the
                # very this seems to be redundant, but if recursive imports
                # happen we will call into the move import a second time.
                # On the second invocation we still don&#39;t have an entry for
                # fullname in sys.modules, but we will end up with the same
                # fake module name and that import will succeed since this
                # one already has a temporary entry in the modules dict.
                # Since this one &amp;quot;succeeded&amp;quot; temporarily that second
                # invocation now will have created a fullname entry in
                # sys.modules which we have to kill.
                sys.modules.pop(fullname, None)

                # If it&#39;s an important traceback we reraise it, otherwise
                # we swallow it and try the next choice.  The skipped frame
                # is the one from __import__ above which we don&#39;t care about
                if self.is_important_traceback(realname, tb):
                    reraise(exc_type, exc_value, tb.tb_next)
                continue
            module = sys.modules[fullname] = sys.modules[realname]
            if &#39;.&#39; not in modname:
                setattr(sys.modules[self.wrapper_module], modname, module)
            return module
        raise ImportError(&#39;No module named %s&#39; % fullname)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在Flask的ext目录下的__init__.py文件中，初始化了该Importer。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def setup():
    from ..exthook import ExtensionImporter
    importer = ExtensionImporter([&#39;flask_%s&#39;, &#39;flaskext.%s&#39;], __name__)
    importer.install()
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;希望坚持阅读到本处的你，能明白Python import的用法、实现和改造方法。准备仓促，难免会有错误，欢迎大家指正和PR。&lt;/p&gt;

&lt;p&gt;本文使用CC-BY-SA协议。&lt;/p&gt;

&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302/&#34;&gt;https://www.python.org/dev/peps/pep-0302/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0338/&#34;&gt;https://www.python.org/dev/peps/pep-0338/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0328/&#34;&gt;https://www.python.org/dev/peps/pep-0328/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0366/&#34;&gt;https://www.python.org/dev/peps/pep-0366/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/noahmorrison/limp&#34;&gt;https://github.com/noahmorrison/limp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mitsuhiko/flask&#34;&gt;https://github.com/mitsuhiko/flask&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>