<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hshsh&#39;s little site</title>
    <link>http://hshsh.me/</link>
    <description>Recent content on hshsh&#39;s little site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 24 Apr 2016 11:36:14 +0800</lastBuildDate>
    <atom:link href="http://hshsh.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>welcome to my hugo blog</title>
      <link>http://hshsh.me/post/2016-04-24-welcome-to-my-hugo-blog/</link>
      <pubDate>Sun, 24 Apr 2016 11:36:14 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-24-welcome-to-my-hugo-blog/</guid>
      <description>&lt;p&gt;Welcome to my new &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; blog.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pandas学习笔记（二）：基本数据结构</title>
      <link>http://hshsh.me/post/2016-04-13-python-pandas-notes-02/</link>
      <pubDate>Wed, 13 Apr 2016 18:02:04 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-13-python-pandas-notes-02/</guid>
      <description>

&lt;p&gt;Pandas的开发者是：&lt;a href=&#34;http://wesmckinney.com&#34;&gt;Wes McKinney&lt;/a&gt;，这位大牛工作的时候没有顺手的工具，就决定自己顺手写一个出来。&lt;/p&gt;

&lt;p&gt;Pandas具有但不限于一下特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;具备按轴自动或显式数据对齐功能的数据结构，这可以防止许多由于数据没有对齐以及来自不同数据源（索引方式不同）的数据而导致的常见错误；&lt;/li&gt;
&lt;li&gt;集成时间序列功能；&lt;/li&gt;
&lt;li&gt;既能处理时间序列数据也能处理非时间序列数据的数据结构；&lt;/li&gt;
&lt;li&gt;数学运算和约简（比如对某个轴求和）可以根据不同的元数据（轴编号）执行；&lt;/li&gt;
&lt;li&gt;可以灵活处理缺失数据；&lt;/li&gt;
&lt;li&gt;合并及其他出现在常见数据库（例如基于SQL的）中的关系型运算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pandas的导入约定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pandas import Series, DataFrame
import pandas as pd
import numpy as np
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;series&#34;&gt;Series&lt;/h2&gt;

&lt;p&gt;Series可以使用列表初始化，初始化时还可以指定索引名称。&lt;/p&gt;

&lt;p&gt;Series可以被看成时一个定长的有序字典，因为它时索引值到数据值的一个映射，它可以用在许多原本需要字典参数的函数中。&lt;/p&gt;

&lt;p&gt;如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series。通过指定 &lt;code&gt;index&lt;/code&gt; 可以只选择需要的对象，缺失值使用NaN自动填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj = Series([4, 7, -5, 3])
obj, obj.values, obj.index

obj = Series([4, 7, -5, 3], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])

obj[obj &amp;gt; 0]
obj * 2
np.exp(obj)

&#39;b&#39; in obj

sdata = {&#39;Ohio&#39;: 35000, &#39;Texas&#39;: 71000, &#39;Oregon&#39;: 16000, &#39;Utah&#39;: 5000}
sdata = Series(sdata)
sdata
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;states = [&#39;California&#39;, &#39;Ohio&#39;, &#39;Oregon&#39;, &#39;Texas&#39;]
obj = Series(sdata, index=states)
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对很多应用而言，Series最重要的一个功能是：在算数运算中会自动对齐不同索引的数据。&lt;/p&gt;

&lt;p&gt;Series对象本身及其索引都有一个 &lt;code&gt;name&lt;/code&gt; 属性，该属性跟Pandas其他的关键功能关系非常密切。&lt;/p&gt;

&lt;p&gt;Series的索引可以通过赋值的方式就地修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sdata + obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj.name = &#39;population&#39;
obj.index.name = &#39;state&#39;
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj.index = [&#39;Tibet&#39;, &#39;Beijing&#39;, &#39;Tianjin&#39;, &#39;Henan&#39;]
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Tibet          NaN
Beijing    35000.0
Tianjin    16000.0
Henan      71000.0
Name: population, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dataframe&#34;&gt;DataFrame&lt;/h2&gt;

&lt;p&gt;DataFrame是一个表格型的数据结构，含有一组有序的列，每列可以时不同的值类型（数值、字符串、布尔值等）。&lt;/p&gt;

&lt;p&gt;DataFrame既有行索引也有列索引，它可以被看成由Series组成的字典（共用同一个索引）。&lt;/p&gt;

&lt;p&gt;跟其他类似的数据结构相比（如R的 &lt;code&gt;data.frame&lt;/code&gt;），DataFrame中面向行和面向列的操作基本上时平衡的。&lt;/p&gt;

&lt;p&gt;构建DataFrame的办法有很多种，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典，DataFrame会自动加上索引，且所有列会被有序排列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = {&#39;state&#39;: [&#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Nevada&#39;, &#39;Nevada&#39;],
            &#39;year&#39;: [2000, 2001, 2002, 2001, 2002],
            &#39;pop&#39;: [1.5, 1.7, 3.6, 2.4, 2.9]}
frame = DataFrame(data)
frame
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列，如果传入的列在数据中找不到，则会产生NaN值。&lt;/p&gt;

&lt;p&gt;除了指定列序列，还可以指定行索引序列，而不是使用默认的数字索引。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2 = DataFrame(data, columns=[&#39;year&#39;, &#39;state&#39;, &#39;pop&#39;, &#39;debt&#39;],
                   index=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;])
frame2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;debt&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;one&lt;/th&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;two&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;three&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;four&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;five&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。&lt;/p&gt;

&lt;p&gt;返回的Series拥有原DataFrame相同的索引，而且其 &lt;code&gt;name&lt;/code&gt; 属性也已经被相应的设置好狼（抽取的列名）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2[&#39;state&#39;]  # or frame2.state
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
Name: state, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行也可以通过位置或名称的方式进行获取，比如用索引字段 &lt;code&gt;ix&lt;/code&gt; 获取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2.ix[&#39;three&#39;]  # or frame2.ix[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列可以通过赋值的方式进行修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用标量赋值会赋值给整列；&lt;/li&gt;
&lt;li&gt;使用列表或数组给某个列赋值时，其长度必须跟DataFrame的长度相匹配（如果不匹配，会抛出ValueError异常）；&lt;/li&gt;
&lt;li&gt;如果赋值的是一个Series，会精确匹配DataFrame的索引，所有空位都将被填上缺失值 &lt;code&gt;NaN&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;为不存在的列赋值会创建出一个新列；&lt;/li&gt;
&lt;li&gt;关键字 &lt;code&gt;del&lt;/code&gt; 用于删除列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，任何对返回的Series的就地修改全部会反应到源DataFrame上。通过Series的 &lt;code&gt;copy&lt;/code&gt; 方法可以显式的复制列。&lt;/p&gt;

&lt;p&gt;除了接受由数组组成的字典外，DataFrame还可以接受其他很多中数据输入：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;嵌套字典，如：{&amp;lsquo;Nevada&amp;rsquo;: {2001: 2.4, 2002: 2.9}, &amp;lsquo;Ohio&amp;rsquo;: {2000: 1.5, 2001: 1.7, 2002: 3.6}}&lt;/li&gt;
&lt;li&gt;二维ndarray：数据矩阵，还可以传入行标和列标&lt;/li&gt;
&lt;li&gt;由数组、列表或元组组成的字典：每个序列会变成DataFrame的一列，所有序列的长度必须相同&lt;/li&gt;
&lt;li&gt;NumPy的结构化／记录数组：类似于“由数组组成的字典”&lt;/li&gt;
&lt;li&gt;由Series组成的字典：每个Series会成为一列，如果没有显式指定索引，则各Series的索引会被合并成结果的行索引&lt;/li&gt;
&lt;li&gt;字典或Series的列表：各项将会成为DataFrame的一行，字典键或Series索引的并集将会成为DataFrame的列标&lt;/li&gt;
&lt;li&gt;由列表或元组组成的列表：类似于“二维ndarray“&lt;/li&gt;
&lt;li&gt;另一个DataFrame：该DataFrame的索引将会被沿用，除非显式的指定列其他索引&lt;/li&gt;
&lt;li&gt;NumPy的MaskedArray：类似于“二维ndarray”的情况，只是掩码值在结果DataFrame中会变成NA/缺失值&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;索引对象&#34;&gt;索引对象&lt;/h2&gt;

&lt;p&gt;Index对象是Pandas数据模型的重要组成部分。&lt;/p&gt;

&lt;p&gt;Pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index对象。&lt;/p&gt;

&lt;p&gt;Index对象是不可修改的（immutable），因此用户不能对其进行修改。Index对象的不可修改性非常重要，因为这样才能使Index对象在多个数据结构之间安全共享。&lt;/p&gt;

&lt;p&gt;Pandas库中内置了一些常用的Index类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Index：最泛化的Index对象，将轴标签表示为一个由Python对象组成的NumPy数组，&lt;/li&gt;
&lt;li&gt;Int64Index：针对整数的特殊Index，&lt;/li&gt;
&lt;li&gt;MultiIndex：“层次化”索引对象，表示单个轴上的多层索引，可以看作由元组组成的数组，&lt;/li&gt;
&lt;li&gt;DatetimeIndex：存储纳秒级的时间戳（用NumPy的 &lt;code&gt;datetime64&lt;/code&gt; 类型表示），&lt;/li&gt;
&lt;li&gt;PeriodIndex：针对Period数据（时间间隔）的特殊Index&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这些常用的Index类型，Index甚至还可以被继承从而实现特别的轴索引功能。&lt;/p&gt;

&lt;p&gt;Index对象长得很像数组，功能也很类似一个固定大小的集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2.index.name = &#39;number&#39;
frame2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;debt&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;number&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;one&lt;/th&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;two&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;three&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;four&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;five&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;state&#39; in frame2.columns or &#39;one&#39; in frame2.index
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。下面是一些比较常用的函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;append：连接另一个Index对象，产生一个新的 Index&lt;/li&gt;
&lt;li&gt;diff：计算差集，并得到一个新的 Index&lt;/li&gt;
&lt;li&gt;intersection：计算交集&lt;/li&gt;
&lt;li&gt;union：计算并集&lt;/li&gt;
&lt;li&gt;isin：计算一个指示各值是否都包含在参数集合中的布尔型数组&lt;/li&gt;
&lt;li&gt;delete：删除指定索引处的元素，并得到新的 Index&lt;/li&gt;
&lt;li&gt;drop：删除传入的值，并得到新的 Index&lt;/li&gt;
&lt;li&gt;insert：将元素插入到索引处，并得到新的 Index&lt;/li&gt;
&lt;li&gt;is_monotonic：当各元素均大于等于前一个元素时，返回 True&lt;/li&gt;
&lt;li&gt;is_unique：当Index没有重复值时，返回 True&lt;/li&gt;
&lt;li&gt;unique：计算Index中唯一值的数组&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pandas学习笔记（一）：CSV数据加载保存</title>
      <link>http://hshsh.me/post/2016-04-12-python-pandas-notes-01/</link>
      <pubDate>Tue, 12 Apr 2016 18:52:25 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-12-python-pandas-notes-01/</guid>
      <description>

&lt;h2 id=&#34;加载csv数据&#34;&gt;加载CSV数据&lt;/h2&gt;

&lt;p&gt;很多数据都存储在CSV文件中，Pandas 为读取提供了一个强大的 &lt;code&gt;read_csv&lt;/code&gt; 函数，这个函数接受很多可选参数，通过参数控制数据加载的方式，以及一些基本的清理工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.read_csv(filepath_or_buffer, sep=&#39;,&#39;, delimiter=None, header=&#39;infer&#39;,
    names=None, index_col=None, usecols=None, squeeze=False, prefix=None,
    mangle_dupe_cols=True, dtype=None, engine=None, converters=None,
    true_values=None, false_values=None, skipinitialspace=False,
    skiprows=None, skipfooter=None, nrows=None, na_values=None,
    keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True,
    parse_dates=False, infer_datetime_format=False, keep_date_col=False,
    date_parser=None, dayfirst=False, iterator=False, chunksize=None,
    compression=&#39;infer&#39;, thousands=None, decimal=&#39;.&#39;, lineterminator=None,
    quotechar=&#39;&amp;quot;&#39;, quoting=0, escapechar=None, comment=None, encoding=None,
    dialect=None, tupleize_cols=False, error_bad_lines=True,
    warn_bad_lines=True, skip_footer=0, doublequote=True,
    delim_whitespace=False, as_recarray=False, compact_ints=False,
    use_unsigned=False, low_memory=True, buffer_lines=None, memory_map=False,
    float_precision=None)

Returns
    result : DataFrame or TextParser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多参数都是非常有用的，简要记录一下（详细文档请参考 &lt;code&gt;help(pd.read_csv)&lt;/code&gt; 及官方文档）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;filepath_or_buffer&lt;/code&gt;：参数名字本身反映了功能

&lt;ul&gt;
&lt;li&gt;这里可以接受一个文件名，或者一个URL，&lt;/li&gt;
&lt;li&gt;也可以接受一个打开的文件句柄，&lt;/li&gt;
&lt;li&gt;或者其他任何提供了&lt;code&gt;read&lt;/code&gt;方法的对象，&lt;/li&gt;
&lt;li&gt;举个栗子：某个URL输出CSV，但是需要验证密码，那么就没法让 &lt;code&gt;read_csv&lt;/code&gt; 直接读取URL，但是可以使用 &lt;code&gt;urlopen&lt;/code&gt; 发送附带了验证信息的Request，并把返回的 Response 对象传给 &lt;code&gt;read_csv&lt;/code&gt; 函数，进而通过 Response 对象的 &lt;code&gt;read&lt;/code&gt; 方法加载数据；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sep&lt;/code&gt; 和 &lt;code&gt;delimiter&lt;/code&gt;：这两个参数是一个意思，&lt;code&gt;delimiter&lt;/code&gt;是&lt;code&gt;sep&lt;/code&gt;的别名；如果指定为 &lt;code&gt;\t&lt;/code&gt;（制表符）的话，就可以实现 &lt;code&gt;read_table&lt;/code&gt; 的默认功能；支持使用正则表达式来匹配某些不标准的CSV文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;names&lt;/code&gt;：配合使用指定加载后的列名；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse_dates&lt;/code&gt;：boolean or list of ints or names or list of lists or dict, default False. 这个参数指定对CSV文件中日期序列的处理方式：

&lt;ul&gt;
&lt;li&gt;默认为False，原样加载，不解析日期时间，&lt;/li&gt;
&lt;li&gt;可以为True，尝试解析日期索引，&lt;/li&gt;
&lt;li&gt;可以为数字或 &lt;code&gt;names&lt;/code&gt; 的列表，解析指定的列为时间序列，&lt;/li&gt;
&lt;li&gt;可以为以列表为元素的列表，解析每个子列表中的字段组合为时间序列，&lt;/li&gt;
&lt;li&gt;可以为值为列表的字典，解析每个列表中的字段组合为时间序列，并命名为字典中对应的键值；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date_parser&lt;/code&gt;：可以指定一个自定义函数解析日期；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keep_date_col&lt;/code&gt;：解析出日期序列后，是否保留原来的列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dayfirst&lt;/code&gt;：boolean, default False, DD/MM format dates, international and European format；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterator&lt;/code&gt;：boolean, default False，Return TextFileReader object for iteration or getting chunks with &lt;code&gt;get_chunk()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding&lt;/code&gt;：指定读取或写入CSV文件时使用的字符集，支持 &lt;a href=&#34;https://docs.python.org/3/library/codecs.html#standard-encodings&#34;&gt;codecs 包中的标准字符集&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index_col&lt;/code&gt;：数字、列名或列表，数字或列名指定某一列作为索引，列表制定某几列作为 DataFrame 的层次索引；&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;skip_initialspace&lt;/code&gt;, &lt;code&gt;skiprows&lt;/code&gt;, &lt;code&gt;skipfooter&lt;/code&gt;, &lt;code&gt;comment&lt;/code&gt;, &lt;code&gt;float_precision&lt;/code&gt;等参数做一些基本的清理动作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面举个例子来简单演示一下 &lt;code&gt;parse_dates&lt;/code&gt; 和 &lt;code&gt;data_parser&lt;/code&gt; 的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
from tempfile import TemporaryFile

mycsv = [&amp;quot;date,hour,A1,A2,A3,A4,A5,A6,date2,hour2&amp;quot;,
    &amp;quot;20150102,1,117,85,109,132,166,113,20160102,2&amp;quot;,
    &amp;quot;20150102,2,88,34,82,100,126,85,20160102,3&amp;quot;,
    &amp;quot;20150102,3,48,54,38,50,55,46,20160102,4&amp;quot;,
    &amp;quot;20150102,4,141,120,154,148,175,114,20160102,5&amp;quot;,
    &amp;quot;20150102,5,91,64,74,71,84,70,20160102,6&amp;quot;,
    &amp;quot;20150102,6,45,10,46,20,68,44,20160102,7&amp;quot;]

tmp_csv_file = TemporaryFile()
tmp_csv_file.write(&#39;\n&#39;.join(mycsv))
tmp_csv_file.flush()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;从上面的示例中，可以看到使用默认参数时，&lt;code&gt;read_csv&lt;/code&gt; 函数不会尝试解析日期，这样可以提高文件的加载速度。&lt;/p&gt;

&lt;p&gt;但是第一列日期和第二列小时构成了我们需要的时间戳，加载了CSV后我们需要进行处理，那能不能在加载CSV的时候就直接解析出来呢？我们可以试一试 &lt;code&gt;parse_dates&lt;/code&gt; 参数，把第一列和第二列的索引组成一个列表传给 &lt;code&gt;parse_dates&lt;/code&gt; 参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, parse_dates=[0, 1])
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;我们看到第一列被成功的解析成了日期数据，但是并没有按照我们想象的那样把第一列和第二列一起解析成一个日期时间对象。&lt;/p&gt;

&lt;p&gt;这是因为我们&lt;strong&gt;传递参数的姿势不对&lt;/strong&gt;，正确的应该是这样：&lt;code&gt;parse_dates=[[0, 1]]&lt;/code&gt;，再试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, parse_dates=[[0, 1]])
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date_hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;20150102 1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;20150102 2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;20150102 3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;20150102 4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;20150102 5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;20150102 6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Opps！虽然第一列和第二列合并到一起了，但是并没有成功的解析成日期时间对象。因为这个格式真的没人看得懂是一个日期时间对象啊！！！&lt;/p&gt;

&lt;p&gt;那就没有办法在加载CSV的时候就解析时间序列的方法了吗？&lt;/p&gt;

&lt;p&gt;答案是有的。&lt;code&gt;read_csv&lt;/code&gt; 还有一个参数：&lt;code&gt;date_parser&lt;/code&gt;，我们可以自己写一个日期时间对象解析函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime

def my_date_parser(dt, hour):
    return datetime(int(dt[0:4]), int(dt[4:6]), int(dt[6:8]), int(hour))

tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, date_parser=my_date_parser,
                 parse_dates={&#39;time&#39;: [0, 1], &#39;time2&#39;: [&#39;date2&#39;, &#39;hour2&#39;]},
                 index_col=&#39;time&#39;)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;time2&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;time&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 01:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 02:00:00&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 02:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 03:00:00&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 03:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 04:00:00&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 04:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 05:00:00&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 05:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 06:00:00&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 06:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 07:00:00&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Bingo！是不是搞定了。这样加载并解析时间序列的效率也比加载后使用循环或列表解析处理的效率高的多了。&lt;/p&gt;

&lt;p&gt;上面这段示例代码中，还演示了解析多列时间序列，可以按照列的索引指定要解析的列，也可以按照列名来制定要解析的列，另外，还演示了使用 &lt;code&gt;index_col&lt;/code&gt; 参数指定 DataFrame 索引的用法。&lt;/p&gt;

&lt;h2 id=&#34;保存csv数据&#34;&gt;保存CSV数据&lt;/h2&gt;

&lt;p&gt;除了加载CSV数据很方便之外，Pandas 的 DataFrame 类一个很方便的 &lt;code&gt;to_csv&lt;/code&gt; 方法，可以把数据保存到CSV文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.DataFrame.to_csv(self, path_or_buf=None, sep=&#39;,&#39;, na_rep=&#39;&#39;,
    float_format=None, columns=None, header=True, index=True, index_label=None,
    mode=&#39;w&#39;, encoding=None, compression=None, quoting=None, quotechar=&#39;&amp;quot;&#39;, 
    line_terminator=&#39;\n&#39;, chunksize=None, tupleize_cols=False, date_format=None,
    doublequote=True, escapechar=None, decimal=&#39;.&#39;, **kwds)
    
unbound pandas.core.frame.DataFrame method:
    Write DataFrame to a comma-separated values (csv) file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，默认输出就是标准的逗号分割的CSV文件，跟 &lt;code&gt;read_csv&lt;/code&gt; 函数一样，这个函数同样有很多可选参数控制输出。&lt;/p&gt;

&lt;p&gt;除了输出到CSV外，DataFrame 还有很多输出到其他格式的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[meth for meth in dir(pd.DataFrame) if meth.startswith(&#39;to_&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;to_clipboard&#39;,
 &#39;to_csv&#39;,
 &#39;to_dense&#39;,
 &#39;to_dict&#39;,
 &#39;to_excel&#39;,
 &#39;to_gbq&#39;,
 &#39;to_hdf&#39;,
 &#39;to_html&#39;,
 &#39;to_json&#39;,
 &#39;to_latex&#39;,
 &#39;to_msgpack&#39;,
 &#39;to_panel&#39;,
 &#39;to_period&#39;,
 &#39;to_pickle&#39;,
 &#39;to_records&#39;,
 &#39;to_sparse&#39;,
 &#39;to_sql&#39;,
 &#39;to_stata&#39;,
 &#39;to_string&#39;,
 &#39;to_timestamp&#39;,
 &#39;to_wide&#39;,
 &#39;to_xarray&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路漫漫其修远兮～～我将慢慢去求索～～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python代理类两例</title>
      <link>http://hshsh.me/post/2016-04-10-python-proxy-class-examples/</link>
      <pubDate>Sun, 10 Apr 2016 23:30:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-10-python-proxy-class-examples/</guid>
      <description>

&lt;p&gt;最近遇到MySQL的连接断开，MySQLdb报&amp;rsquo;(2006, MySQL server has gone away.)&amp;lsquo;错误的问题。&lt;/p&gt;

&lt;p&gt;问题发生的环境是，客户端使用了长连接，程序启动的时候使用MySQLdb模块的connect方法建立一个数据库连接，程序运行期间一直使用这个连接。对于请求比较多的服务程序来说，这个方法不会出现问题，因为MySQL默认连接超时的时间设定是8小时，所以连接不会超时断开，也就不会报这个错误了。但是作为一个调试服务，请求频率可能低于8小时，就导致错误了。&lt;/p&gt;

&lt;p&gt;由于不想修改很多具体实现的代码，所以使用&lt;strong&gt;代理类&lt;/strong&gt;的方法对这个程序打了个补丁解决问题。&lt;/p&gt;

&lt;p&gt;另外 SQLAlchemy 中的 &lt;code&gt;scoped_session&lt;/code&gt; 也是一个代理类，实现也很有意思，这里一起分享一下这两个代理类。&lt;/p&gt;

&lt;h2 id=&#34;mysqldb-connection-代理类&#34;&gt;MySQLdb Connection 代理类&lt;/h2&gt;

&lt;p&gt;先看看出问题的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import MySQLdb
conn = MySQLdb.connect(host=&#39;host&#39;, port=&#39;port&#39;,
                       user=&#39;user&#39;, passwd=&#39;passwd&#39;, db=&#39;db&#39;)

def use_mysql():
    cursor = conn.cursor()
    cursor.execute(&#39;do something with mysql database;&#39;)
    cursor.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MySQLdb.connect&lt;/code&gt;函数返回的是一个&lt;code&gt;Connection&lt;/code&gt;对象，当操作频率大于8个小时的时候，MySQL服务器就会关闭连接，然后下一次执行 &lt;code&gt;cursor = conn.cursor()&lt;/code&gt; 的时候，就会报连接丢失的错误。为了既使用长连接，又能避免这个错误，我们可以封装一个&lt;code&gt;Connection&lt;/code&gt;类的代理类，重载 &lt;code&gt;cursor&lt;/code&gt; 方法，当有新的请求的时候，先检查连接是否还在，如果连接丢失的话，就重新连接数据库，然后再调用 &lt;code&gt;Connection&lt;/code&gt; 类的 &lt;code&gt;cursor&lt;/code&gt; 方法并返回结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import MySQLdb
from MySQLdb.connections import Connection

class ProxyConnection(Connection):
    def __init__(self, *args, **kwargs):
        # 保存数据库连接参数以备丢失时候重新连接
        self.args = args
        self.kwargs = kwargs
        super(ProxyConnection, self).__init__(*args, **kwargs)

    def cursor(self, cursorclass=None):
        try:
            self.ping()
        except MySQLdb.OperationalError:
            super(ProxyConnection, self).__init__(*self.args, **self.kwargs)
        return super(ProxyConnection, self).cursor(cursorclass)

conn = ProxyConnection(host=&#39;host&#39;, port=&#39;port&#39;,
                       user=&#39;user&#39;, passwd=&#39;passwd&#39;, db=&#39;db&#39;)

def use_mysql():
    cursor = conn.cursor()
    cursor.execute(&#39;do something with mysql database;&#39;)
    cursor.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代理类，只重载 &lt;code&gt;cursor()&lt;/code&gt; 这一个方法，其他方法直接继承自父类 &lt;code&gt;Connection&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样就解决了MySQL数据库连接丢失的问题。但是这个方法并不是完美的，主要的缺点是每次处理新的请求时，都要 &lt;code&gt;ping()&lt;/code&gt; 一下，当请求比较多的时候，会增加不必要的开支。不过如果真的请求多的话，也就不会出现这个问题了。作为低请求频次服务的解决方法，这个代理类用起来还是很方便的。&lt;/p&gt;

&lt;p&gt;相对于这种粗糙的方法，SQLAlchemy中 &lt;code&gt;scoped_session&lt;/code&gt; 类对 Session 类的代理实现就精巧的多了，而且它并没有从被代理的 &lt;code&gt;session&lt;/code&gt; 类继承，而是一个完全独立的类（实际上&lt;code&gt;scoped_session&lt;/code&gt;是一种 &lt;a href=&#34;http://martinfowler.com/eaaCatalog/registry.html&#34;&gt;Registry 设计模式&lt;/a&gt;，实现了一些高级功能，不过这里暂时只看它的代理作用）。&lt;/p&gt;

&lt;h2 id=&#34;sqlalchemy-代理类-scoped-session&#34;&gt;SQLAlchemy 代理类 &lt;code&gt;scoped_session&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 的 Session 类是 SQLAlchemy ORM 模型对数据库操作的主要接口，定义了&lt;code&gt;query&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;, &lt;code&gt;refresh&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;等方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-pyhton&#34;&gt;# file: sqlalchemy/orm/session.py

class Session(_SessionClassMethods):
    &amp;quot;&amp;quot;&amp;quot;Manages persistence operations for ORM-mapped objects.

    The Session&#39;s usage paradigm is described at :doc:`/orm/session`.
    &amp;quot;&amp;quot;&amp;quot;

    public_methods = (
        &#39;__contains__&#39;, &#39;__iter__&#39;, &#39;add&#39;, &#39;add_all&#39;, &#39;begin&#39;, &#39;begin_nested&#39;,
        &#39;close&#39;, &#39;commit&#39;, &#39;connection&#39;, &#39;delete&#39;, &#39;execute&#39;, &#39;expire&#39;,
        &#39;expire_all&#39;, &#39;expunge&#39;, &#39;expunge_all&#39;, &#39;flush&#39;, &#39;get_bind&#39;,
        &#39;is_modified&#39;, &#39;bulk_save_objects&#39;, &#39;bulk_insert_mappings&#39;,
        &#39;bulk_update_mappings&#39;,
        &#39;merge&#39;, &#39;query&#39;, &#39;refresh&#39;, &#39;rollback&#39;,
        &#39;scalar&#39;)

    # def __init__(...):
    #     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Session类的对象可以通过 &lt;code&gt;sessionmaker(bind=engine)()&lt;/code&gt; 建立，由使用数据库的模块建立、使用，并自行管理。&lt;code&gt;scoped_session&lt;/code&gt; 类给 Session 对象提供了一层透明代理，既可以像使用 Session 对象一样使用，又可以对 Session 对象进行统一管理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类的实现代码并不复杂，而且相当的精巧，下面是全部代码（为方便阅读，已删除文档字符串）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file: sqlalchemy/orm/scoping.py

class scoped_session(object):
    session_factory = None

    def __init__(self, session_factory, scopefunc=None):
        self.session_factory = session_factory
        if scopefunc:
            self.registry = ScopedRegistry(session_factory, scopefunc)
        else:
            self.registry = ThreadLocalRegistry(session_factory)

    def __call__(self, **kw):
        if kw:
            scope = kw.pop(&#39;scope&#39;, False)
            if scope is not None:
                if self.registry.has():
                    raise sa_exc.InvalidRequestError(
                        &amp;quot;Scoped session is already present; &amp;quot;
                        &amp;quot;no new arguments may be specified.&amp;quot;)
                else:
                    sess = self.session_factory(**kw)
                    self.registry.set(sess)
                    return sess
            else:
                return self.session_factory(**kw)
        else:
            return self.registry()

    def remove(self):
        if self.registry.has():
            self.registry().close()
        self.registry.clear()

    def configure(self, **kwargs):
        if self.registry.has():
            warn(&#39;At least one scoped session is already present. &#39;
                 &#39; configure() can not affect sessions that have &#39;
                 &#39;already been created.&#39;)

        self.session_factory.configure(**kwargs)

    def query_property(self, query_cls=None):
        class query(object):
            def __get__(s, instance, owner):
                try:
                    mapper = class_mapper(owner)
                    if mapper:
                        if query_cls:
                            # custom query class
                            return query_cls(mapper, session=self.registry())
                        else:
                            # session&#39;s configured query class
                            return self.registry().query(mapper)
                except orm_exc.UnmappedClassError:
                    return None
        return query()

&amp;quot;&amp;quot;&amp;quot;Old name for backwards compatibility.&amp;quot;&amp;quot;&amp;quot;
ScopedSession = scoped_session


def instrument(name):
    def do(self, *args, **kwargs):
        return getattr(self.registry(), name)(*args, **kwargs)
    return do

for meth in Session.public_methods:
    setattr(scoped_session, meth, instrument(meth))


def makeprop(name):
    def set(self, attr):
        setattr(self.registry(), name, attr)

    def get(self):
        return getattr(self.registry(), name)

    return property(get, set)

for prop in (&#39;bind&#39;, &#39;dirty&#39;, &#39;deleted&#39;, &#39;new&#39;, &#39;identity_map&#39;,
             &#39;is_active&#39;, &#39;autoflush&#39;, &#39;no_autoflush&#39;, &#39;info&#39;):
    setattr(scoped_session, prop, makeprop(prop))


def clslevel(name):
    def do(cls, *args, **kwargs):
        return getattr(Session, name)(*args, **kwargs)
    return classmethod(do)

for prop in (&#39;close_all&#39;, &#39;object_session&#39;, &#39;identity_key&#39;):
    setattr(scoped_session, prop, clslevel(prop))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;撇开复杂的部分不说，暂时之看这个类的透明代理性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当程序需要连接数据库的时候，可以使用 &lt;code&gt;scoped_session&lt;/code&gt;，像使用&lt;code&gt;Session&lt;/code&gt;类一样，&lt;code&gt;Session&lt;/code&gt;支持的方法都支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类通过 &lt;code&gt;instrument&lt;/code&gt;, &lt;code&gt;makeprop&lt;/code&gt;, &lt;code&gt;clslevel&lt;/code&gt; 这几个函数把 &lt;code&gt;Session&lt;/code&gt; 类的方法属性“挂接”到自己身上，实现了对 &lt;code&gt;Session&lt;/code&gt; 类的透明代理&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类通过维护 Registry 来实现程序的不同部分可以共用 Session，既节省资源，又方便不同部分共享数据（不知道这样理解对不对？）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_session&lt;/code&gt; 对象的作用域是线程局部的，类内部通过以 &lt;code&gt;threading.local()&lt;/code&gt; 作为 Registry 的键值，来区分不同线程中的对象，不同的线程不共享Session对象，这样就实现了线程安全，写程序的时候只需要使用 &lt;code&gt;scoped_session&lt;/code&gt; 来操作就好了，而不需要再关注线程相关的东西了。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;有时候，代理类用着还是很方便的。我是一个初学者，如果本文中有谬误，请不吝指正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[转载] Python类引入机制</title>
      <link>http://hshsh.me/post/2016-04-08-python-import-schema/</link>
      <pubDate>Fri, 08 Apr 2016 09:27:54 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-08-python-import-schema/</guid>
      <description>

&lt;p&gt;本文转载自&lt;a href=&#34;http://liuchang0812.com&#34;&gt;刘畅的博客&lt;/a&gt;，&lt;a href=&#34;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&#34;&gt;文章地址&lt;/a&gt;。本文所涉及到的代码在&lt;a href=&#34;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&#34;&gt;github&lt;/a&gt;上。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Python 是一门优美简单、功能强大的动态语言。在刚刚接触这门语言时，我们会被其优美的格式、简洁的语法和无穷无尽的类库所震撼。在真正的将python应用到实际的项目中，你会遇到一些无法避免的问题。最让人困惑不解的问题有二类，一个 编码问题，另一个则是引用问题。&lt;/p&gt;

&lt;p&gt;本文主要讨论关于Python中import的机制与实现、以及介绍一些有意思的Python Hooks。&lt;/p&gt;

&lt;h2 id=&#34;python-类库引入机制&#34;&gt;Python 类库引入机制&lt;/h2&gt;

&lt;p&gt;首先，看一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
目录结构如下：
├── __init__.py
├── main.py
└── string.py
&amp;quot;&amp;quot;&amp;quot;
# main.py 内容如下
import string
print string.a
# string.py 内容如下
a = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，考虑一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当我们执行main.py的时候，会发生什么事情？&lt;/li&gt;
&lt;li&gt;在main.py文件执行到&lt;code&gt;import string&lt;/code&gt;的时候，解释器导入的string类库是当前文件夹下的string.py还是系统标准库的string.py呢？&lt;/li&gt;
&lt;li&gt;如果明确的指明自己要引用的类库？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了搞清楚上面的问题，我们需要了解关于Python类库引入的机制。&lt;/p&gt;

&lt;h2 id=&#34;python的两种引入机制&#34;&gt;Python的两种引入机制&lt;/h2&gt;

&lt;p&gt;Python 提供了二种引入机制：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;relative import&lt;/li&gt;
&lt;li&gt;absolute import&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;relative-import&#34;&gt;relative import&lt;/h3&gt;

&lt;p&gt;relative import 也叫作相对引入，在Python2.5及之前是默认的引入方法。它的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from .string import a
from ..string import a
from ...string import a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种引入方式使用一个点号来标识引入类库的精确位置。与linux的相对路径表示相似，一个点表示当前目录，每多一个点号则代表向上一层目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
├── __init__.py
├── foo.py
└── main.py
&amp;quot;&amp;quot;&amp;quot;
# foo.py
a = 2
# main.py
print __name__
from .foo import a
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对引入，那么我们需要知道相对什么来引入。相对引入使用被引入文件的&lt;code&gt;__name__&lt;/code&gt;属性来决定该文件在整个包结构的位置。那么如果文件的&lt;code&gt;__name__&lt;/code&gt;没有包含任何包的信息，例如&lt;code&gt;__name__&lt;/code&gt;被设置为了&lt;code&gt;__main__&lt;/code&gt;，则认为其为‘top level script&amp;rsquo;，而不管该文件的位置，这个时候相对引入就没有引入的参考物。如上面的程序所示，当我们执行&lt;code&gt;python main.py&lt;/code&gt;时，Python解释器会抛出 ValueError: Attempted relative import in non-package 的异常。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，&lt;a href=&#34;https://www.python.org/dev/peps/pep-0366/&#34;&gt;PEP 0366 &amp;ndash; Main module explicit relative imports&lt;/a&gt;提出了一个解决方案。允许用户使用&lt;code&gt;python -m ex2.main&lt;/code&gt;的方式,来执行该文件。在这个方案下，引入了一个新的属性&lt;code&gt;__package__&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
╭─liuchang@localhost  ~/Codes/pycon
╰─$ cat ex2/main.py
print __name__
print __package__
from .foo import a
print a
╭─liuchang@localhost  ~/Codes/pycon
╰─$ python -m ex2.main
__main__
ex2
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;absolute-import&#34;&gt;absolute import&lt;/h3&gt;

&lt;p&gt;absolute import 也叫作完全引入，非常类似于Java的引入进制，在Python2.5被完全实现，但是是需要通过&lt;code&gt;from __future__ import absolute_import&lt;/code&gt;来打开该引入进制。在Python2.6之后以及Python3，完全引用成为Python的默认的引入机制。它的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from pkg import foo
from pkg.moduleA import foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，需要从包目录最顶层目录依次写下，而不能从中间开始。&lt;/p&gt;

&lt;p&gt;在使用该引入方式时，我们碰到比较多的问题就是因为位置原因，Python找不到相应的库文件，抛出ImportError的异常。让我们看一个完全引用的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
ex3
├── __init__.py
├── foo.py
└── main.py
&amp;quot;&amp;quot;&amp;quot;
# foo.py
a = 2

# main.py
print __name__
print __package__
from ex2.foo import a
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们尝试着去运行main.py文件，Python解释器会抛出ImportError。那么我们如何解决这个问题呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╰─$ python ex3/main.py
__main__
None
Traceback (most recent call last):
  File &amp;quot;ex3/main.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    from ex2.foo import a
ImportError: No module named ex2.foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，我们也可以使用前文所述的module的方式去运行程序，通过-m参数来告诉解释器&lt;code&gt;__package__&lt;/code&gt;属性。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ python -m ex3.main
__main__
ex3
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们还有一个办法可以解决该问题，在描述之前，我们介绍一个关于Python的非常有用的小知识：&lt;strong&gt;Python解释器会自动将当前工作目录添加到PYTHONPATH&lt;/strong&gt;。如下所示，可以看到我们打印出的&lt;code&gt;sys.path&lt;/code&gt;已经包含了当前工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon/ex4
╰─$ cat main.py
import sys
print sys.path
╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon/ex4
╰─$ python main.py
[&#39;/Users/liuchang/Codes/pycon/ex4&#39;,
&#39;/Library/Python/2.7/site-packages/pip-7.1.0-py2.7.egg&#39;,
&#39;/Library/Python/2.7/site-packages/mesos-_PACKAGE_VERSION_-py2.7.egg&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload&#39;,
&#39;/Users/liuchang/Library/Python/2.7/lib/python/site-packages&#39;,
&#39;/usr/local/lib/python2.7/site-packages&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC&#39;,
&#39;/Library/Python/2.7/site-packages&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;了解了Python解释器的这个特性后，我们就可以解决完全引用的找不到类库的问题：执行的时候，让解释器自动的将类库的目录添加到PYTHONPATH中。&lt;/p&gt;

&lt;p&gt;我们可以在顶层目录中添加一个run_ex3.py的文件，文件内容和运行结果如下，可以看到Python解释器正确的执行了ex3.main文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ cat run_ex3.py
from ex3 import main
╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ python run_ex3.py
ex3.main
None
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一些实践经验&#34;&gt;一些实践经验&lt;/h2&gt;

&lt;h3 id=&#34;相对引用还是绝对引用&#34;&gt;相对引用还是绝对引用？&lt;/h3&gt;

&lt;p&gt;上面介绍了Python的两种引用方式，都可以解决引入歧义的问题。那我们应该使用哪一种呢？&lt;/p&gt;

&lt;p&gt;先说明一下Python的默认引用方式，在Python2.4及之前，Python只有相对引用这一种方式，在Python2.5中实现了绝对引用，但默认没有打开，需要用户自己指定使用该引用方式。在之后的版本和Python3版本，绝对引用已经成为默认的引用方式。&lt;/p&gt;

&lt;p&gt;其次，二种引用方式各有利弊。绝对引用代码更加清晰明了，可以清楚的看到引入的包名和层次，但是，当包名修改的时候，我们需要手动修改所有的引用代码。相对引用则比较精简，不会被包名修改所影响，但是可读性较差，不如完全引用清晰。&lt;/p&gt;

&lt;p&gt;最后，对于两种引用的方式选择，还是有争论的。在PEP8中，Python官方推荐的是绝对引用,详细理由可以参考&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/#imports&#34;&gt;这儿&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Absolute imports are recommended, as they are usually more readable and tend to be better behaved (or at least give better error messages) if the import system is incorrectly configured (such as when a directory inside a package ends up on sys.path ):&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;However, explicit relative imports are an acceptable alternative to absolute imports, especially when dealing with complex package layouts where using absolute imports would be unnecessarily verbose:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import sibling
from .sibling import example
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Standard library code should avoid complex package layouts and always use absolute imports.
Implicit relative imports should never be used and have been removed in Python 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;规范打包发布&#34;&gt;规范打包发布&lt;/h3&gt;

&lt;p&gt;为了别人使用自己代码的方便，应该尽量使用规范的包分发机制。为自己的Python包编写正确的setup.py文件，添加相应的README.md文件。对于提供一些可执行命令的包，则可以使用 console_entrypoint 的机制来提供。因为打包和分发不是本文重点，不再详细叙述，大家可以查看官方文档。&lt;/p&gt;

&lt;h3 id=&#34;使用virtualenv管理包依赖&#34;&gt;使用virtualenv管理包依赖&lt;/h3&gt;

&lt;p&gt;在使用Python的时候，尽量使用virtualenv来管理项目，所有的项目从编写到运行都在特定的virtualenv中。并且为自己的项目生成正确的依赖描述文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于virtualenv的用法，可以参考我之前的一篇文章&lt;a href=&#34;http://lcblog-wordpress.stor.sinaapp.com/uploads/2015/10/virtualenv教程.pdf&#34;&gt;virtualenv教程&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;python-import实现&#34;&gt;Python import实现&lt;/h2&gt;

&lt;p&gt;Python 提供了 import 语句来实现类库的引用，下面我们详细介绍当执行了 import 语句的时候，内部究竟做了些什么事情。&lt;/p&gt;

&lt;p&gt;当我们执行一行 &lt;code&gt;from package import module as mymodule&lt;/code&gt;命令时，Python解释器会查找package这个包的module模块，并将该模块作为mymodule引入到当前的工作空间。所以import语句主要是做了二件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查找相应的module&lt;/li&gt;
&lt;li&gt;加载module到local namespace&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们详细了解python是如何查找模块的。&lt;/p&gt;

&lt;h3 id=&#34;查找module的过程&#34;&gt;查找module的过程&lt;/h3&gt;

&lt;p&gt;在import的第一个阶段，主要是完成了查找要引入模块的功能，这个查找的过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查 sys.modules (保存了之前import的类库的缓存），如果module被找到，则⾛到第二步。&lt;/li&gt;
&lt;li&gt;检查 sys.meta_path。meta_path 是一个 list，⾥面保存着一些 finder 对象，如果找到该module的话，就会返回一个finder对象。&lt;/li&gt;
&lt;li&gt;检查⼀些隐式的finder对象，不同的python实现有不同的隐式finder，但是都会有 sys.path_hooks, sys.path_importer_cache 以及sys.path。&lt;/li&gt;
&lt;li&gt;抛出 ImportError。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;sys-modules&#34;&gt;sys.modules&lt;/h3&gt;

&lt;p&gt;对于第一步中sys.modules，我们可以打开Python来实际的查看一下其内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python 2.7.10 (default, Aug 22 2015, 20:33:39)
[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.1)] on darwin
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.modules
{&#39;copy_reg&#39;: &amp;lt;module &#39;copy_reg&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/copy_reg.pyc&#39;&amp;gt;,
&#39;sre_compile&#39;: &amp;lt;module &#39;sre_compile&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_compile.pyc&#39;&amp;gt;,
&#39;_sre&#39;: &amp;lt;module &#39;_sre&#39; (built-in)&amp;gt;,
&#39;encodings&#39;: &amp;lt;module &#39;encodings&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/__init__.pyc&#39;&amp;gt;,
&#39;site&#39;: &amp;lt;module &#39;site&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site.pyc&#39;&amp;gt;,
&#39;__builtin__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;,
&#39;sysconfig&#39;: &amp;lt;module &#39;sysconfig&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sysconfig.pyc&#39;&amp;gt;,
&#39;encodings.encodings&#39;: None,
&#39;__main__&#39;: &amp;lt;module &#39;__main__&#39; (built-in)&amp;gt;,
&#39;supervisor&#39;: &amp;lt;module &#39;supervisor&#39; (built-in)&amp;gt;,
&#39;abc&#39;: &amp;lt;module &#39;abc&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/abc.pyc&#39;&amp;gt;,
&#39;posixpath&#39;: &amp;lt;module &#39;posixpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/posixpath.pyc&#39;&amp;gt;,
&#39;_weakrefset&#39;: &amp;lt;module &#39;_weakrefset&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_weakrefset.pyc&#39;&amp;gt;,
&#39;errno&#39;: &amp;lt;module &#39;errno&#39; (built-in)&amp;gt;,
&#39;encodings.codecs&#39;: None,
&#39;sre_constants&#39;: &amp;lt;module &#39;sre_constants&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_constants.pyc&#39;&amp;gt;,
&#39;re&#39;: &amp;lt;module &#39;re&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/re.pyc&#39;&amp;gt;,
&#39;_abcoll&#39;: &amp;lt;module &#39;_abcoll&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_abcoll.pyc&#39;&amp;gt;,
&#39;types&#39;: &amp;lt;module &#39;types&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/types.pyc&#39;&amp;gt;,
&#39;_codecs&#39;: &amp;lt;module &#39;_codecs&#39; (built-in)&amp;gt;,
&#39;encodings.__builtin__&#39;: None,
&#39;_warnings&#39;: &amp;lt;module &#39;_warnings&#39; (built-in)&amp;gt;,
&#39;genericpath&#39;: &amp;lt;module &#39;genericpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/genericpath.pyc&#39;&amp;gt;,
&#39;stat&#39;: &amp;lt;module &#39;stat&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/stat.pyc&#39;&amp;gt;,
&#39;zipimport&#39;: &amp;lt;module &#39;zipimport&#39; (built-in)&amp;gt;,
&#39;_sysconfigdata&#39;: &amp;lt;module &#39;_sysconfigdata&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_sysconfigdata.pyc&#39;&amp;gt;,
&#39;mpl_toolkits&#39;: &amp;lt;module &#39;mpl_toolkits&#39; (built-in)&amp;gt;,
&#39;warnings&#39;: &amp;lt;module &#39;warnings&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/warnings.pyc&#39;&amp;gt;,
&#39;UserDict&#39;: &amp;lt;module &#39;UserDict&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/UserDict.pyc&#39;&amp;gt;,
&#39;encodings.utf_8&#39;: &amp;lt;module &#39;encodings.utf_8&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/utf_8.pyc&#39;&amp;gt;,
&#39;sys&#39;: &amp;lt;module &#39;sys&#39; (built-in)&amp;gt;,
&#39;_osx_support&#39;: &amp;lt;module &#39;_osx_support&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_osx_support.pyc&#39;&amp;gt;,
&#39;codecs&#39;: &amp;lt;module &#39;codecs&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.pyc&#39;&amp;gt;,
&#39;readline&#39;: &amp;lt;module &#39;readline&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/readline.so&#39;&amp;gt;,
&#39;os.path&#39;: &amp;lt;module &#39;posixpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/posixpath.pyc&#39;&amp;gt;,
&#39;_locale&#39;: &amp;lt;module &#39;_locale&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/_locale.so&#39;&amp;gt;,
&#39;signal&#39;: &amp;lt;module &#39;signal&#39; (built-in)&amp;gt;,
&#39;traceback&#39;: &amp;lt;module &#39;traceback&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/traceback.pyc&#39;&amp;gt;,
&#39;linecache&#39;: &amp;lt;module &#39;linecache&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/linecache.pyc&#39;&amp;gt;,
&#39;posix&#39;: &amp;lt;module &#39;posix&#39; (built-in)&amp;gt;,
&#39;encodings.aliases&#39;: &amp;lt;module &#39;encodings.aliases&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/aliases.pyc&#39;&amp;gt;,
&#39;exceptions&#39;: &amp;lt;module &#39;exceptions&#39; (built-in)&amp;gt;,
&#39;sre_parse&#39;: &amp;lt;module &#39;sre_parse&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_parse.pyc&#39;&amp;gt;,
&#39;os&#39;: &amp;lt;module &#39;os&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.pyc&#39;&amp;gt;,
&#39;_weakref&#39;: &amp;lt;module &#39;_weakref&#39; (built-in)&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; sys.modules[&#39;zlib&#39;].__file__
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/zlib.so&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到sys.modules已经保存了一些包的信息，由这些信息，我们就可以直接知道要查找的包的位置等信息。&lt;/p&gt;

&lt;h3 id=&#34;finder-loader和importer&#34;&gt;finder、loader和importer&lt;/h3&gt;

&lt;p&gt;在上文中，我们提到了sys.meta_path中保证了一些finder对象。在python中，不仅定义了finder的概念，还定义了loader和importor的概念。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finder的任务是决定自己是否根据名字找到相应的模块，在py2中，finder对象必须实现find_module()方法，在py3中必须要实现find_module()或者find_loader（)方法。如果finder可以查找到模块，则会返回一个loader对象(在py3.4中，修改为返回一个module specs)。&lt;/li&gt;
&lt;li&gt;loader则是负责加载模块，它必须实现一个load_module()的方法。&lt;/li&gt;
&lt;li&gt;importer 则指一个对象，实现了finder和loader的方法。因为Python是duck type，只要实现了方法，就可以认为是该类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sys-meta-path&#34;&gt;sys.meta_path&lt;/h3&gt;

&lt;p&gt;在Python查找的时候，如果在sys.modules没有查找到，就会依次调用sys.meta_path中的finder对象。默认的情况下，sys.meta_path是一个空列表，并没有任何finder对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In [6]: sys.meta_path
Out[6]: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以向sys.meta_path中添加一些定义的finder，来实现对Python加载模块的修改。比如下例，我们实现了一个会将每次加载包的信息打印出来的finder。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import sys

class Watcher(object):
    @classmethod
    def find_module(cls, name, path, target=None):
        print(&amp;quot;Importing&amp;quot;, name, path, target)
        return None

sys.meta_path.insert(0, Watcher)

import socket
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们执行的时候，就可以看到系统加载socket包时所发生的事情。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; ╭─liuchang@localhost  ~/Codes/pycon/ex5_meta_path
 ╰─$ python finder1.py
 Importing socket None None
 Importing _socket None None
 Importing functools None None
 Importing _functools None None
 Importing _ssl None None
 Importing cStringIO None None
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sys-path-hook&#34;&gt;sys.path hook&lt;/h3&gt;

&lt;p&gt;Python import的hook分为二类，一类是上一章节已经描述的meta hook，另一类是 path hook。&lt;/p&gt;

&lt;p&gt;当处理sys.path（或者package.&lt;strong&gt;path&lt;/strong&gt;)时，就会调用对应的一部分的 Pack hook。Path Hook是通过向sys.path_hooks 中添加一个importer生成器来注册的。&lt;/p&gt;

&lt;p&gt;sys.path_hooks 是由可被调用的对象组成，它会顺序的检查以决定他们是否可以处理给定的sys.path的一项。每个对象会使用sys.path项的路径来作为参数被调用。如果它不能处理该路径，就必须抛出ImportError，如果可以，则会返回一个importer对象。之后，不会再尝试其它的sys.path_hooks对象，即使前一个importer出错了。&lt;/p&gt;

&lt;p&gt;详细可以参考&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302/#specification-part-2-registering-hooks&#34;&gt;registering-hooks&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;python-import-hooks&#34;&gt;python import hooks&lt;/h2&gt;

&lt;p&gt;在介绍完Python的引用机制与一些实现方法后，接下来我们介绍一些关于如何根据自己的需求来扩展Python的引用机制。&lt;/p&gt;

&lt;p&gt;在开始详细介绍前，给大家展示一个实用性不高，但是很有意思的例子：&lt;strong&gt;让Python在执行代码的时候自动安装缺失的类库&lt;/strong&gt;。我们会实现一个autoinstall的模块，只要import了该模块，就可以打开该功能。如下所示，我们尝试引入tornado库的时候，iPython会提示我们没有安装。然后，我们引入了autoinstall，再尝试引入tornado，iPython就会自动的安装tornado库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In [1]: import tornado
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
&amp;lt;ipython-input-1-3eac10687b7e&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 import tornado

ImportError: No module named tornado

In [2]: import autoinstall

In [3]: import tornado
Installing tornado

Collecting tornado
  Downloading tornado-4.2.1.tar.gz (434kB)
Collecting backports.ssl-match-hostname (from tornado)
  Downloading http://182.92.2.186:7002/packages/backports.ssl_match_hostname-3.4.0.2-py2-none-any.whl
Collecting certifi (from tornado)
  Downloading certifi-2015.9.6.2-py2.py3-none-any.whl (371kB)
Installing collected packages: backports.ssl-match-hostname, certifi, tornado
  Running setup.py install for tornado
Successfully installed backports.ssl-match-hostname-3.4.0.2 certifi-2015.9.6.2 tornado-4.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个功能的实现其实很简单，利用了sys.meta_path。autoinstall的全部代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import sys
import subprocess


class AutoInstall(object):
    _loaded = set()

    @classmethod
    def find_module(cls, name, path, target=None):
        if path is None and name not in cls._loaded:
            cls._loaded.add(name)
            print(&amp;quot;Installing&amp;quot;, name)
            try:
                out = subprocess.check_output(
                    [&#39;sudo&#39;, sys.executable, &#39;-m&#39;, &#39;pip&#39;, &#39;install&#39;, name])
                print(out)
            except Exception as e:
                print(&amp;quot;Failed&amp;quot; + e.message)
        return None

sys.meta_path.append(AutoInstall)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;import-hook的重要性&#34;&gt;import hook的重要性&lt;/h3&gt;

&lt;p&gt;我们为什么需要Python import的hook呢？使用import的hook可以让我们做到很多事情，比如说当我们的Python包存储在一个非标准的文件中，或者Python程序存储在网络数据库中，或者像py2exe一样将Python程序打包成了一个文件，我们需要一种方法来正确的解析它们。&lt;/p&gt;

&lt;p&gt;其次，我们希望在Python加载类库的时候，可以额外的做一些事情，比如上传审计信息，比如延迟加载，比如自动解决上例的依赖未安装的问题。&lt;/p&gt;

&lt;p&gt;所以，import系统的Hook技术是值的花时间学习的。&lt;/p&gt;

&lt;h3 id=&#34;如何实现import-hooks&#34;&gt;如何实现import hooks&lt;/h3&gt;

&lt;p&gt;Python提供了一些方法，让我们可以在代码中动态的调用import。主要有如下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;__import__ : Python的内置函数&lt;/li&gt;
&lt;li&gt;imputil        : Python的import工具库，在py2.6被声明废弃，py3中彻底移除。&lt;/li&gt;
&lt;li&gt;imp            : Python2 的一个import库，py3中移除&lt;/li&gt;
&lt;li&gt;importlib      : Python3 中最新添加，backport到py2.7，但只有很小的子集（只有一个函数）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python2 所有关于import的库的列表参见&lt;a href=&#34;https://docs.python.org/2/library/modules.html&#34;&gt;Importing Modules&lt;/a&gt;。Python3 的可以参考&lt;a href=&#34;https://docs.python.org/3/library/modules.html&#34;&gt;Importing Modules&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302&#34;&gt;PEP 0302 &amp;ndash; New Import Hooks&lt;/a&gt; 提案详细的描述了importlib的目的、用法。&lt;/p&gt;

&lt;h3 id=&#34;一些hook示例&#34;&gt;一些Hook示例&lt;/h3&gt;

&lt;h3 id=&#34;lazy化库引入&#34;&gt;Lazy化库引入&lt;/h3&gt;

&lt;p&gt;使用Import Hook，我们可以达到Lazy Import的效果，当我们执行import的时候，实际上并没引入该库，只有真正的使用这个库的时候，才会将其引入到当前工作空间。
具体的代码可以参考&lt;a href=&#34;https://github.com/noahmorrison/limp&#34;&gt;github&lt;/a&gt;。
实现的效果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python

import limp  # Lazy imports begin now

import json
import sys

print(&#39;json&#39; in sys.modules)  # False
print(&#39;, &#39;.join(json.loads(&#39;[&amp;quot;Hello&amp;quot;, &amp;quot;World!&amp;quot;]&#39;)))
print(&#39;json&#39; in sys.modules)  # True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的实现也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import imp

_lazy_modules = {}

class LazyModule():
    def __init__(self, name):
        self.name = name

    def __getattr__(self, attr):
        path = _lazy_modules[self.name]
        f, pathname, desc = imp.find_module(self.name, path)

        lf = sys.meta_path.pop()
        imp.load_module(self.name, f, pathname, desc)
        sys.meta_path.append(lf)


        self.__dict__ = sys.modules[self.name].__dict__
        return self.__dict__[attr]

class LazyFinder(object):

    def find_module(self, name, path):
        _lazy_modules[name] = path
        return self

    def load_module(self, name):
        return LazyModule(name)

sys.meta_path.append(LazyFinder())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flask-插件库统一入口&#34;&gt;Flask 插件库统一入口&lt;/h3&gt;

&lt;p&gt;使用过Flask的同学都知道，Flask的对于插件提供了统一的入口。比如说我们安装了Flask_API这个库，然后我们可以直接&lt;code&gt;import flask_api&lt;/code&gt;来使用这个库，同时Flask还允许我们采用&lt;code&gt;import flask.ext.api&lt;/code&gt;的方式来引用该库。&lt;/p&gt;

&lt;p&gt;这里Flask就是使用了import 的hook，当引入flask.ext的包时，就自动的引用相应的库。Flask实现了一个叫ExtensionImporter的类，这个类实现了find_module和load_module代码实现如下&lt;a href=&#34;https://github.com/mitsuhiko/flask/blob/master/flask/exthook.py#L27&#34;&gt;github&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ExtensionImporter(object):
    &amp;quot;&amp;quot;&amp;quot;This importer redirects imports from this submodule to other locations.
    This makes it possible to transition from the old flaskext.name to the
    newer flask_name without people having a hard time.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, module_choices, wrapper_module):
        self.module_choices = module_choices
        self.wrapper_module = wrapper_module
        self.prefix = wrapper_module + &#39;.&#39;
        self.prefix_cutoff = wrapper_module.count(&#39;.&#39;) + 1

    def __eq__(self, other):
        return self.__class__.__module__ == other.__class__.__module__ and \
               self.__class__.__name__ == other.__class__.__name__ and \
               self.wrapper_module == other.wrapper_module and \
               self.module_choices == other.module_choices

    def __ne__(self, other):
        return not self.__eq__(other)

    def install(self):
        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]

    def find_module(self, fullname, path=None):
        if fullname.startswith(self.prefix):
            return self

    def load_module(self, fullname):
        if fullname in sys.modules:
            return sys.modules[fullname]
        modname = fullname.split(&#39;.&#39;, self.prefix_cutoff)[self.prefix_cutoff]
        for path in self.module_choices:
            realname = path % modname
            try:
                __import__(realname)
            except ImportError:
                exc_type, exc_value, tb = sys.exc_info()
                # since we only establish the entry in sys.modules at the
                # very this seems to be redundant, but if recursive imports
                # happen we will call into the move import a second time.
                # On the second invocation we still don&#39;t have an entry for
                # fullname in sys.modules, but we will end up with the same
                # fake module name and that import will succeed since this
                # one already has a temporary entry in the modules dict.
                # Since this one &amp;quot;succeeded&amp;quot; temporarily that second
                # invocation now will have created a fullname entry in
                # sys.modules which we have to kill.
                sys.modules.pop(fullname, None)

                # If it&#39;s an important traceback we reraise it, otherwise
                # we swallow it and try the next choice.  The skipped frame
                # is the one from __import__ above which we don&#39;t care about
                if self.is_important_traceback(realname, tb):
                    reraise(exc_type, exc_value, tb.tb_next)
                continue
            module = sys.modules[fullname] = sys.modules[realname]
            if &#39;.&#39; not in modname:
                setattr(sys.modules[self.wrapper_module], modname, module)
            return module
        raise ImportError(&#39;No module named %s&#39; % fullname)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在Flask的ext目录下的__init__.py文件中，初始化了该Importer。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def setup():
    from ..exthook import ExtensionImporter
    importer = ExtensionImporter([&#39;flask_%s&#39;, &#39;flaskext.%s&#39;], __name__)
    importer.install()
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;希望坚持阅读到本处的你，能明白Python import的用法、实现和改造方法。准备仓促，难免会有错误，欢迎大家指正和PR。&lt;/p&gt;

&lt;p&gt;本文使用CC-BY-SA协议。&lt;/p&gt;

&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302/&#34;&gt;https://www.python.org/dev/peps/pep-0302/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0338/&#34;&gt;https://www.python.org/dev/peps/pep-0338/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0328/&#34;&gt;https://www.python.org/dev/peps/pep-0328/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0366/&#34;&gt;https://www.python.org/dev/peps/pep-0366/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/noahmorrison/limp&#34;&gt;https://github.com/noahmorrison/limp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mitsuhiko/flask&#34;&gt;https://github.com/mitsuhiko/flask&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MySQL配置文件参考</title>
      <link>http://hshsh.me/post/2016-04-05-mysql-configuration-notes/</link>
      <pubDate>Tue, 05 Apr 2016 14:48:25 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-05-mysql-configuration-notes/</guid>
      <description>

&lt;p&gt;最近公式生产环境中使用MySQL做数据存储，把数据库跑起来不复杂，但是各种参数的设置调优可真是技术活。&lt;/p&gt;

&lt;p&gt;这是配置MySQL的学习笔记，大部分内容出自：&lt;a href=&#34;http://wsgzao.github.io/post/ltmp/&#34;&gt;http://wsgzao.github.io/post/ltmp/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mysql数据库配置&#34;&gt;MySQL数据库配置&lt;/h2&gt;

&lt;h3 id=&#34;mysql客户端配置&#34;&gt;MySQL客户端配置：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[client]
# 客户端连接默认字符集
default-character-set = utf8
port = 3306
socket = /tmp/mysql.sock

[mysql]
#prompt=&amp;quot;(\u:HOSTNAME:)[\d]&amp;gt; &amp;quot;
#mysql提示符中显示当前用户、数据库、时间等信息
prompt=&amp;quot;\u@\h \R:\m:\s [\d]&amp;gt; &amp;quot;
#no-auto-rehash  # 自动补全功能，取消自动补全可以提高启动速度
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql服务端配置&#34;&gt;MySQL服务端配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[mysqld]
# 唯一的服务标识号，主从同步会涉及
server-id = 1
port = 3306
user = mysql
basedir = /app/local/mysql
datadir = /app/data/mysql/data
socket = /tmp/mysql.sock
log-error = /app/data/mysql/mysql_error.log
pid-file = /app/data/mysql/mysql.pid
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES

# 默认存储引擎
default-storage-engine = InnoDB
# 设置最大并发连接数，如果前端程序是PHP，可适当加大，但不可过大。
# 如果前端程序采用连接池，可适当调小，避免连接数过大
max_connections = 512
# 最大连接错误次数，可适当加大，防止频繁连接错误后，前端host被mysql拒绝掉
max_connect_errors = 100000
# 所有线程所打开表的数量
table_open_cache = 512
# 不允许外部文件级别的锁. 打开文件锁会对性能造成负面影响
external-locking = FALSE
# 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小
max_allowed_packet = 32M
# 启用慢查询日志
slow_query_log = 1
slow_query_log_file = /app/data/mysql/slow.log
# MySQL打开的文件描述符限制
open_files_limit = 10240
# 操作系统在监听队列中所能保持的连接数
back_log = 600
# 每个连接都会分配的一些排序、连接等缓冲
sort_buffer_size = 16M
join_buffer_size = 16M
read_buffer_size = 16M
read_rnd_buffer_size = 16M
# 在cache中保留多少线程用于重用
thread_cache_size = 300
# 查询缓冲     
query_cache_size = 128M
# 只有小于此设定值的结果才会被缓冲     
query_cache_limit = 4M
# 设置查询缓存分配内存的最小单位
query_cache_min_res_unit = 2k
# 线程使用的堆大小
thread_stack = 512K
# 设置事务隔离级别为 READ-COMMITED，提高事务效率，通常都满足事务一致性要求
transaction_isolation = READ-COMMITTED
# 临时表的最大大小
tmp_table_size = 256M
# 独立的内存表所允许的最大容量
max_heap_table_size = 256M
# 设置慢查询阀值
long_query_time = 3
# 表示slave将复制事件写进自己的二进制日志
log-slave-updates
# 打开二进制日志功能
log-bin = /app/data/mysql/binlog/binlog
sync_binlog = 1
# 在一个事务中binlog为了记录SQL状态所持有的cache大小  
binlog_cache_size = 4M
# 设置混合模式
binlog_format = MIXED
# 表示的是binlog能够使用的最大cache 内存大小
max_binlog_cache_size = 8M
# binlog最大值
max_binlog_size = 1G
# 启用中继日志
relay-log-index = /app/data/mysql/relaylog/relaylog
relay-log-info-file = /app/data/mysql/relaylog/relaylog
relay-log = /app/data/mysql/relaylog/relaylog
# 设置了只保留7天binlog
expire_logs_days = 7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;myisam-相关选项&#34;&gt;MyISAM 相关选项&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;#关键词缓冲的大小, 一般用来缓冲MyISAM表的索引块
key_buffer_size = 128M
#排序缓存
read_rnd_buffer_size = 64M
#限制每个进程中缓冲树的字节数
bulk_insert_buffer_size = 256M
#MyISAM表发生变化时重新排序所需的缓冲
myisam_sort_buffer_size = 256M
#MySQL重建索引时所允许的最大临时文件的大小
myisam_max_sort_file_size = 10G
#如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们
myisam_repair_threads = 1
#自动检查和修复没有适当关闭的 MyISAM 表
myisam_recover
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;innodb-相关选项&#34;&gt;InnoDB 相关选项&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;# InnoDB存储数据字典、内部数据结构的缓冲池，16MB 已经足够大了     
innodb_additional_mem_pool_size = 16M
# InnoDB用于缓存数据、索引、锁、插入缓冲、数据字典等
# 如果是专用的DB服务器，且以InnoDB引擎为主的场景，通常可设置物理内存的50%
# 如果是非专用DB服务器，可以先尝试设置成内存的1/4，如果有问题再调整
innodb_buffer_pool_size = 4G
# InnoDB共享表空间初始化大小，默认是 10MB，也非常坑X，改成 1GB，并且自动扩展
innodb_data_file_path = ibdata1:1G:autoextend
# 如果将此参数设置为1，将在每次提交事务后将日志写入磁盘，能较好保护数据可靠性。
# 为提供性能可以设置为0或2，但要承担在发生故障时丢失数据的风险
innodb_flush_log_at_trx_commit = 1
# InnoDB的log buffer，通常设置为 64MB 就足够了
innodb_log_buffer_size = 64M
# InnoDB redo log大小，通常设置256MB 就足够了
innodb_log_file_size = 256M
# InnoDB redo log文件组，通常设置为 2 就足够了
innodb_log_files_in_group = 2
# Buffer_Pool中Dirty_Page所占的数量，直接影响InnoDB的关闭时间
innodb_max_dirty_pages_pct = 90
# 启用InnoDB的独立表空间模式，便于管理
innodb_file_per_table = 1
# 控制innodb是否对gap加锁
innodb_locks_unsafe_for_binlog = 0
# 设置连接超时阀值，如果前端程序采用短连接，建议缩短这2个值
# 如果前端程序采用长连接，可直接注释掉这两个选项，是用默认配置(8小时)
interactive_timeout = 120
wait_timeout = 120
# 不再进行反解析(ip不反解成域名)，这样可以加快数据库的反应时间
skip-name-resolve
# 主从复制跳过错误
slave-skip-errors = 1032,1062,126,1114,1146,1048,1396
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其他配置选项&#34;&gt;其他配置选项&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[mysqldump]
# 不要在将内存中的整个结果写入磁盘之前缓存. 在导出非常巨大的表时需要此项
quick
max_allowed_packet = 32M
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://wsgzao.github.io/post/ltmp/&#34;&gt;LTMP手动编译安装以及全自动化部署实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.mysql.com/doc/refman/5.7/en/charset-configuration.html&#34;&gt;MySQL 5.7 Reference Manual: Character Set Configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy学习笔记（一）</title>
      <link>http://hshsh.me/post/2016-04-04-sqlalchemy-study-notes-01/</link>
      <pubDate>Mon, 04 Apr 2016 19:18:09 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-04-sqlalchemy-study-notes-01/</guid>
      <description>

&lt;p&gt;这篇笔记部分内容来自网络&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fn-copyright&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fn-copyright&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，部分来自对《Essential SQLAlchemy》的学习和使用经验。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;是 Python 编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，使用MIT许可证发行。&lt;/p&gt;

&lt;p&gt;SQLAlchemy“采用简单的Python语言，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型”。&lt;/p&gt;

&lt;p&gt;SQLAlchemy的理念是，SQL数据库的量级和性能重要于对象集合；而对象集合的抽象又重要于表和行。因此，SQLAlchmey 采用了类似于Java里 Hibernate 的数据映射模型，而不是其他ORM框架采用的 Active Record 模型。不过，Elixir 和 declarative 等可选插件可以让用户使用声明语法。&lt;/p&gt;

&lt;p&gt;SQLAlchemy首次发行于2006年2月，并迅速地在Python社区中最广泛使用的ORM工具之一，不亚于Django的ORM框架。&lt;/p&gt;

&lt;p&gt;以上摘自&lt;a href=&#34;https://zh.wikipedia.org/wiki/SQLAlchemy&#34;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;使用&lt;code&gt;SQLAlchemy&lt;/code&gt;有三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 Raw SQL&lt;/li&gt;
&lt;li&gt;使用 SQL Expression&lt;/li&gt;
&lt;li&gt;使用 ORM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两种方式可以统称为 core 方式。&lt;/p&gt;

&lt;p&gt;对于绝大多数应用，推荐使用 &lt;code&gt;SQLAlchemy&lt;/code&gt;，即使是使用 Raw SQL，也可以带来如下好处。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内建数据库连接池。&lt;strong&gt;注意：&lt;/strong&gt;如果是 SQLAlchemy + cx_oracle 的话，需要禁用 Connection Pool，否则会有异常。方法是设置&lt;code&gt;sqlalchemy.poolclass&lt;/code&gt;为&lt;code&gt;sqlalchemy.pool.NullPool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;强大的日志功能（log）&lt;/li&gt;
&lt;li&gt;数据库无关的写法，包括：SQL参数写法、LIMIT语法等&lt;/li&gt;
&lt;li&gt;特别提一下，WHERE 条件的 &lt;code&gt;== value&lt;/code&gt; 写法，如果&lt;code&gt;value&lt;/code&gt;等于&lt;code&gt;None&lt;/code&gt;，真正的SQL会转为 &lt;code&gt;IS NULL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SQLAlchemy 的 Raw SQL 和 SQL Expression 比较：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SQL Expression 的写法是纯 Python 代码，阅读性更好，尤其是在使用 &lt;code&gt;insert()&lt;/code&gt; 方法时，字段名和取值成对出现。&lt;/li&gt;
&lt;li&gt;Raw SQL 比 SQL Expression 更灵活，如果 SQL/DDL 很复杂，Raw SQL 就更有优势了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;常用数据库连接字符串&#34;&gt;常用数据库连接字符串&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy import create_engine

# file database
# sqlite = create_engine(&#39;sqlite:////absolute/path/to/database.db&#39;)
# in-memory database, two ways
# sqlite = create_engine(&#39;sqlite://&#39;)
sqlite = create_engine(&#39;sqlite:///:memory:&#39;)
# postgresql
pgsql = create_engine(&#39;postgres://user:passwd@host:port/database&#39;)
# mysql
mysql = create_engine(&#39;mysql://user:passwd@host:port/database&#39;)
# oracle
oracle = create_engine(&#39;oracle://user:passwd@host:port/sidname&#39;)
# oracle via TNS name
oracle_tns = create_engine(&#39;oracle://user:passwd@tnsname&#39;)
# ms sql server using ODBC datasource names.
PyODBC is the default driver
# mssql = create_engine(&#39;mssql://mydsn&#39;)
mssql = create_engine(&#39;mssql://user:passwd@mydsn&#39;)
# firebird
firebird = create_engine(&#39;firebird://user:passwd@host/some.gdm&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;connection-less-执行和-connection-执行&#34;&gt;Connection less 执行和 Connection 执行&lt;/h2&gt;

&lt;p&gt;直接使用 &lt;code&gt;engine&lt;/code&gt; 执行SQL的方式，叫做 connection less 执行。&lt;/p&gt;

&lt;p&gt;先使用 &lt;code&gt;engine.connect()&lt;/code&gt; 获取连接对象 &lt;code&gt;conn&lt;/code&gt;，然后通过 &lt;code&gt;conn&lt;/code&gt; 执行SQL的方式，叫做 connection 执行。&lt;/p&gt;

&lt;p&gt;如果要在 transaction 模式下执行，推荐使用 connection 方式；如果不涉及 transaction，两种方法效果是一样的。&lt;/p&gt;

&lt;h2 id=&#34;使用-text-函数封装sql字符串&#34;&gt;使用&lt;code&gt;text()&lt;/code&gt;函数封装SQL字符串&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;text()&lt;/code&gt; 函数有很多好处：&lt;/p&gt;

&lt;p&gt;1). 不同数据库，可以使用统一的SQL参数传递写法，参数需以“冒号”引出，在调用 &lt;code&gt;execute()&lt;/code&gt; 的时候，使用 dict 结构将实参传进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import text

result = db.execute(
   text(&#39;select * from table where id &amp;lt; :id and typeName = :type&#39;),
   {&#39;id&#39;: 2, &#39;type&#39;: &#39;USER_TABLE&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2). 如果不指定参数的类型，默认为字符串类型；如果要传递日期参数，需要使用 &lt;code&gt;text()&lt;/code&gt; 的 &lt;code&gt;bindparams&lt;/code&gt; 参数来声明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime, timedelta
from sqlalchemy import DateTime, bindparam

# ten days ago
date_param = datetime.today() + timedelta(days=-1*10)
sql = &#39;delete from caw_job_alarm_log where alarm_time &amp;lt; :alarm_time_param&#39;
t = text(sql, bindparams=[
        bindparam(&#39;alarm_time_param&#39;, type_=DateTime, required=True)])
db.execute(t, {&#39;alarm_time_param&#39;: date_param})
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参数 &lt;code&gt;bindparam&lt;/code&gt; 可以使用 &lt;code&gt;type_&lt;/code&gt; 来制定参数的类型，也可以使用 initial 值来指定参数的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;bindparam(&#39;alart_time_param&#39;, type_=DateTime)  # or
bindparam(&#39;alart_time_param&#39;, DateTime())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3). 如果要转换查询结果中的数据类型，可以通过 &lt;code&gt;text()&lt;/code&gt; 的参数 &lt;code&gt;typemap&lt;/code&gt; 参数指定。这点比 mybatis 还灵活：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import Integer, Unicode

t = text(&#39;select id, name from users&#39;,
         typemap={&#39;id&#39;: Integer, &#39;name&#39;: Unicode})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4). 其他好处，详见 sqlalchemy/sql/expression.py 中的 docstring。&lt;/p&gt;

&lt;h2 id=&#34;sqlalchemy-访问数据库&#34;&gt;SQLAlchemy 访问数据库&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;create_engine&lt;/code&gt; 函数返回一个 &lt;code&gt;Engine&lt;/code&gt; 对象。通过 &lt;code&gt;Engine&lt;/code&gt; 对象的 &lt;code&gt;execute&lt;/code&gt; 方法可以执行数据库操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;execute&lt;/code&gt; 方法返回一个 &lt;code&gt;ResultProxy&lt;/code&gt; 对象，&lt;code&gt;ResultProxy&lt;/code&gt; 类是对 &lt;code&gt;Cursor&lt;/code&gt; 类的封装，其中的 &lt;code&gt;cursor&lt;/code&gt; 属性对应原来的 &lt;code&gt;cursor&lt;/code&gt;，这个类有很多方法对应着 &lt;code&gt;Cursor&lt;/code&gt; 类的方法，另外又扩展了一些属性和方法。&lt;/p&gt;

&lt;p&gt;对 &lt;code&gt;ResultProxy&lt;/code&gt; 对象进行遍历时，得到的每一行都是一个 &lt;code&gt;RowProxy&lt;/code&gt; 对象，获取字段的方法非常灵活，索引、字段名，甚至属性都行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;row_proxy[0] == row_proxy[&#39;id&#39;] == row_proxy.id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看得出来，&lt;code&gt;RowProxy&lt;/code&gt; 跟Java的 POJO 类有相似的特性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import create_engine

db = create_engine(&#39;sqlite:///:memory:&#39;, echo=True)

# DDL
db.execute(&#39;create table users(userid char(10), username char(50))&#39;)

# DML
result = db.execute(
    &amp;quot;insert into users (userid, username) values (&#39;user1&#39;, &#39;tony&#39;)&amp;quot;)
# get rows affected by an UPDATE or DELETE statement,
# it is not intended to provide the number of rows present from SELECT
result.rowcount
# True if this ResultProxy returns rows.
result.returns_rows

# Query
result = db.execute(&amp;quot;select * from users&amp;quot;)
result.scalar()  # 可以返回一个标量查询的值
result.fetchall()   # 取回所有的行
result.fetchmany()  # 取回多行
result.fetchone()   # 取回一行，并判断有且只有一行，若超出一行则报错
result.first()      # 取回第一行
result.close()  # result 用完之后，需要关闭
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLAlchemy 支持事务，甚至可以嵌套事务。&lt;/p&gt;

&lt;p&gt;缺省情况下事务自动提交，即执行一条SQL就自动提交。&lt;/p&gt;

&lt;p&gt;如果要更精准的控制事务，最简单的方法是使用 &lt;code&gt;connection&lt;/code&gt;，然后通过 &lt;code&gt;connection&lt;/code&gt; 获取 &lt;code&gt;transaction&lt;/code&gt; 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# transaction
connection = db.connect()
trans = connection.begin()
try:
    do_something_with(connection)
    trans.commit()
except:
    trans.rollback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方式是在创建 &lt;code&gt;engine&lt;/code&gt; 对象时指定 &lt;code&gt;strategy=&#39;threadlocal&#39;&lt;/code&gt; 参数，这样会自动创建一个线程局部的连接，对于后续的无连接的执行都会自动使用这个连接，这样在处理事务时，只要使用 &lt;code&gt;engine&lt;/code&gt; 对象来操作事务就行了。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;db = create_engine(connection, strategy=&#39;threadlocal&#39;)
db.begin()
try:
    do_something()
except:
    db.rollback()
else:
    db.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果希望手动提交事务，也可以在 &lt;code&gt;connection&lt;/code&gt; 和 &lt;code&gt;statement&lt;/code&gt; 上通过 &lt;code&gt;execute_options()&lt;/code&gt; 方法修改为手动提交模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conn.execute_options(autocommit=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置为手动提交模式后，要提交事务，需要调用 &lt;code&gt;conn.commit()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h2 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 默认的连接池算法选用规则为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接内存中的 SQLite，默认的连接池算法为 &lt;code&gt;SingletonThreadPool&lt;/code&gt; 类，即两个线程允许一个连接；&lt;/li&gt;
&lt;li&gt;连接基于文件的 SQLite，默认的i连接池算法为 &lt;code&gt;NullPool&lt;/code&gt; 类，即不使用连接池；&lt;/li&gt;
&lt;li&gt;对于其他情况，默认的连接池算法为 &lt;code&gt;QueuePool&lt;/code&gt; 类。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们也可以实现自己的连接池算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db = create_engine(&#39;sqlite:///file.db&#39;, poolclass=YourPoolClass)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;create_engine()&lt;/code&gt; 函数和连接池相关的参数有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pool_recycle: 默认为-1，推荐设置为7200，即如果 &lt;code&gt;connection&lt;/code&gt; 空闲了 7200秒 = 2小时，自动重新获取，以防止 &lt;code&gt;connection&lt;/code&gt; 被数据库服务器关闭；&lt;/li&gt;
&lt;li&gt;pool_size: 保持连接数，默认为5，正式环境下该数值偏小，需根据实际情况调整；&lt;/li&gt;
&lt;li&gt;max_overflow: 超出 &lt;code&gt;pool_size&lt;/code&gt; 后允许的最大连接数，默认为10，这10个连接在使用过后，不放在连接池中，而是被真正关闭的。&lt;/li&gt;
&lt;li&gt;pool_timeout: 获取连接的超时阀值，默认为30秒。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;国内的云服务平台 &lt;a href=&#34;http://sae.sina.com.cn&#34;&gt;SAE&lt;/a&gt; 中的共享型 MySQL 服务不支持连接池，如果在其上部署应用，需要禁用连接池，也就是使用 &lt;code&gt;NullPool&lt;/code&gt; 类，否则会报 &amp;lsquo;(2006, MySQL server has gone away)&amp;rsquo; 错误。&lt;/p&gt;

&lt;h2 id=&#34;日志输出&#34;&gt;日志输出&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 默认输出日志到 &lt;code&gt;sys.stdout&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果要输出到文件，log 文件不具备 rotate 功能，不推荐在生产环境中使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import logging
logging.getLogger(&#39;sqlalchemy.engine&#39;).setLevel(logging.INFO)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;create_engine()&lt;/code&gt; 函数时，可选传递一个参数 &lt;code&gt;echo=True&lt;/code&gt; 来打开详细信息输出，这个功能信息量非常大，只适合调试使用，不建议生产环境中使用。&lt;/p&gt;

&lt;h2 id=&#34;最佳实践与使用心得&#34;&gt;最佳实践与使用心得&lt;/h2&gt;

&lt;p&gt;使用 ORM 方式构建复杂查询比较困难，使用 Raw SQL 和 SQL Expression 会比较合适一些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;declarative&lt;/code&gt; 是 SQLAlchemy 的一个新的扩展功能 ，只能用在 ORM 方式中，不适用在 Raw SQL 和 SQL Expression 方式。&lt;/p&gt;

&lt;p&gt;如果使用 ORM 方式，表必须有主键，使用 Raw SQL 和 SQL Express 方式没有这个约束。&lt;/p&gt;

&lt;p&gt;查询有简单的也有复杂的，使用 Raw SQL 会比较方便。&lt;/p&gt;

&lt;p&gt;增、删、改，多是单表操作，使用 SQL Expression 就足够了。具体讲，比如一个 &lt;code&gt;User&lt;/code&gt; 类，&lt;strong&gt;可以包含一个固定的 &lt;code&gt;_table&lt;/code&gt; 成员&lt;/strong&gt;，增删改直接使用 &lt;code&gt;_table&lt;/code&gt; 对象来完成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_table = Table(&#39;users&#39;, metadata, autoload=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;批量的 insert/update/delete 操作，可以将每行数据组成一个 dict，在将这些 dict 组成一个 list，和 _table.insert()/update()/delete() 一起作为参数传给 `conn.execute()&amp;lsquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import Table

# _table member object
_table = Table(&#39;users&#39;, metadata, autoload=True)
# insert
_table.insert().values(f1=value1, f2=value2)
# update
_table.update().values(f1=new_value1, f2=new_value2).where(
    _table.c.f1 == value1).where(_table.c.f2 == value2)
# delete
_table.delete().where(_table.c.f1 == value1).where(
    _table.c.f2 == value2)

# batch opration
conn.execute(_table.insert(), [
        {&#39;user_id&#39;: 1, &#39;email_address&#39;: &#39;jack@yahoo.com&#39;},
        {&#39;user_id&#39;: 1, &#39;email_address&#39;: &#39;jack@msn.com&#39;},
        {&#39;user_id&#39;: 2, &#39;email_address&#39;: &#39;susan@example.com&#39;},
        {&#39;user_id&#39;: 2, &#39;email_address&#39;: &#39;susan@example.org&#39;}
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL Expression 也可以像 Raw SQL 的 &lt;code&gt;text()&lt;/code&gt; 函数一样使用 &lt;code&gt;bindparam&lt;/code&gt;，方法是在调用 insert()/update()/delete() 时声明参数，然后在 &lt;code&gt;conn.execute()&lt;/code&gt; 执行时候，将参数传递进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = _table.delete().where(_table.c.hire_date &amp;lt;= bindparam(
    &#39;hire_day&#39;, DateTime(), required=True))
conn.execute(d, {&#39;hire_day&#39;: datetime.today()})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;where()&lt;/code&gt; 和 ORM 中的 &lt;code&gt;filter()&lt;/code&gt; 接受一样的参数，各种SQL条件都支持：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# equals, not equals
where(_table.c.name == &#39;ed&#39;)
where(_table.c.name != &#39;ed&#39;)
# like
where(_table.c.name.like(&#39;%ed%&#39;))
# in, not in
where(_table.c.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))
where(~_table.c.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))
# is null, is not null
where(_table.c.name == None)
where(_table.c.name != None)

# and, or
from sqlalchemy import and_, or_
where(and_(_table.c.name == &#39;ed&#39;, _table.c.fullname == &#39;Ed Jones&#39;))
where(or_(_table.c.name == &#39;ed&#39;, _table.c.name == &#39;wendy&#39;))
# and can also be written with multiple where clause
where(_table.c.name == &#39;ed&#39;).where(_table.c.fullname == &#39;Ed Jones&#39;)

# match: contents of the match parameter are database backend specific
where(_table.c.name.match(&#39;wendy&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fn-copyright&#34;&gt;出处已不可考，如有侵权请联系我。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fn-copyright&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Linux常用打包解包命令备忘</title>
      <link>http://hshsh.me/post/2016-04-02-linux-pack-and-unpack/</link>
      <pubDate>Sat, 02 Apr 2016 22:33:15 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-02-linux-pack-and-unpack/</guid>
      <description>

&lt;h2 id=&#34;tar&#34;&gt;.tar&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;tar cvf file.tar dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;tar xvf filename.tar&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;gz&#34;&gt;.gz&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;gzip dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;gzip -d filename.gz&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tar-gz&#34;&gt;.tar.gz&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;tar zcvf file.tar.gz dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;tar zxvf file.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tar-bz2&#34;&gt;.tar.bz2&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;tar jcvf file.tar.bz2 dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;tar jxvf filename.tar.bz2&lt;/code&gt; or &lt;code&gt;tar jxvf filename.tar.bz&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;zip&#34;&gt;.zip&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;zip file.zip dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;unzip filename.zip&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;rar&#34;&gt;.rar&lt;/h2&gt;

&lt;p&gt;安装： &lt;code&gt;sudo apt-get install rar&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打包： &lt;code&gt;rar e dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;rar a filename.rar&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;z&#34;&gt;.z&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;compress dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;uncompress filename.z&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tar-z&#34;&gt;.tar.Z&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;tar Zcvf file.tar.Z dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;tar Zxvf filename.tar.Z&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tgz&#34;&gt;.tgz&lt;/h2&gt;

&lt;p&gt;解包： &lt;code&gt;tar zxvf filename.tgz&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tar-tgz&#34;&gt;.tar.tgz&lt;/h2&gt;

&lt;p&gt;打包： &lt;code&gt;tar zcvf file.tar.tgz dirname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解包： &lt;code&gt;tar zxvf filename.tar.tgz&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Pandoc制作精美的EPUB、MOBI、PDF电子书</title>
      <link>http://hshsh.me/post/2014-01-13-make-beautiful-ebooks-with-pandoc/</link>
      <pubDate>Mon, 13 Jan 2014 10:38:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2014-01-13-make-beautiful-ebooks-with-pandoc/</guid>
      <description>

&lt;h2 id=&#34;缘起&#34;&gt;缘起&lt;/h2&gt;

&lt;p&gt;在亚马逊上购买了一部 Kindle Paperwhite，设备还没有拿到手，就先在网上找一找电子书。结果是网络上的电子书资源确实是不少，但是质量确是参差不齐，只有少数书籍排版精美，书签完整，大多数简直惨不忍睹，可以说严重影响阅读体验。&lt;/p&gt;

&lt;p&gt;之前接触到了Pandoc这个文本格式转换的瑞士军刀，知道它可以简便的输出HTML、PDF、EPUB、DOCX等等各类格式，所以就想着能不能自己动手制作排版精美的电子书。经过一番探索，发现可以使用Pandoc和KindleGen非常方便的制作排版精良的电子书。本着造福买不起纸质书的广大群众的意愿，将所得方法及操作技巧发布出来，于是有了本文。&lt;/p&gt;

&lt;h2 id=&#34;简便制作和精美电子书的定义&#34;&gt;简便制作和精美电子书的定义&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简便制作&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从网络上到处可以下载到的TXT格式可以方便的转换为排好版的电子书&lt;/li&gt;
&lt;li&gt;源文件一次整理，可以直接输出为不同格式的电子文档，比如通过一条命名，或者一两次鼠标点击&lt;/li&gt;
&lt;li&gt;简单方便的控制书籍排版格式（全书格式统一），比如通过一个CSS文件&lt;/li&gt;
&lt;li&gt;修改书籍内容时，不影响书籍排版格式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;精美电子书&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;带有目录，支持EPUB、MOBI阅读软件导航功能&lt;/li&gt;
&lt;li&gt;标题、正文、引用字段使用不同字体区分，便于识别阅读&lt;/li&gt;
&lt;li&gt;段落距离、缩进与行距设置适中，便于识别阅读&lt;/li&gt;
&lt;li&gt;整书排版格式统一，清晰易读，无过多分散注意力的元素&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;相关技术说明&#34;&gt;相关技术说明&lt;/h2&gt;

&lt;p&gt;这里应该先从Markdown说起，作为一种轻量级的标记语言，Markdown很适合用来写作，能够让作者把精力集中在书籍的内容撰写上面，而不会被排版等问题分散精力。在一份典型的Markdown文件中，作者使用简单的符号来标记诸如标题、段落、引用、列表、图表等等结构元素，而不记录排版相关的内容。具体的排版工作留给编译器来处理，也就是在从Markdown源文件输出HTML、PDF、EPUB等出版格式的时候才确定，并且可以简便的通过格式控制指令（CSS文件、Latex模板）来控制排版格式。Pandoc就是这么一个编译器，它与其它Markdown解释器相比，有它自己的优点：扩展的Markdown的语法，弥补了Markdown语法结构简单的问题；可以生成很多种格式的文件，甚至Word文档也可以；使用模板控制输出结果，定制简单，等等。关于Markdown和Pandoc的更多信息，请参阅本节的&lt;a href=&#34;#markdown-pandoc-readings&#34;&gt;拓展阅读&lt;/a&gt;和文末的&lt;a href=&#34;#foot-reference&#34;&gt;参考资料&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于使用OCR或者网络下载的TXT文件制作电子书来说，并不需要掌握Markdown和Pandoc的全部知识，只需要知道基本的Markdown语法就行了：标题、段落、引用、列表、图表等，这些很简单，查看Markdown的语法说明，一会儿就能掌握。按照Markdown的语法对TXT文件进行格式化，然后使用本文中展示的模板文件和编译命令，就可以直接输出为EPUB、MOBI、PDF（A4、6寸，或者其它定制尺寸）文件了。&lt;/p&gt;

&lt;p&gt;生成EPUB是Pandoc原生自带的功能，只需要在源文件中填入相关的metadata属性，整理好书籍内容，直接一条命名就OK了。&lt;/p&gt;

&lt;p&gt;生成MOBI使用亚马逊的KindleGen软件，由上面生成的EPUB文件为参数转换而来，生成的MOBI文件同时包含旧的MOBI格式和新的KF8格式，可以直接向Amazon网上商店发布，也可以使用Calibre软件（需要安装MobiUnpack插件）拆分为单独的MOBI和AZW3文件。&lt;/p&gt;

&lt;p&gt;生成6寸或A4尺寸的PDF，也是Pandoc原生自带的功能，Pandoc根据源文件生成Latex文件，然后使用Latex来生成PDF文件。Latex生成的PDF质量高、排版精美是众所周知的，但是它的语法非常复杂，学习曲线陡峭，把一般用户远远地挡在了大门外。现在有了Pandoc，我们就可以以非常少的工作享用Latex输出的高质量PDF了，当然了这需要Latex软件，只要安装Pandoc用户指南中推荐的&lt;a href=&#34;http://miktex.org/&#34;&gt;MikTex&lt;/a&gt;即可。不同尺寸的PDF只需要在运行pandoc命令时指定相应的模板文件就行了。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;markdown-pandoc-readings&#34;&gt;&lt;/span&gt;
关于Markdown和Pandoc的拓展阅读：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://zh.wikipedia.org/wiki/Markdown&#34;&gt;Markdown - 维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://iout.in/archives/454.html&#34;&gt;Markdown+Pandoc 最佳写作拍档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;操作步骤&#34;&gt;操作步骤&lt;/h2&gt;

&lt;p&gt;前面已经把使用到的程序，相关的原理都已经交代了，实际上真正操作起来，步骤非常简单。&lt;/p&gt;

&lt;h3 id=&#34;安装使用到的软件&#34;&gt;安装使用到的软件&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;安装Pandoc&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;从Pandoc官方网站&lt;a href=&#34;https://code.google.com/p/pandoc/downloads/list&#34;&gt;下载适用于Windows的安装包&lt;/a&gt;安装，下一步、下一步，就OK了&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fn-pandoc&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fn-pandoc&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装MikTex&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;从&lt;a href=&#34;http://miktex.org/&#34;&gt;MikTex&lt;/a&gt;官方网站下载MikTex安装包进行安装，可以选择安装版本或者便携版本均可。 如果选择使用便携版本，需要把MikTex的执行文件路径添加到系统路径中。&lt;/p&gt;

&lt;h3 id=&#34;整理源文件&#34;&gt;整理源文件&lt;/h3&gt;

&lt;p&gt;用Pandoc的语法把文章的结构标记出来，各章节标题、引用、表格、插图等等。并把书籍内容文件命名为 &lt;code&gt;book.md&lt;/code&gt; 。如果对正则表达式熟悉的话，这里可以使用sed或者其它编辑器对文件进行批量处理。这不是本文的讨论内容，这里就不再详述，如果有兴趣，请自行查阅相关资料。&lt;/p&gt;

&lt;p&gt;添加EPUB元数据到 &lt;code&gt;meta.md&lt;/code&gt; 文件，这里使用markdown文件中内嵌的YAML来书写，详见&lt;a href=&#34;http://johnmacfarlane.net/pandoc/README.html#epub-metadata&#34;&gt;Pandoc用户指南中的EPUB元数据部分&lt;/a&gt;和本文样书源文件中的 &lt;code&gt;meta.md&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;下载或制作一张封面图片命名为 &lt;code&gt;cover.jpg&lt;/code&gt; 与书籍的源文件放在同一个目录。&lt;/p&gt;

&lt;h3 id=&#34;根据需要修改模板文件&#34;&gt;根据需要修改模板文件&lt;/h3&gt;

&lt;p&gt;本文附件模板中的 epub.css 文件是控制生成的EPUB和MOBI文件排版格式的，如果有需要，请根据需要进行修改，比如正文字体、引用段落字体、各级标题字体字号等。需要注意的是MOBI并不能支持完整的CSS规范，详情请参阅&lt;a href=&#34;#foot-reference&#34;&gt;参考资料 Amazon Kindle Publishing Guidelines&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;附件模板中的 default.epub 文件是Pandoc生成EPUB时使用的HTML模板，需要放在用户数据目录下的 &lt;code&gt;templates&lt;/code&gt; 文件夹中，详细见&lt;a href=&#34;#foot-reference&#34;&gt;参考资料 Pandoc User&amp;rsquo;s Guide&lt;/a&gt; 中的 &lt;code&gt;--data-dir&lt;/code&gt; 部分。如有需要，也可以进行修改。&lt;/p&gt;

&lt;p&gt;附件模板中的 kindle.latex (6 inch) 和 zhtw.latex (A4) 文件是控制生成的PDF文件排版格式的，如果有需要，请根据需要进行修改，页边距、字体、字号、段落间距、行间距等。&lt;/p&gt;

&lt;h3 id=&#34;生成电子书&#34;&gt;生成电子书&lt;/h3&gt;

&lt;p&gt;把源文件整理好后，只需要运行下面的命令就可以输出包含目录、支持导航、排版精美的电子书了。&lt;/p&gt;

&lt;p&gt;使用Pandoc和KindleGen生成电子书的命令（模板文件 &lt;code&gt;_tmpl/build.bat&lt;/code&gt;）：&lt;/p&gt;

&lt;div&gt;&lt;pre&gt;&lt;code&gt;:: A4 pdf
pandoc meta.md book.md --toc --template=zhtw --latex-engine=xelatex ^
    --no-tex-ligatures -V documentclass=scrartcl -o A4.pdf
:: 6 inch pdf
pandoc meta.md book.md --toc --template=kindle --latex-engine=xelatex ^
    --no-tex-ligatures -V documentclass=scrartcl -o output.pdf
:: epub
pandoc meta.md book.md -o output.epub
:: mobi
kindelgen output.epub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过上面这几条命令，已经生成好了各种格式和尺寸的电子书，是不是很简便？有没有很过瘾的感觉？&lt;/p&gt;

&lt;p&gt;顺带一提，本文及本网站也都是用Pandoc生成的 ~ ~&lt;/p&gt;

&lt;p&gt;最后，忠心的祝愿网络上能够有越来越多的高质量电子书供我们这些买不起纸质书的穷屌丝们阅读。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;模板及样书下载&#34;&gt;模板及样书下载&lt;/h2&gt;

&lt;p&gt;前文中提到的文件模板，以及南怀瑾大师著述的《南怀瑾选集·第十卷·原本大学微言》源文件和生成的电子书（包括EPUB、MOBI、6寸和A4尺寸的PDF）作为示例样书，可以从我的百度网盘下载：&lt;/p&gt;

&lt;p&gt;&lt;small style=&#34;color: red; font-style:italic&#34;&gt;（2016/4/2更新：链接已失效，暂时没有时间更新）&lt;/small&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模板：&lt;s&gt;&lt;a href=&#34;http://pan.baidu.com/s/1o6rvZAU&#34;&gt;http://pan.baidu.com/s/1o6rvZAU&lt;/a&gt;&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;源文件：&lt;s&gt;&lt;a href=&#34;http://pan.baidu.com/s/1iWWdo&#34;&gt;http://pan.baidu.com/s/1iWWdo&lt;/a&gt;&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;电子书：&lt;s&gt;&lt;a href=&#34;http://pan.baidu.com/s/1nt6Xcud&#34;&gt;http://pan.baidu.com/s/1nt6Xcud&lt;/a&gt;&lt;/s&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span id=&#34;foot-reference&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://johnmacfarlane.net/pandoc/README.html&#34;&gt;Pandoc User&amp;rsquo;s Guide&lt;/a&gt;：Pandoc用法，以YAML格式书写 epub metadata&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kindlegen.s3.amazonaws.com/AmazonKindlePublishingGuidelines.pdf&#34;&gt;Amazon Kindle Publishing Guidelines&lt;/a&gt;：Amazon Kindle MOBI 格式参考&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://puppetlabs.com/blog/automated-ebook-generation-convert-markdown-epub-mobi-pandoc-kindlegen&#34;&gt;How We Automated Our Ebook Builds With Pandoc and KindleGen&lt;/a&gt;：从epub文件自动生成mobi文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tzengyuxio/pages/tree/gh-pages/pandoc&#34;&gt;Pandoc latex 模板参考&lt;/a&gt;：Pandoc 中文 PDF 模板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.bibodeng.com/tools/140.html&#34;&gt;xelatex在文档处理中的使用&lt;/a&gt;：Pandoc latex 中文字体处理&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;hi.baidu.com/asnahu/item/59ce80a9ce7e9a15a8cfb707&#34;&gt;LaTeX quote 重定义&lt;/a&gt;：Pandoc latex 模板定制&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fn-pandoc&#34;&gt;撰写本文时，Pandoc最新版本为 1.12.3
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fn-pandoc&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>