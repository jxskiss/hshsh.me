<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sqlalchemy on hshsh&#39;s little site</title>
    <link>http://hshsh.me/tags/sqlalchemy/</link>
    <description>Recent content in Sqlalchemy on hshsh&#39;s little site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 04 Apr 2016 19:18:09 +0800</lastBuildDate>
    <atom:link href="http://hshsh.me/tags/sqlalchemy/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SQLAlchemy学习笔记（一）</title>
      <link>http://hshsh.me/post/2016-04-04-sqlalchemy-study-notes-01/</link>
      <pubDate>Mon, 04 Apr 2016 19:18:09 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-04-sqlalchemy-study-notes-01/</guid>
      <description>

&lt;p&gt;这篇笔记部分内容来自网络&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fn-copyright&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fn-copyright&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，部分来自对《Essential SQLAlchemy》的学习和使用经验。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;是 Python 编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，使用MIT许可证发行。&lt;/p&gt;

&lt;p&gt;SQLAlchemy“采用简单的Python语言，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型”。&lt;/p&gt;

&lt;p&gt;SQLAlchemy的理念是，SQL数据库的量级和性能重要于对象集合；而对象集合的抽象又重要于表和行。因此，SQLAlchmey 采用了类似于Java里 Hibernate 的数据映射模型，而不是其他ORM框架采用的 Active Record 模型。不过，Elixir 和 declarative 等可选插件可以让用户使用声明语法。&lt;/p&gt;

&lt;p&gt;SQLAlchemy首次发行于2006年2月，并迅速地在Python社区中最广泛使用的ORM工具之一，不亚于Django的ORM框架。&lt;/p&gt;

&lt;p&gt;以上摘自&lt;a href=&#34;https://zh.wikipedia.org/wiki/SQLAlchemy&#34;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;使用&lt;code&gt;SQLAlchemy&lt;/code&gt;有三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 Raw SQL&lt;/li&gt;
&lt;li&gt;使用 SQL Expression&lt;/li&gt;
&lt;li&gt;使用 ORM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两种方式可以统称为 core 方式。&lt;/p&gt;

&lt;p&gt;对于绝大多数应用，推荐使用 &lt;code&gt;SQLAlchemy&lt;/code&gt;，即使是使用 Raw SQL，也可以带来如下好处。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内建数据库连接池。&lt;strong&gt;注意：&lt;/strong&gt;如果是 SQLAlchemy + cx_oracle 的话，需要禁用 Connection Pool，否则会有异常。方法是设置&lt;code&gt;sqlalchemy.poolclass&lt;/code&gt;为&lt;code&gt;sqlalchemy.pool.NullPool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;强大的日志功能（log）&lt;/li&gt;
&lt;li&gt;数据库无关的写法，包括：SQL参数写法、LIMIT语法等&lt;/li&gt;
&lt;li&gt;特别提一下，WHERE 条件的 &lt;code&gt;== value&lt;/code&gt; 写法，如果&lt;code&gt;value&lt;/code&gt;等于&lt;code&gt;None&lt;/code&gt;，真正的SQL会转为 &lt;code&gt;IS NULL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SQLAlchemy 的 Raw SQL 和 SQL Expression 比较：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SQL Expression 的写法是纯 Python 代码，阅读性更好，尤其是在使用 &lt;code&gt;insert()&lt;/code&gt; 方法时，字段名和取值成对出现。&lt;/li&gt;
&lt;li&gt;Raw SQL 比 SQL Expression 更灵活，如果 SQL/DDL 很复杂，Raw SQL 就更有优势了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;常用数据库连接字符串&#34;&gt;常用数据库连接字符串&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy import create_engine

# file database
# sqlite = create_engine(&#39;sqlite:////absolute/path/to/database.db&#39;)
# in-memory database, two ways
# sqlite = create_engine(&#39;sqlite://&#39;)
sqlite = create_engine(&#39;sqlite:///:memory:&#39;)
# postgresql
pgsql = create_engine(&#39;postgres://user:passwd@host:port/database&#39;)
# mysql
mysql = create_engine(&#39;mysql://user:passwd@host:port/database&#39;)
# oracle
oracle = create_engine(&#39;oracle://user:passwd@host:port/sidname&#39;)
# oracle via TNS name
oracle_tns = create_engine(&#39;oracle://user:passwd@tnsname&#39;)
# ms sql server using ODBC datasource names.
PyODBC is the default driver
# mssql = create_engine(&#39;mssql://mydsn&#39;)
mssql = create_engine(&#39;mssql://user:passwd@mydsn&#39;)
# firebird
firebird = create_engine(&#39;firebird://user:passwd@host/some.gdm&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;connection-less-执行和-connection-执行&#34;&gt;Connection less 执行和 Connection 执行&lt;/h2&gt;

&lt;p&gt;直接使用 &lt;code&gt;engine&lt;/code&gt; 执行SQL的方式，叫做 connection less 执行。&lt;/p&gt;

&lt;p&gt;先使用 &lt;code&gt;engine.connect()&lt;/code&gt; 获取连接对象 &lt;code&gt;conn&lt;/code&gt;，然后通过 &lt;code&gt;conn&lt;/code&gt; 执行SQL的方式，叫做 connection 执行。&lt;/p&gt;

&lt;p&gt;如果要在 transaction 模式下执行，推荐使用 connection 方式；如果不涉及 transaction，两种方法效果是一样的。&lt;/p&gt;

&lt;h2 id=&#34;使用-text-函数封装sql字符串&#34;&gt;使用&lt;code&gt;text()&lt;/code&gt;函数封装SQL字符串&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;text()&lt;/code&gt; 函数有很多好处：&lt;/p&gt;

&lt;p&gt;1). 不同数据库，可以使用统一的SQL参数传递写法，参数需以“冒号”引出，在调用 &lt;code&gt;execute()&lt;/code&gt; 的时候，使用 dict 结构将实参传进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import text

result = db.execute(
   text(&#39;select * from table where id &amp;lt; :id and typeName = :type&#39;),
   {&#39;id&#39;: 2, &#39;type&#39;: &#39;USER_TABLE&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2). 如果不指定参数的类型，默认为字符串类型；如果要传递日期参数，需要使用 &lt;code&gt;text()&lt;/code&gt; 的 &lt;code&gt;bindparams&lt;/code&gt; 参数来声明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime, timedelta
from sqlalchemy import DateTime, bindparam

# ten days ago
date_param = datetime.today() + timedelta(days=-1*10)
sql = &#39;delete from caw_job_alarm_log where alarm_time &amp;lt; :alarm_time_param&#39;
t = text(sql, bindparams=[
        bindparam(&#39;alarm_time_param&#39;, type_=DateTime, required=True)])
db.execute(t, {&#39;alarm_time_param&#39;: date_param})
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参数 &lt;code&gt;bindparam&lt;/code&gt; 可以使用 &lt;code&gt;type_&lt;/code&gt; 来制定参数的类型，也可以使用 initial 值来指定参数的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;bindparam(&#39;alart_time_param&#39;, type_=DateTime)  # or
bindparam(&#39;alart_time_param&#39;, DateTime())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3). 如果要转换查询结果中的数据类型，可以通过 &lt;code&gt;text()&lt;/code&gt; 的参数 &lt;code&gt;typemap&lt;/code&gt; 参数指定。这点比 mybatis 还灵活：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import Integer, Unicode

t = text(&#39;select id, name from users&#39;,
         typemap={&#39;id&#39;: Integer, &#39;name&#39;: Unicode})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4). 其他好处，详见 sqlalchemy/sql/expression.py 中的 docstring。&lt;/p&gt;

&lt;h2 id=&#34;sqlalchemy-访问数据库&#34;&gt;SQLAlchemy 访问数据库&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;create_engine&lt;/code&gt; 函数返回一个 &lt;code&gt;Engine&lt;/code&gt; 对象。通过 &lt;code&gt;Engine&lt;/code&gt; 对象的 &lt;code&gt;execute&lt;/code&gt; 方法可以执行数据库操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;execute&lt;/code&gt; 方法返回一个 &lt;code&gt;ResultProxy&lt;/code&gt; 对象，&lt;code&gt;ResultProxy&lt;/code&gt; 类是对 &lt;code&gt;Cursor&lt;/code&gt; 类的封装，其中的 &lt;code&gt;cursor&lt;/code&gt; 属性对应原来的 &lt;code&gt;cursor&lt;/code&gt;，这个类有很多方法对应着 &lt;code&gt;Cursor&lt;/code&gt; 类的方法，另外又扩展了一些属性和方法。&lt;/p&gt;

&lt;p&gt;对 &lt;code&gt;ResultProxy&lt;/code&gt; 对象进行遍历时，得到的每一行都是一个 &lt;code&gt;RowProxy&lt;/code&gt; 对象，获取字段的方法非常灵活，索引、字段名，甚至属性都行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;row_proxy[0] == row_proxy[&#39;id&#39;] == row_proxy.id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看得出来，&lt;code&gt;RowProxy&lt;/code&gt; 跟Java的 POJO 类有相似的特性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import create_engine

db = create_engine(&#39;sqlite:///:memory:&#39;, echo=True)

# DDL
db.execute(&#39;create table users(userid char(10), username char(50))&#39;)

# DML
result = db.execute(
    &amp;quot;insert into users (userid, username) values (&#39;user1&#39;, &#39;tony&#39;)&amp;quot;)
# get rows affected by an UPDATE or DELETE statement,
# it is not intended to provide the number of rows present from SELECT
result.rowcount
# True if this ResultProxy returns rows.
result.returns_rows

# Query
result = db.execute(&amp;quot;select * from users&amp;quot;)
result.scalar()  # 可以返回一个标量查询的值
result.fetchall()   # 取回所有的行
result.fetchmany()  # 取回多行
result.fetchone()   # 取回一行，并判断有且只有一行，若超出一行则报错
result.first()      # 取回第一行
result.close()  # result 用完之后，需要关闭
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLAlchemy 支持事务，甚至可以嵌套事务。&lt;/p&gt;

&lt;p&gt;缺省情况下事务自动提交，即执行一条SQL就自动提交。&lt;/p&gt;

&lt;p&gt;如果要更精准的控制事务，最简单的方法是使用 &lt;code&gt;connection&lt;/code&gt;，然后通过 &lt;code&gt;connection&lt;/code&gt; 获取 &lt;code&gt;transaction&lt;/code&gt; 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# transaction
connection = db.connect()
trans = connection.begin()
try:
    do_something_with(connection)
    trans.commit()
except:
    trans.rollback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方式是在创建 &lt;code&gt;engine&lt;/code&gt; 对象时指定 &lt;code&gt;strategy=&#39;threadlocal&#39;&lt;/code&gt; 参数，这样会自动创建一个线程局部的连接，对于后续的无连接的执行都会自动使用这个连接，这样在处理事务时，只要使用 &lt;code&gt;engine&lt;/code&gt; 对象来操作事务就行了。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;db = create_engine(connection, strategy=&#39;threadlocal&#39;)
db.begin()
try:
    do_something()
except:
    db.rollback()
else:
    db.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果希望手动提交事务，也可以在 &lt;code&gt;connection&lt;/code&gt; 和 &lt;code&gt;statement&lt;/code&gt; 上通过 &lt;code&gt;execute_options()&lt;/code&gt; 方法修改为手动提交模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conn.execute_options(autocommit=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置为手动提交模式后，要提交事务，需要调用 &lt;code&gt;conn.commit()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h2 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 默认的连接池算法选用规则为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接内存中的 SQLite，默认的连接池算法为 &lt;code&gt;SingletonThreadPool&lt;/code&gt; 类，即两个线程允许一个连接；&lt;/li&gt;
&lt;li&gt;连接基于文件的 SQLite，默认的i连接池算法为 &lt;code&gt;NullPool&lt;/code&gt; 类，即不使用连接池；&lt;/li&gt;
&lt;li&gt;对于其他情况，默认的连接池算法为 &lt;code&gt;QueuePool&lt;/code&gt; 类。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们也可以实现自己的连接池算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db = create_engine(&#39;sqlite:///file.db&#39;, poolclass=YourPoolClass)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;create_engine()&lt;/code&gt; 函数和连接池相关的参数有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pool_recycle: 默认为-1，推荐设置为7200，即如果 &lt;code&gt;connection&lt;/code&gt; 空闲了 7200秒 = 2小时，自动重新获取，以防止 &lt;code&gt;connection&lt;/code&gt; 被数据库服务器关闭；&lt;/li&gt;
&lt;li&gt;pool_size: 保持连接数，默认为5，正式环境下该数值偏小，需根据实际情况调整；&lt;/li&gt;
&lt;li&gt;max_overflow: 超出 &lt;code&gt;pool_size&lt;/code&gt; 后允许的最大连接数，默认为10，这10个连接在使用过后，不放在连接池中，而是被真正关闭的。&lt;/li&gt;
&lt;li&gt;pool_timeout: 获取连接的超时阀值，默认为30秒。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;国内的云服务平台 &lt;a href=&#34;http://sae.sina.com.cn&#34;&gt;SAE&lt;/a&gt; 中的共享型 MySQL 服务不支持连接池，如果在其上部署应用，需要禁用连接池，也就是使用 &lt;code&gt;NullPool&lt;/code&gt; 类，否则会报 &amp;lsquo;(2006, MySQL server has gone away)&amp;rsquo; 错误。&lt;/p&gt;

&lt;h2 id=&#34;日志输出&#34;&gt;日志输出&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 默认输出日志到 &lt;code&gt;sys.stdout&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果要输出到文件，log 文件不具备 rotate 功能，不推荐在生产环境中使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import logging
logging.getLogger(&#39;sqlalchemy.engine&#39;).setLevel(logging.INFO)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;create_engine()&lt;/code&gt; 函数时，可选传递一个参数 &lt;code&gt;echo=True&lt;/code&gt; 来打开详细信息输出，这个功能信息量非常大，只适合调试使用，不建议生产环境中使用。&lt;/p&gt;

&lt;h2 id=&#34;最佳实践与使用心得&#34;&gt;最佳实践与使用心得&lt;/h2&gt;

&lt;p&gt;使用 ORM 方式构建复杂查询比较困难，使用 Raw SQL 和 SQL Expression 会比较合适一些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;declarative&lt;/code&gt; 是 SQLAlchemy 的一个新的扩展功能 ，只能用在 ORM 方式中，不适用在 Raw SQL 和 SQL Expression 方式。&lt;/p&gt;

&lt;p&gt;如果使用 ORM 方式，表必须有主键，使用 Raw SQL 和 SQL Express 方式没有这个约束。&lt;/p&gt;

&lt;p&gt;查询有简单的也有复杂的，使用 Raw SQL 会比较方便。&lt;/p&gt;

&lt;p&gt;增、删、改，多是单表操作，使用 SQL Expression 就足够了。具体讲，比如一个 &lt;code&gt;User&lt;/code&gt; 类，&lt;strong&gt;可以包含一个固定的 &lt;code&gt;_table&lt;/code&gt; 成员&lt;/strong&gt;，增删改直接使用 &lt;code&gt;_table&lt;/code&gt; 对象来完成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_table = Table(&#39;users&#39;, metadata, autoload=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;批量的 insert/update/delete 操作，可以将每行数据组成一个 dict，在将这些 dict 组成一个 list，和 _table.insert()/update()/delete() 一起作为参数传给 `conn.execute()&amp;lsquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import Table

# _table member object
_table = Table(&#39;users&#39;, metadata, autoload=True)
# insert
_table.insert().values(f1=value1, f2=value2)
# update
_table.update().values(f1=new_value1, f2=new_value2).where(
    _table.c.f1 == value1).where(_table.c.f2 == value2)
# delete
_table.delete().where(_table.c.f1 == value1).where(
    _table.c.f2 == value2)

# batch opration
conn.execute(_table.insert(), [
        {&#39;user_id&#39;: 1, &#39;email_address&#39;: &#39;jack@yahoo.com&#39;},
        {&#39;user_id&#39;: 1, &#39;email_address&#39;: &#39;jack@msn.com&#39;},
        {&#39;user_id&#39;: 2, &#39;email_address&#39;: &#39;susan@example.com&#39;},
        {&#39;user_id&#39;: 2, &#39;email_address&#39;: &#39;susan@example.org&#39;}
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL Expression 也可以像 Raw SQL 的 &lt;code&gt;text()&lt;/code&gt; 函数一样使用 &lt;code&gt;bindparam&lt;/code&gt;，方法是在调用 insert()/update()/delete() 时声明参数，然后在 &lt;code&gt;conn.execute()&lt;/code&gt; 执行时候，将参数传递进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = _table.delete().where(_table.c.hire_date &amp;lt;= bindparam(
    &#39;hire_day&#39;, DateTime(), required=True))
conn.execute(d, {&#39;hire_day&#39;: datetime.today()})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;where()&lt;/code&gt; 和 ORM 中的 &lt;code&gt;filter()&lt;/code&gt; 接受一样的参数，各种SQL条件都支持：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# equals, not equals
where(_table.c.name == &#39;ed&#39;)
where(_table.c.name != &#39;ed&#39;)
# like
where(_table.c.name.like(&#39;%ed%&#39;))
# in, not in
where(_table.c.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))
where(~_table.c.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))
# is null, is not null
where(_table.c.name == None)
where(_table.c.name != None)

# and, or
from sqlalchemy import and_, or_
where(and_(_table.c.name == &#39;ed&#39;, _table.c.fullname == &#39;Ed Jones&#39;))
where(or_(_table.c.name == &#39;ed&#39;, _table.c.name == &#39;wendy&#39;))
# and can also be written with multiple where clause
where(_table.c.name == &#39;ed&#39;).where(_table.c.fullname == &#39;Ed Jones&#39;)

# match: contents of the match parameter are database backend specific
where(_table.c.name.match(&#39;wendy&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fn-copyright&#34;&gt;出处已不可考，如有侵权请联系我。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fn-copyright&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>