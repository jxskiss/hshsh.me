<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.31-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> hshsh&#39;s little site &middot; hshsh&#39;s little site </title>

  
  <link rel="stylesheet" href="http://hshsh.me/css/poole.css">
  <link rel="stylesheet" href="http://hshsh.me/css/syntax.css">
  <link rel="stylesheet" href="http://hshsh.me/css/hyde.css">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/default.min.css">
  <link rel="stylesheet" href="http://hshsh.me/css/style.css">

  
  <script type="text/javascript" src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="http://hshsh.me/index.xml" rel="alternate" type="application/rss+xml" title="hshsh&#39;s little site" />
</head>

<body class=" ">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://hshsh.me/"><h1>hshsh&#39;s little site</h1></a>
      <p class="lead">
       假行僧 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      <li><a href="/post/"><span class="navlink">Blog</span></a></li>
      <li><a href="https://github.com/jxskiss/">@Github</a></li>
    </ul>

    <p>&copy; 2014 - 2017<br>All rights reserved. </p>
  </div>
</div>


<div class="content container">
<div class="posts">

  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hshsh.me/post/2017-10-29-openresty-dynamic-upstreams/">
        用OpenResty构建动态代理服务
      </a>
    </h1>

    <span class="post-date">Sun, Oct 29, 2017</span>

    <p>最近的项目使用了前后端分离的开发模式，前后端都在同一台机器上开发，需要对前后端开发配置联调服务。解决这个问题方法很多，Nginx/OpenResty 是其中一种。</p>

<p>后来又有其他项目的前端后端同学也在这台服务器上做开发。</p>

<p>后来，这台服务器绑定了多个域名，要对多个域名、多个端口做解析。</p>

<p>再后来，其中一个项目的后端开始以微服务的方式开发，对不同路径要代理到不同的后端开发端口上去。</p>

<p>既然已经走了这么远，索性再扩展一下，除了支持代理到端口，再加上指定文件夹静态文件服务呗，于是有了下面的配置。</p>

<p>功能列表：</p>

<ol>
<li>一个端口支持多域名，访问不同域名可以转发到不同上游服务</li>
<li>一个域名下，可以按照项目分组，不同项目可以配置不同后端服务</li>
<li>一个项目可以根据路由配置多个对应后端服务</li>
<li>支持不带后端路由的直接转发</li>
<li>支持指定文件夹静态文件服务</li>
<li>上述一切都可以通过接口在线配置，不需要修改 Nginx/OpenResty 配置文件，并且自带接口文档</li>
</ol>

<p>依赖：OpenResty，安装请参考<a href="https://openresty.org/cn/installation.html">官方文档</a>。</p>

<pre><code class="language-conf"># #### OpenResty dynamic upstreams ####

# 配置表，key 有三种格式
#   1. example.domain.name:port_number
#      value 有三种格式：
#      - upstream_ip:port
#      - upstream_ip:port,project
#      - /absolute/path/to/document/root
#   2. example.domain.name:project_name
#      value JSON格式的路由表
#   2. kv:runtime_variable_name
#      value 所有请求共享的运行时变量
lua_shared_dict dyn_registry 1m;

server {
    # 把要开发的端口全部注册在这里，一行一个，比如 9000 - 9009
    listen       9000;
    listen       9001;
    # listen     ...
    listen       9008;
    listen       9009;

    # 接受请求的域名，全部写在一行，用空格分开
    # 上面注册的端口对所有域名都可用
    server_name  dyn1.hshsh.me dyn2.hshsh.me;

    access_log   /path/to/access_or_dynamic.log main;
    error_log    /path/to/error_or_dynamic.log notice;

    default_type  application/json;

    set $dyn_conf_file &quot;/path/to/or-dynamic.json&quot;;

    # 无论是配置请求，还是代理请求，第一个请求都需要触发配置加载，
    # 因此这两个 set 指令不能放在 location 里面，必须放在 server 中
    set $upstream &quot;&quot;;
    set_by_lua_block $docroot {
        local cjson = require &quot;cjson&quot;
        local registry = ngx.shared.dyn_registry

        -- 配置成请求触发加载可以不用写全局的 init_by_lua* 指令，
        -- 方便与其他 OpenResty 服务集成
        if not registry:get(&quot;kv:loaded&quot;) then
            local file, err = io.open(ngx.var.dyn_conf_file, &quot;rb&quot;)
            if not file then
                ngx.log(ngx.ERR, &quot;error opening config file: &quot;, err)
            else
                local contents = file:read(&quot;*all&quot;)
                file:close()
                local suc, config = pcall(cjson.decode, contents)
                if not suc then
                    ngx.log(ngx.ERR, &quot;error decoding config file&quot;)
                else
                    for k, v in pairs(config) do
                        -- 第一种 key, domain:port
                        if k:match(&quot;:%d+$&quot;) then
                            registry:set(k, v)
                        -- 第二种 key, domain:project
                        else
                            registry:set(k, cjson.encode(v))
                        end
                    end
                end
            end
            registry:set(&quot;kv:loaded&quot;, &quot;true&quot;)
        end

        -- 对于配置请求不需要查配置，配置接口可以在所有域名和端口上访问
        if ngx.re.match(ngx.var.uri, &quot;^/or-dynamic/&quot;) then
            return &quot;&quot;
        end

        -- 根据域名和端口查配置，如果查不到则是没有注册，直接返回
        -- 在 / location 中会返回 404，set 指令中不能结束请求
        local http_host = ngx.var.http_host
        local upstream = registry:get(http_host)
        if not upstream then
            return &quot;&quot;
        end

        -- upstream_ip:port, 项目无关，没有后端路由的直接代理
        if upstream:match(&quot;:%d+$&quot;) then
            ngx.var.upstream = upstream
            return &quot;&quot;
        end

        -- 没有逗号，文档根目录路径，所以不支持配置带有都好的路径
        if not upstream:match(&quot;,&quot;) then
            return upstream
        end

        -- upstream_ip:port,project, 项目前端配置
        -- 根据路由表确定是否需要转发后端服务
        local proj, routes, uri, dest, m, err
        m, err = ngx.re.match(upstream, [=[([^,]+),([^,]+)]=])
        upstream, proj = m[1], m[2]
        routes = cjson.decode(registry:get(ngx.var.host .. &quot;:&quot; .. proj))
        for uri, dest in pairs(routes) do
            if dest and ngx.re.match(ngx.var.uri, uri) then
                upstream = dest
                break
            end
        end
        ngx.var.upstream = upstream
        return &quot;&quot;
    }

    # 方便开发调试，给每个请求加上 upstream 和 docroot 的响应头
    header_filter_by_lua_block {
        ngx.header[&quot;OR-Dyn-Upstream&quot;] = ngx.var.upstream
        ngx.header[&quot;OR-Dyn-Docroot&quot;] = ngx.var.docroot
    }

    location / {
        proxy_set_header Host $Host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $remote_addr;

        # upstream 需要在处理 docroot 之前处理, if is evil
        if ($upstream != &quot;&quot;) {
            proxy_pass http://$upstream;
            break;
        }

        # upstream 没有命中，docroot 也没有命中，则没有注册，可以洗洗睡了
        if ($docroot = &quot;&quot;) {
            return 404;
        }

        root $docroot;
        index index.html index.htm;

        # 对于静态文件服务，如果需要支持 history 模式路由的前端单页面应用，取消注释下面这一行
        # try_files $uri $uri/ /index.html =404;

        error_page   500 502 503 504  @5xx;
    }

    # 方便开发调试，把抛 5xx 错误的 upstream 直接显示在页面上
    location @5xx {
        default_type text/plain;
        content_by_lua_block {
            ngx.say(&quot;oops: &quot; .. ngx.var.upstream)
        }
    }

    # 当前配置查询接口
    location = /or-dynamic/ {
        content_by_lua_block {
            local cjson = require &quot;cjson&quot;
            local registry = ngx.shared.dyn_registry
            
            -- 自包含的接口文档
            local config = {
                help = {
                    [ &quot;parameters&quot; ] = {
                        host = &quot;域名, eg: example.domain.name&quot;,
                        port = &quot;端口号, eg: 9001&quot;,
                        upstream = &quot;上游服务, eg: 127.0.0.1:6666&quot;,
                        docroot = &quot;静态文件根目录, eg: /absolute/path/to/document/root&quot;,
                        uri = &quot;后端服务路由，支持正则表达式, eg: ^/api/v\d+/&quot;
                    },
                    -- 配置项目无关的直接代理
                    [ &quot;direct proxy&quot; ] = {
                        set = &quot;/or-dynamic/set?host=&amp;port=&amp;upstream=&quot;,
                        del = &quot;/or-dynamic/del?host=&amp;port=&quot;
                    },
                    -- 配置静态文件服务根目录
                    [ &quot;document root&quot; ] = {
                        set = &quot;/or-dynamic/set?host=&amp;port=&amp;docroot=&quot;,
                        del = &quot;/or-dynamic/del?host=&amp;port=&quot;
                    },
                    -- 配置项目前端代理
                    [ &quot;project frontend&quot; ] = {
                        set = &quot;/or-dynamic/set?host=&amp;proj=&amp;port=&amp;upstream=&quot;,
                        del = &quot;/or-dynamic/del?host=&amp;port=&quot;
                    },
                    -- 配置项目后端路由
                    [ &quot;project backend&quot; ] = {
                        set = &quot;/or-dynamic/set?host=&amp;proj=&amp;uri=&amp;upstream=&quot;,
                        del = &quot;/or-dynamic/del?host=&amp;proj=&amp;uri=&quot;
                    }
                }
            }

            # 按照域名和项目分组
            for _, k in ipairs(registry:get_keys()) do
                if not k:match(&quot;^kv:&quot;) then
                    local v = registry:get(k)
                    local req_type, host, proj, port, upstream, docroot, routes, m, err
                    m, err = ngx.re.match(k, [=[^([^:]+):(\d+)$]=])
                    if m then  -- host:port
                        host, port = m[1], m[2]
                        if v:match(&quot;:%d+$&quot;) then  -- direct proxy
                            req_type = &quot;proxy&quot;
                            upstream = v
                        elseif not v:match(&quot;,&quot;) then  -- document root
                            req_type = &quot;docroot&quot;
                            docroot = v
                        else  -- project frontend
                            req_type = &quot;frontend&quot;
                            m, err = ngx.re.match(v, [=[^([^,]+),([^,]+)$]=])
                            upstream, proj = m[1], m[2]
                        end
                    else  -- project backend routes
                        req_type = &quot;backend&quot;
                        m, err = ngx.re.match(k, [=[([^:]+):([^:]+)]=])
                        host, proj = m[1], m[2]
                    end

                    if not config[host] then
                        config[host] = {}
                    end
                    if req_type == &quot;docroot&quot; then
                        config[host][port] = docroot
                    elseif req_type == &quot;proxy&quot; then
                        config[host][port] = upstream
                    else  -- project frontend or backend
                        if not config[host][proj] then
                            config[host][proj] = {}
                        end
                        if req_type == &quot;frontend&quot; then
                            config[host][proj][port] = upstream
                        else
                            config[host][proj][&quot;routes&quot;] = cjson.decode(v)
                        end
                    end
                end
            end
            ngx.say(cjson.encode(config))
        }
    }

    # 新增、修改配置接口
    location = /or-dynamic/set {
        content_by_lua_block {
            local cjson = require &quot;cjson&quot;
            local registry = ngx.shared.dyn_registry
            local args = ngx.req.get_uri_args()
            local is_valid = true
            local req_type, r_key, r_value, err

            -- host is required for requests of any type
            if not args or not args.host or args.host:len() == 0 then
                is_valid = false
                err = &quot;parameter host required&quot;
            end

            -- project frontend: host, proj, port, upstream
            -- project backend: host, proj, uri, upstream
            -- direct proxy: host, port, upstream
            -- document root: host, port, docroot
            if is_valid and (not req_type) and args.port and args.port:len() &gt; 0 then
                r_key = args.host .. &quot;:&quot; .. args.port
                if args.upstream and args.upstream:len() &gt; 0 then
                    if args.proj and args.proj:len() &gt; 0 then
                        req_type = &quot;frontend&quot;
                        r_value = args.upstream .. &quot;,&quot; .. args.proj
                    else
                        req_type = &quot;proxy&quot;
                        r_value = args.upstream
                    end
                elseif args.docroot and args.docroot:len() &gt; 0 then
                    req_type = &quot;docroot&quot;
                    r_value = args.docroot
                end
            end
            if is_valid and (not req_type) and args.uri and args.uri:len() &gt; 0 and
                    args.upstream and args.upstream:len() &gt; 0 and
                    args.proj and args.proj:len() &gt; 0 then
                req_type = &quot;backend&quot;
                r_key = args.host .. &quot;:&quot; .. args.proj
                local routes = cjson.decode(registry:get(routes_key) or &quot;{}&quot;)
                routes[args.uri] = args.upstream
                r_value = cjson.encode(routes)
            end

            if req_type then
                registry:set(r_key, r_value)
                local res = ngx.location.capture(&quot;/or-dynamic/_save&quot;)
                if res.status ~= ngx.HTTP_OK then
                    err = &quot;failed writing config file&quot;
                else
                    ngx.redirect(&quot;/or-dynamic/&quot;)
                end
            end
            ngx.say(cjson.encode({error = err or &quot;invalid or missing parameters&quot;}))
        }
    }

    # 删除配置接口
    location = /or-dynamic/del {
        content_by_lua_block {
            local cjson = require &quot;cjson&quot;
            local args = ngx.req.get_uri_args()
            if (not args or not args.host or args.host:len() == 0 or
                    ((not args.port or args.port:len() == 0) and
                     (not args.proj or args.proj.len() == 0 or
                      not args.uri or args.uri:len() == 0))
                ) then
                ngx.say(cjson.encode({error = &quot;missing parameters&quot;}))
                return
            end

            local registry = ngx.shared.dyn_registry
            if args.port and args.port:len() &gt; 0 then
                registry:delete(args.host .. &quot;:&quot; .. args.port)
            else
                local routes_key = args.host .. &quot;:&quot; .. args.proj
                local routes = cjson.decode(registry:get(routes_key) or &quot;{}&quot;)
                local new = {}
                for uri, dest in pairs(routes) do
                    if dest and uri ~= args.uri then
                        new[uri] = dest
                    end
                end
                registry:set(routes_key, cjson.encode(new))
            end

            local res = ngx.location.capture(&quot;/or-dynamic/_save&quot;)
            if res.status ~= ngx.HTTP_OK then
                ngx.say(cjson.encode({error = &quot;failed writing config file&quot;}))
            else
                ngx.redirect(&quot;/or-dynamic/&quot;)
            end
        }
    }

    # 保存当前配置表到配置文件
    # internal 类型的 location 专门用于内部请求逻辑，外部访问不到
    location = /or-dynamic/_save {
        internal;
        content_by_lua_block {
            local cjson = require &quot;cjson&quot;
            local registry = ngx.shared.dyn_registry
            local config = {}

            for _, k in ipairs(registry:get_keys()) do
                -- 不保存运行时变量，只保存配置内容
                if not k:match(&quot;^kv:&quot;) then
                    local v = registry:get(k)
                    if ngx.re.match(k, [=[\:\d+$]=]) then  -- host:port
                        config[k] = v
                    else
                        config[k] = cjson.decode(v)
                    end
                end
            end

            -- assume we don't need lock to access config file
            local file, err = io.open(ngx.var.dyn_conf_file, &quot;w&quot;)
            if file then
                file:write(cjson.encode(config))
                file:close()
                ngx.print(&quot;ok&quot;)
            else
                ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                ngx.log(ngx.ERR, &quot;failed to save config: &quot;, err)
                ngx.say(err)
            end
        }
    }

}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hshsh.me/post/2017-10-28-build-static-openresty/">
        静态编译OpenResty
      </a>
    </h1>

    <span class="post-date">Sat, Oct 28, 2017</span>

    <p>有时候会需要静态编译OpenResty。</p>

<p>参考资料：<a href="http://www.codingblog.cn/blog/9579.html">http://www.codingblog.cn/blog/9579.html</a>。</p>

<p>当前使用的编译脚本。Ubuntu 16.04 测试通过，需要 <code>build-essential</code> 包，使用 <code>sudo apt-get install build-essential</code> 安装。</p>

<pre><code class="language-bash">#!/bin/bash

set -e

OPENRESTY_VER=1.11.2.5
LUAJIT_BUNDLE_VER=&quot;2.1-20170808&quot;
wget https://openresty.org/download/openresty-${OPENRESTY_VER}.tar.gz
tar -xzf openresty-${OPENRESTY_VER}.tar.gz

cd openresty-${OPENRESTY_VER}

cd bundle/LuaJIT-${LUAJIT_BUNDLE_VER}

make -j8
make install PREFIX=`pwd`
LUAROOT=`pwd`
rm -rf lib/*.so*
cd ../..

mkdir -p extra-libs
cd extra-libs

PCRE_VER=8.39
rm -rf pcre-*
echo -n &quot;downloading pcre-$PCRE_VER...&quot;
wget -O pcre-$PCRE_VER.tar.bz2 &quot;http://downloads.sourceforge.net/project/pcre/pcre/$PCRE_VER/pcre-$PCRE_VER.tar.bz2&quot;
echo &quot;ok&quot;
tar -xjf pcre-$PCRE_VER.tar.bz2


wget -O pcre-8.39.tar.bz2 &quot;http://downloads.sourceforge.net/project/pcre/pcre/8.39/pcre-8.39.tar.bz2

ZLIB_VER=1.2.11
echo -n &quot;downloading zlib-$ZLIB_VER...&quot;
wget -O zlib-$ZLIB_VER.tar.gz http://zlib.net/zlib-$ZLIB_VER.tar.gz
echo &quot;ok&quot;
tar -xzf zlib-$ZLIB_VER.tar.gz

rm -rf openssl-*
rm -rf OpenSSL_1_0_1t*
echo -n &quot;downloading OpenSSL_1_0_1t...&quot;
wget https://github.com/openssl/openssl/archive/OpenSSL_1_0_1t.tar.gz
echo &quot;ok&quot;
tar -xzf OpenSSL_1_0_1t.tar.gz

cd ..

OPENRESTY_PREFIX=/opt/openresty
NGINX_TEMP_PREFIX=$OPENRESTY_PREFIX/temp
./configure -j8 \
    --prefix=$OPENRESTY_PREFIX \
    --http-client-body-temp-path=$NGINX_TEMP_PREFIX/client_body \
    --http-proxy-temp-path=$NGINX_TEMP_PREFIX/proxy \
    --http-fastcgi-temp-path=$NGINX_TEMP_PREFIX/fastcgi \
    --http-uwsgi-temp-path=$NGINX_TEMP_PREFIX/uwsgi \
    --http-scgi-temp-path=$NGINX_TEMP_PREFIX/scgi \
    --with-luajit=$LUAROOT \
    --with-http_ssl_module \
    --with-http_realip_module \
    --with-http_addition_module \
    --with-http_sub_module \
    --with-http_dav_module \
    --with-http_flv_module \
    --with-http_mp4_module \
    --with-http_gunzip_module \
    --with-http_gzip_static_module \
    --with-http_auth_request_module \
    --with-http_random_index_module \
    --with-http_secure_link_module \
    --with-http_slice_module \
    --with-http_stub_status_module \
    --with-http_v2_module \
    --with-mail \
    --with-mail_ssl_module \
    --with-stream \
    --with-stream_ssl_module \
    --with-ipv6 \
    --with-pcre-jit \
    --with-pcre=./extra-libs/pcre-$PCRE_VER \
    --with-zlib=./extra-libs/zlib-$ZLIB_VER \
    --with-openssl=./extra-libs/openssl-OpenSSL_1_0_1t

make -j8

cp build/nginx-1.11.2/objs/nginx ./openresty
# make install
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hshsh.me/post/2017-10-22-single-file-vue-webpack/">
        单文件 Vue Webpack 配置
      </a>
    </h1>

    <span class="post-date">Sun, Oct 22, 2017</span>

    

<p>在今年的工作中接触到了前端框架 Vue.js 和构建工具 Webpack。虽然没写了几行前端界面代码，
不过对 Webpack 配置倒是花了一些时间学习，整理了一个针对 Vue.js 的单文件 Webpack 配置。
本文通过对配置文件的注释解析分享 Webpack 配置的一些要点。</p>

<p>本文中配置已经整理为一个糅合了 Django、Tornado、Vue.js、Webpack 的 <a href="https://github.com/jxskiss/nice-pyvue-template">Django 项目模板</a>，主要作为学习记录用途。不过在 Django、Tornado 和 Webpack
的工程配置方面都有一些巧妙地处理，作为前后端分离的工程项目模板也是一个很好的开始（我就是这么用的）。欢迎 Star。</p>

<h2 id="配置目标">配置目标</h2>

<ol>
<li>版本：Vue 2.0+、Webpack 2.0+</li>
<li>支持单页面应用和多页面应用</li>
<li>多页面应用，每个应用入口可选指定自己的HTML模板</li>
<li>多页面应用，可以通过环境变量或命令行选项支持构建指定页面</li>
<li>支持本地 devServer，可指定运行端口，指定开发页面</li>
<li>支持 TypeScript，<code>.ts</code> 文件和 Vue.js 单文件组件</li>
</ol>

<h2 id="项目说明">项目说明</h2>

<h3 id="目录结构">目录结构</h3>

<p>该配置是结合后端 Django 开发做的，因此前端文件放在 <code>frontend</code> 子目录中，
同时为了方便使用 <code>apidocjs</code> 编译API文档，<code>package.json</code>、<code>tsconfig.json</code>、
<code>webpack.config.js</code> 等前端配置文件放在项目根目录下。</p>

<p>对 Django 有所了解的同学，看到 <code>apps/</code> 子目录可能会感到奇怪，这里通过修改 <code>manage.py</code> 文件对
<code>startapp</code> 命令打了一个补丁，把所有新建 app 都放置在 <code>apps/</code> 子目录中以维持目录结构清晰。</p>

<pre><code class="language-text">├── frontend/
│   ├── dist/  # 打包发布目录
│   ├── src/
│   │   ├── assets/  # 静态资源
│   │   │   ├── css/
│   │   │   └── images/
│   │   ├── components/  # 页面组件
│   │   │   └── Hello.vue
│   │   ├── pages/  # 页面代码
│   │   │   ├── demoapp/
│   │   │   │   ├── App.vue
│   │   │   │   ├── index.html  # 应用 HTML 模板文件
│   │   │   │   └── index.js
│   │   │   ├── App.vue
│   │   │   ├── index.html  # 缺省 HTML 模板文件
│   │   │   └── index.ts
│   │   ├── plugins/  # 封装插件
│   │   └── utils/  # 通用 Util 代码
│   └── static  # 发布时需要拷贝到 dist 目录的静态文件
├── node_modules/
├── package.json
├── tsconfig.json  # TypeScript 配置
├── webpack.config.js  # Webpack 单文件配置
├── manage.py
├── apps/  # 后端 Django 应用代码
│   ├── app1/
│   └── app2/
└── project_name/  # 后端 Django 项目配置
</code></pre>

<h3 id="npm包依赖">NPM包依赖</h3>

<ol>
<li>Vue.js 2.5+，Vue 2.5 开始改善了和 TypeScript 的集成应用</li>
<li>TypeScript 2.5+，理由同上</li>
</ol>

<h2 id="配置解析">配置解析</h2>

<pre><code class="language-javascript">/* 
 * 配置文件用到的外部工具
 */
const fs = require('fs')
const glob = require('glob')
const path = require('path')
const webpack = require('webpack')
const ExtractTextPlugin = require('extract-text-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const CopyWebpackPlugin = require('copy-webpack-plugin')
const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')
const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')

/*
 * 配置选项，对应 vue-cli webpack 工程的 config 目录
 * 1. common 是开发和生产环境公用配置
 * 2. build 是生产配置，dev 是开发配置，当重名时，build 和 dev 覆盖 common 配置
 * 3. extraPlugins 针对生产和开发环境配置单独启用的 webpack 插件
 * 4. outputFilename 针对生产和开发环境配置输出文件命名规则
 * 5. get 工具函数针对 NODE_ENV 环境变量从 build 或者 dev 中查询配置，
 *    如果找不到，则从 common 中查询配置
 * 6. 与 vue-cli webpack 工程不同，这里不使用 *.env.js 配置环境变量，
 *    而是在 module.exports 中通过命令行环境变量或命令行选项设置环境变量，
 *    因此把配置写成一个函数确保拿到正确的环境变量 process.env.VAR
 */
function makeBuildConfigs (options) {
  return {
    // build or dev settings take priority over common settings
    // see the &quot;get&quot; method for details
    common: {
      assetsRoot: path.resolve(__dirname, './frontend/dist'),
      assetsSubDirectory: 'static',
      assetsPublicPath: '/'
    },
    build: {
      cssMinimize: true,
      cssSourceMap: true,
      cssExtract: true,
      // 生产环境启用对调试工具友好的 #source-map，设置为 false 禁用 source-map
      devtool: '#source-map',
      // Gzip off by default as many popular static hosts already gzip
      // all static assets for you. Before setting to true, make sure to:
      // `npm install --save-dev compression-webpack-plugin`
      productionGzip: false,
      productionGzipExtensions: ['js', 'css'],
      // 生产环境单独启用的插件
      extraPlugins: [
        // 压缩JS文件
        new webpack.optimize.UglifyJsPlugin({
          compress: {warnings: false},
          sourceMap: true
        }),
        // 合并压缩提取出的CSS文件
        new OptimizeCSSPlugin({cssProcessorOptions: {safe: true}})
      ],
      outputFilename: (ext) =&gt; ext === 'ext'
        ? `[name].[chunkhash:8].[ext]` : `[name].[chunkhash:8].${ext}`
    },
    dev: {
      cssMinimize: false,
      cssSourceMap: false,
      cssExtract: true,
      // 开发环境使用常规的 #cheap-modulel-eval-source-map，编译速度较快
      devtool: '#cheap-module-eval-source-map',
      // 使用环境变量指定的开发服务端口，默认 8080
      port: process.env.PORT || 8080,
      // 如果有需要，可以配置后端API代理
      // https://webpack.github.io/docs/webpack-dev-server.html#proxy
      proxy: {},
      // 开发环境单独启用的插件
      extraPlugins: [
        // 自动重载开发页面
        new webpack.HotModuleReplacementPlugin(),
        new webpack.NoEmitOnErrorsPlugin(),
        new FriendlyErrorsPlugin()
      ],
      // 开发环境编译输出文件不加 hash
      outputFilename: (ext) =&gt; ext === 'ext' ? `[name].[ext]` : `[name].${ext}`
    },
    // _path: 如果配置有嵌套，使用以 &quot;.&quot; 分割的对象路径
    get: function (_path, options = {}) {
      let config = process.env.NODE_ENV === 'production' ? this.build : this.dev
      let properties = _path.split('.')
      let search = (root) =&gt; {
        let value = null
        for (let idx in properties) {
          let parent = value || root
          if (!parent.hasOwnProperty(properties[idx])) {
            break
          } else {
            value = parent[properties[idx]]
          }
        }
        return value
      }
      let value = search(config)
      if (value === null) value = search(this.common)
      return value
    }
  }
}

/*
 * 从 vue-cli webpack 工程中抄来的 style loaders 配置
 */
function cssLoaders (options) {
  options = options || {}

  let cssLoader = {
    loader: 'css-loader',
    options: {
      minimize: options.minimize,
      sourceMap: options.sourceMap
    }
  }

  // generate loader string to be used with extract text plugin
  function generateLoaders (loader, loaderOptions) {
    let loaders = [cssLoader]
    if (loader) {
      loaders.push({
        loader: loader + '-loader',
        options: Object.assign({}, loaderOptions, {
          sourceMap: options.sourceMap
        })
      })
    }

    // Extract CSS when that option is specified
    // (which is the case during production build)
    if (options.extract) {
      return ExtractTextPlugin.extract({
        use: loaders,
        fallback: 'vue-style-loader'
      })
    } else {
      return ['vue-style-loader'].concat(loaders)
    }
  }

  // http://vuejs.github.io/vue-loader/configurations/extract-css.html
  return {
    css: generateLoaders(),
    postcss: generateLoaders(),
    less: generateLoaders('less'),
    sass: generateLoaders('sass', {indentedSyntax: true}),
    scss: generateLoaders('scss'),
    stylus: generateLoaders('stylus'),
    styl: generateLoaders('stylus')
  }
}

// Generate loaders for standalone style files (outside of .vue)
function styleLoaders (options) {
  let output = []
  let loaders = cssLoaders(options)
  for (let extension in loaders) {
    let loader = loaders[extension]
    output.push({
      test: new RegExp('\\.' + extension + '$'),
      use: loader
    })
  }
  return output
}

/*
 * 获取页面列表
 * 1. 根据指定 PAGE 过滤列表，如果有指定则输出指定页面，否则输出全部页面，
 *    src/pages 目录下的根页面，使用文件 basename 过滤，子目录页面使用子目录名称过滤；
 * 2. 返回不包含 &quot;frontend/src/pages/&quot; 和文件后缀的页面列表；
 */

function getPageEntries (globPath) {
  let targetPage = process.env.PAGE
  let entries = {}, paths, basename, pathname, pageIndex
  glob.sync(globPath).forEach(entry =&gt; {
    basename = path.basename(entry, path.extname(entry))
    // node-glob uses forward-slashes only in glob expressions, even on windows
    paths = entry.split('/')
    pageIndex = paths.indexOf('pages') + 1
    if (targetPage) {  // partially build
      if (paths.length === pageIndex + 1) {  // root pages
        if (basename !== targetPage) {
          return
        }
      } else if (paths[pageIndex] !== targetPage) {
        return
      }
    }
    pathname = paths.slice(pageIndex, -1).concat([basename]).join('/')
    entries[pathname] = entry
  })
  return entries
}

// 解析前端文件路径，类似 vue-cli webpack 工程中 resolve 函数。
// 若未传入 target 参数，返回 frontend 目录路径
function resolveFrontend (target) {
  return path.join(__dirname, 'frontend', target || '')
}

// 检查是否 node_modules 模块
function isNodeModule (module) {
  return (
    module.resource &amp;&amp;
    /\.js$/.test(module.resource) &amp;&amp;
    module.resource.indexOf(
      path.join(__dirname, 'node_modules')
    ) === 0
  )
}

/*
 * Webpack 导出配置，通过使用导出函数，环境变量可以通过命令行参数传入:
 * https://webpack.js.org/api/cli/#environment-options
 */

module.exports = (options = {}) =&gt; {
  // 该配置文件不使用 *.env.js 文件，环境变量使用命令行环境变量或命令行选项传入，
  // Windows 平台不支持 &quot;VAR=value command&quot; 这样的调用方式，
  // 网上多见到使用 cross_env 解决这个问题的，个人以为使用命令行选项更简单优雅
  // --env.production
  if (typeof options.production === 'boolean' &amp;&amp; options.production) {
    process.env.NODE_ENV = 'production'
  } else {
    process.env.NODE_ENV = 'development'
  }
  if (options.port) process.env.PORT = options.port  // --env.port=PORT
  if (options.page) process.env.PAGE = options.page  // --env.page=PAGE

  // 环境变量配置完成，生成配置选项
  const buildConfigs = makeBuildConfigs(options)
  // 针对配置选项的工具函数
  const getConfig = (_path) =&gt; buildConfigs.get(_path, options)
  const assetsPath = (_path) =&gt; path.posix.join(getConfig('assetsSubDirectory'), _path)
  const outputFilename = (ext) =&gt; getConfig('outputFilename')(ext)

  // 导出内容
  let exports = {
    context: path.resolve(__dirname),
    // 获取 frontend/src/pages/ 目录下的所有 .js, .ts 入口文件列表
    entry: getPageEntries(resolveFrontend('src/pages/**/*.[jt]s')),
    output: {
      path: getConfig('assetsRoot'),
      // 输出到 $assetsPath/js/ 目录，使用配置选项中的 outputFilename 计算输出文件名
      filename: assetsPath(`js/${outputFilename('js')}`),
      publicPath: getConfig('assetsPublicPath')
    },

    resolve: {
      modules: [resolveFrontend('src'), 'node_modules'],
      // 解析所有 js/typescript/vue/json/css/scss/less 文件
      extensions: ['.js', '.ts', '.vue', '.json', '.css', '.scss', '.less'],
      // 引用别名，方便代码里引入，如：&quot;import Hello from '@/components/Hello'&quot;
      alias: {
        'vue$': 'vue/dist/vue.esm.js',
        '@': resolveFrontend('src'),
        'assets': resolveFrontend('src/assets'),
        'components': resolveFrontend('src/components'),
        'plugins': resolveFrontend('src/plugins'),
        'utils': resolveFrontend('src/utils')
      }
    },

    module: {
      rules: [
        {  // eslint
          test: /\.(js|vue)$/,
          loader: 'eslint-loader',
          enforce: 'pre',
          include: [resolveFrontend('src'), resolveFrontend('test')],
          exclude: /node_modules/,
          options: {
            formatter: require('eslint-friendly-formatter')
          }
        },
        {
          test: /\.vue$/,
          loader: 'vue-loader',
          options: {
            loaders: cssLoaders({
              minimize: getConfig('cssMinimize') || false,
              sourceMap: getConfig('cssSourceMap') || false,
              extract: getConfig('cssExtract') || false
            }),
            // 在模版编译过程中，编译器可以将某些属性，如 src 路径，转换为 require 调用，
            // 以便目标资源可以由 Webpack 处理。
            // 转为 require 调用可以增加构建的灵活性，并减少开发环境和生产环境路径配置不一致可能导致的问题
            transformToRequire: {
              video: 'src',
              source: 'src',
              img: 'src',
              image: 'xlink:href'
            }
          }
        },
        {
          // typescript
          // 注意：如果在 Vue 单文件组件中使用 typescript，entry 文件必须以 .ts 作为后缀
          test: /\.tsx?$/,
          loader: 'ts-loader',
          include: [resolveFrontend('src'), resolveFrontend('test')],
          options: {
            appendTsSuffixTo: [/\.vue$/],
            // set to false to get benefits from static type checking
            // https://www.npmjs.com/package/ts-loader#transpileonly-boolean-defaultfalse
            transpileOnly: true
          }
        },
        {
          test: /\.js$/,
          loader: 'babel-loader',
          include: [resolveFrontend('src'), resolveFrontend('test')],
          exclude: /node_modules/
        },
        {
          test: /\.json$/,
          loader: 'json-loader'
        },
        {
          test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
          loader: 'url-loader',
          options: {
            limit: 10000,
            name: assetsPath(`img/${outputFilename('ext')}`)
            // a lot of other options can be customized
          }
        },
        {
          test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
          loader: 'url-loader',
          options: {
            limit: 10000,
            name: assetsPath(`fonts/${outputFilename('ext')}`)
          }
        }
      ].concat(styleLoaders({
        minimize: getConfig('cssMinimize') || false,
        sourceMap: getConfig('cssSourceMap') || false,
        extract: getConfig('cssExtract') || false
      }))
    },

    // 可选在 HTML 文件中从CDN引入JS库，可以加入 externals 列表减小打包体积
    externals: {},

    // dev 和 build 通用的 webpack 插件
    plugins: [
      // 提取每个页面的样式表到独立的CSS文件
      new ExtractTextPlugin({
        filename: assetsPath(`css/${outputFilename('css')}`)
      }),
      // any required modules inside node_modules are extracted to vendor
      new webpack.optimize.CommonsChunkPlugin({
        name: 'vendor',
        minChunks: function (module, count) {
          return isNodeModule(module)
        }
      }),
      // extract webpack runtime and module manifest to its own file in order to
      // prevent vendor hash from being updated whenever app bundle is updated
      new webpack.optimize.CommonsChunkPlugin({
        name: 'manifest',
        chunks: ['vendor']
      }),
      // 从 frontend/static/ 目录复制文件到构建目录
      new CopyWebpackPlugin([
        {
          from: resolveFrontend('static'),
          to: getConfig('assetsSubDirectory'),
          ignore: ['.*', 'README.*']
        }
      ])
    ].concat(getConfig('extraPlugins') || []),

    devtool: getConfig('devtool') || '#cheap-module-eval-source-map',

    // development server
    devServer: {
      contentBase: resolveFrontend('dist'),
      compress: true,
      historyApiFallback: true,
      hot: true,
      port: buildConfigs.dev.port,
      proxy: buildConfigs.dev.proxy
    }
  }

  /*
   * 为每个 index/main entry 配置 HtmlWebpackPlugin
   * 1. entry 文件使用 index.js, index.ts, main.js, main.ts 为文件名
   * 2. 输出总是以 index.html 作为文件名，保持和源文件对应的目录结构，例如：
   *    src/pages/index.ts =&gt; dist/index.html
   *    src/pages/main.js =&gt; dist/index.html
   *    src/pages/demoapp/index.js =&gt; dist/demoapp/index.html
   * 3. 如果存在，则使用与 entry 文件对应的同名HTML模板文件，否则使用 src/pages/index.html
   */
  for (let pathname in getPageEntries(resolveFrontend('src/pages/**/@(index|main).[jt]s'))) {
    let conf = {
      filename: ((pn) =&gt; {
        // always use index.html as output filename for main or index entry
        if (pn === 'main') return 'index.html'
        if (pn.endsWith('/main')) return `${pn.slice(0, -5)}/index.html`
        return pn + '.html'
      })(pathname),
      template: ((pn) =&gt; {
        // use root index.html as template if page html not exists
        let htmlPath = resolveFrontend(`src/pages/${pn}.html`)
        if (fs.existsSync(htmlPath)) {
          return htmlPath
        }
        return resolveFrontend('src/pages/index.html')
      })(pathname),
      chunks: [pathname, 'vendor', 'manifest'],
      inject: true,   // inject js file
      minify: {       // minify the html file
        removeComments: true,
        collapseWhitespace: true,
        removeAttributeQuotes: true,
        // necessary to consistently work with multiple chunks via CommonsChunkPlugin
        chunksSortMode: 'dependency'
        // more options:
        // https://github.com/kangax/html-minifier#options-quick-reference
      }
    }
    exports.plugins.push(new HtmlWebpackPlugin(conf))
  }

  /*
   * 为独立HTML页面配置 HtmlWebpackPlugin
   * 1. HTML文件不以 index.html, main.html 为文件名
   * 2. 如果存在同名的 js/ts 文件，则注入HTML文件，无则省略
   */
  for (let pathname in getPageEntries(resolveFrontend('src/pages/**/!(index|main).html'))) {
    let conf = {
      filename: pathname + '.html',
      template: resolveFrontend(`src/pages/${pathname}.html`),
      chunks: [pathname, 'vendor', 'manifest'],
      inject: true,
      minify: {
        removeComments: true,
        collapseWhitespace: true,
        removeAttributeQuotes: true,
        chunksSortMode: 'dependency'
      }
    }
    exports.plugins.push(new HtmlWebpackPlugin(conf))
  }

  // 可选项，大部分生产环境的 Web server 都提供了 gzip 压缩的功能，
  // 通常不会在编译阶段执行 gzip 压缩
  if (getConfig('productionGzip')) {
    let extensions = getConfig('productionGzipExtensions')
    if (extensions &amp;&amp; extensions.length &gt; 0) {
      const CompressionWebpackPlugin = require('compression-webpack-plugin')
      let conf = {
        asset: '[path].gz[query]',
        algorithm: 'gzip',
        test: new RegExp(`\\.(${extensions.join('|')})$`),
        threshold: 10240,
        minRatio: 0.8
      }
      exports.plugins.push(new CompressionWebpackPlugin(conf))
    }
  }

  /*
   * 如果在命令行指定 --env.report 参数，则在构建结束后查看打包分析报告：
   * `npm run build -- --env.report`
   */
  if (options.report) {
    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
    exports.plugins.push(new BundleAnalyzerPlugin())
  }

  return exports
}
</code></pre>

<h3 id="配合使用的-package-json">配合使用的 package.json</h3>

<pre><code class="language-jsom">{
  &quot;name&quot;: &quot;project_name&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;The Awesome Project&quot;,
  &quot;author&quot;: &quot;&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;apidoc&quot;: &quot;apidoc -o staticfiles/apidoc -f \&quot;.*\\\\.py\&quot;&quot;,
    &quot;clean&quot;: &quot;rm -rf ./frontend/dist/*&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server -d&quot;,
    &quot;watch&quot;: &quot;webpack -d -w&quot;,
    &quot;build&quot;: &quot;npm run clean &amp;&amp; webpack -p --progress --env.production&quot;
  },
  &quot;dependencies&quot;: {
    &quot;axios&quot;: &quot;^0.16.2&quot;,
    &quot;lodash&quot;: &quot;^4.17.4&quot;,
    &quot;moment&quot;: &quot;^2.19.0&quot;,
    &quot;vue&quot;: &quot;^2.5.2&quot;,
    &quot;vue-router&quot;: &quot;^3.0.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;apidoc&quot;: &quot;^0.17.6&quot;,
    &quot;autoprefixer&quot;: &quot;^7.1.5&quot;,
    &quot;babel-core&quot;: &quot;^6.26.0&quot;,
    &quot;babel-eslint&quot;: &quot;^8.0.1&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
    &quot;babel-register&quot;: &quot;^6.22.0&quot;,
    &quot;chalk&quot;: &quot;^2.1.0&quot;,
    &quot;connect-history-api-fallback&quot;: &quot;^1.3.0&quot;,
    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
    &quot;eslint&quot;: &quot;^4.8.0&quot;,
    &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;,
    &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-html&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,
    &quot;eslint-plugin-node&quot;: &quot;^5.2.0&quot;,
    &quot;eslint-plugin-promise&quot;: &quot;^3.4.0&quot;,
    &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;,
    &quot;eventsource-polyfill&quot;: &quot;^0.9.6&quot;,
    &quot;express&quot;: &quot;^4.16.2&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.1&quot;,
    &quot;file-loader&quot;: &quot;^1.1.5&quot;,
    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;http-proxy-middleware&quot;: &quot;^0.17.4&quot;,
    &quot;opn&quot;: &quot;^5.1.0&quot;,
    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;ora&quot;: &quot;^1.2.0&quot;,
    &quot;rimraf&quot;: &quot;^2.6.0&quot;,
    &quot;semver&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.7.6&quot;,
    &quot;ts-loader&quot;: &quot;^3.0.5&quot;,
    &quot;typescript&quot;: &quot;^2.5.3&quot;,
    &quot;url-loader&quot;: &quot;^0.6.2&quot;,
    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.3&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,
    &quot;webpack&quot;: &quot;^3.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
    &quot;webpack-dev-middleware&quot;: &quot;^1.12.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,
    &quot;webpack-hot-middleware&quot;: &quot;^2.19.1&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 4.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;
  },
  &quot;browserslist&quot;: [
    &quot;&gt; 1%&quot;,
    &quot;last 2 versions&quot;,
    &quot;not ie &lt;= 8&quot;
  ],
  &quot;apidoc&quot;: {
    &quot;title&quot;: &quot;The API Documentation&quot;,
    &quot;url&quot;: &quot;http://project.example.com/api&quot;,
    &quot;sampleUrl&quot;: &quot;http://localhost:8080/api&quot;
  }
}
</code></pre>

  </div>
  
</div>
<div class="more-posts">
  <h2><a href="/post/">&gt;&gt;&gt;&gt;</a></h2>
</div>
</div>

</body>
</html>
