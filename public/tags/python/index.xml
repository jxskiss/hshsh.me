<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on hshsh&#39;s little site</title>
    <link>http://hshsh.me/tags/python/</link>
    <description>Recent content in Python on hshsh&#39;s little site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 24 Apr 2016 22:48:11 +0800</lastBuildDate>
    <atom:link href="http://hshsh.me/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[转载] 专栏：RabbitMQ从入门到精通</title>
      <link>http://hshsh.me/post/2016-04-24-rabbitmq-topic-articles/</link>
      <pubDate>Sun, 24 Apr 2016 22:48:11 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-24-rabbitmq-topic-articles/</guid>
      <description>

&lt;p&gt;最近有用到RabbitMQ，在网上搜到几篇介绍文章，除去CSDN的排版不说，文章内容还是很好的。&lt;/p&gt;

&lt;p&gt;原文网址：&lt;a href=&#34;http://blog.csdn.net/column/details/rabbitmq.html&#34;&gt;http://blog.csdn.net/column/details/rabbitmq.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是几篇文章的摘要，详情请跳转原文阅读。&lt;/p&gt;

&lt;h2 id=&#34;文章摘要&#34;&gt;文章摘要&lt;/h2&gt;

&lt;p&gt;RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-一-detailed-introduction-详细介绍-http-blog-csdn-net-anzhsoft-article-details-19563091&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19563091&#34;&gt;RabbitMQ消息队列（一）: Detailed Introduction 详细介绍&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何防止丢失？&lt;/li&gt;
&lt;li&gt;如何降低发送者和接收者的耦合度？&lt;/li&gt;
&lt;li&gt;如何让Priority高的接收者先接到数据？&lt;/li&gt;
&lt;li&gt;如何做到load balance？有效均衡接收者的负载？&lt;/li&gt;
&lt;li&gt;如何有效的将数据发送到相关的接收者？也就是说让接收者subscribe不同的数据，如何做有效的filter。&lt;/li&gt;
&lt;li&gt;如何做到可扩展，甚至将这个通信模块发到cluster上？&lt;/li&gt;
&lt;li&gt;如何保证接收者接收到了完整，正确的数据？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-二-hello-world-http-blog-csdn-net-anzhsoft-article-details-19570187&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19570187&#34;&gt;RabbitMQ消息队列（二）：“Hello, World”&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;首先复习一下上篇所学：RabbitMQ实现了AMQP定义的消息队列。它实现的功能“非常简单”：从Producer接收数据然后传递到Consumer。它能保证多并发，数据安全传递，可扩展。&lt;/p&gt;

&lt;p&gt;和任何的Hello World一样，它们都不复杂。我们将会设计两个程序，一个发送Hello world，另一个接收这个数据并且打印到屏幕。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-三-任务分发机制-http-blog-csdn-net-anzhsoft-article-details-19607841&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19607841&#34;&gt;RabbitMQ消息队列（三）：任务分发机制&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在上篇文章中，我们解决了从发送端（Producer）向接收端（Consumer）发送“Hello World”的问题。在实际的应用场景中，这是远远不够的。从本篇文章开始，我们将结合更加实际的应用场景来讲解更多的高级用法。&lt;/p&gt;

&lt;p&gt;当有Consumer需要大量的运算时，RabbitMQ Server需要一定的分发机制来balance每个Consumer的load。试想一下，对于web application来说，在一个很多的HTTP request里是没有时间来处理复杂的运算的，只能通过后台的一些工作线程来完成。接下来我们分别讲解。&lt;/p&gt;

&lt;p&gt;应用场景就是RabbitMQ Server会将queue的Message分发给不同的Consumer以处理计算密集型的任务。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-四-分发到多consumer-publish-subscribe-http-blog-csdn-net-anzhsoft-article-details-19617305&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19617305&#34;&gt;RabbitMQ消息队列（四）：分发到多Consumer（Publish/Subscribe）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这篇文章中，我们将创建一个日志系统，它包含两个部分：第一个部分是发出log（Producer），第二个部分接收到并打印（Consumer）。我们将构建两个Consumer，第一个将log写到物理磁盘上；第二个将log输出的屏幕。&lt;/p&gt;

&lt;p&gt;RabbitMQ 的Messaging Model就是Producer并不会直接发送Message到queue。实际上，Producer并不知道它发送的Message是否已经到达queue。&lt;/p&gt;

&lt;p&gt;Producer发送的Message实际上是发到了Exchange中。它的功能也很简单：从Producer接收Message，然后投递到queue中。Exchange需要知道如何处理Message，是把它放到那个queue中，还是放到多个queue中？这个rule是通过Exchange的类型定义的。&lt;/p&gt;

&lt;p&gt;我们知道有三种类型的Exchange：direct, topic 和fanout。fanout就是广播模式，会将所有的Message都放到它所知道的queue中。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-五-routing-消息路由-http-blog-csdn-net-anzhsoft-article-details-19630147&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19630147&#34;&gt;RabbitMQ消息队列（五）：Routing 消息路由&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;上篇文章中，我们构建了一个简单的日志系统。接下来，我们将丰富它：能够使用不同的severity来监听不同等级的log。比如我们希望只有error的log才保存到磁盘上。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-六-使用主题进行消息分发-http-blog-csdn-net-anzhsoft-article-details-19633079&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19633079&#34;&gt;RabbitMQ消息队列（六）：使用主题进行消息分发&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在上篇文章中，我们实现了一个简单的日志系统。Consumer可以监听不同severity的log。但是，这也是它之所以叫做简单日志系统的原因，因为是仅仅能够通过severity设定。不支持更多的标准。&lt;/p&gt;

&lt;p&gt;比如syslog unix的日志工具，它可以通过severity (info/warn/crit&amp;hellip;) 和模块(auth/cron/kern&amp;hellip;)。这可能更是我们想要的：我们可以仅仅需要cron模块的log。&lt;/p&gt;

&lt;p&gt;为了实现类似的功能，我们需要用到topic exchange。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列-七-适用于云计算集群的远程调用-rpc-http-blog-csdn-net-anzhsoft-article-details-19633107&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19633107&#34;&gt;RabbitMQ消息队列（七）：适用于云计算集群的远程调用（RPC）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在云计算环境中，很多时候需要用它其他机器的计算资源，我们有可能会在接收到Message进行处理时，会把一部分计算任务分配到其他节点来完成。那么，RabbitMQ如何使用RPC呢？在本篇文章中，我们将会通过其它节点来求斐波纳契完成示例。&lt;/p&gt;

&lt;p&gt;为了展示一个RPC服务是如何使用的，我们将创建一段很简单的客户端class。它将会向外提供名字为call的函数，这个call会发送RPC请求并且阻塞知道收到RPC运算的结果。&lt;/p&gt;

&lt;h3 id=&#34;rabbitmq消息队列的小伙伴-protobuf-google-protocol-buffer-http-blog-csdn-net-anzhsoft-article-details-19771671&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/19771671&#34;&gt;RabbitMQ消息队列的小伙伴: ProtoBuf（Google Protocol Buffer）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;什么是ProtoBuf？&lt;/p&gt;

&lt;p&gt;一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。&lt;/p&gt;

&lt;p&gt;它可以作为RabbitMQ的Message的数据格式进行传输，由于是结构化的数据，这样就极大的方便了Consumer的数据高效处理。当然了你可能说使用XML不也可以吗？与XML相比，ProtoBuf有以下优势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;size小了3-10倍&lt;/li&gt;
&lt;li&gt;速度快了20-100倍&lt;/li&gt;
&lt;li&gt;易于编程&lt;/li&gt;
&lt;li&gt;减小了语义的歧义&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;rabbitmq消息队列-九-publisher的消息确认机制-http-blog-csdn-net-anzhsoft-article-details-21603479&#34;&gt;&lt;a href=&#34;http://blog.csdn.net/anzhsoft/article/details/21603479&#34;&gt;RabbitMQ消息队列（九）：Publisher的消息确认机制&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在前面的文章中提到了queue和consumer之间的消息确认机制：通过设置ack。那么Publisher能不到知道他post的Message有没有到达queue，甚至更近一步，是否被某个Consumer处理呢？毕竟对于一些非常重要的数据，可能Publisher需要确认某个消息已经被正确处理。&lt;/p&gt;

&lt;p&gt;在我们的系统中，我们没有是实现这种确认，也就是说，不管Message是否被Consume了，Publisher不会去关心。他只是将自己的状态publish给上层，由上层的逻辑去处理。如果Message没有被正确处理，可能会导致某些状态丢失。但是由于提供了其他强制刷新全部状态的机制，因此这种异常情况的影响也就可以忽略不计了。&lt;/p&gt;

&lt;p&gt;对于某些异步操作，比如客户端需要创建一个FileSystem，这个可能需要比较长的时间，甚至要数秒钟。这时候通过RPC可以解决这个问题。因此也就不存在Publisher端的确认机制了。&lt;/p&gt;

&lt;p&gt;那么，有没有一种机制能保证Publisher能够感知它的Message有没有被处理的？答案肯定的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pandas学习笔记（二）：基本数据结构</title>
      <link>http://hshsh.me/post/2016-04-13-python-pandas-notes-02/</link>
      <pubDate>Wed, 13 Apr 2016 18:02:04 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-13-python-pandas-notes-02/</guid>
      <description>

&lt;p&gt;Pandas的开发者是：&lt;a href=&#34;http://wesmckinney.com&#34;&gt;Wes McKinney&lt;/a&gt;，这位大牛工作的时候没有顺手的工具，就决定自己顺手写一个出来。&lt;/p&gt;

&lt;p&gt;Pandas具有但不限于一下特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;具备按轴自动或显式数据对齐功能的数据结构，这可以防止许多由于数据没有对齐以及来自不同数据源（索引方式不同）的数据而导致的常见错误；&lt;/li&gt;
&lt;li&gt;集成时间序列功能；&lt;/li&gt;
&lt;li&gt;既能处理时间序列数据也能处理非时间序列数据的数据结构；&lt;/li&gt;
&lt;li&gt;数学运算和约简（比如对某个轴求和）可以根据不同的元数据（轴编号）执行；&lt;/li&gt;
&lt;li&gt;可以灵活处理缺失数据；&lt;/li&gt;
&lt;li&gt;合并及其他出现在常见数据库（例如基于SQL的）中的关系型运算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pandas的导入约定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pandas import Series, DataFrame
import pandas as pd
import numpy as np
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;series&#34;&gt;Series&lt;/h2&gt;

&lt;p&gt;Series可以使用列表初始化，初始化时还可以指定索引名称。&lt;/p&gt;

&lt;p&gt;Series可以被看成时一个定长的有序字典，因为它时索引值到数据值的一个映射，它可以用在许多原本需要字典参数的函数中。&lt;/p&gt;

&lt;p&gt;如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series。通过指定 &lt;code&gt;index&lt;/code&gt; 可以只选择需要的对象，缺失值使用NaN自动填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj = Series([4, 7, -5, 3])
obj, obj.values, obj.index

obj = Series([4, 7, -5, 3], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])

obj[obj &amp;gt; 0]
obj * 2
np.exp(obj)

&#39;b&#39; in obj

sdata = {&#39;Ohio&#39;: 35000, &#39;Texas&#39;: 71000, &#39;Oregon&#39;: 16000, &#39;Utah&#39;: 5000}
sdata = Series(sdata)
sdata
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;states = [&#39;California&#39;, &#39;Ohio&#39;, &#39;Oregon&#39;, &#39;Texas&#39;]
obj = Series(sdata, index=states)
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对很多应用而言，Series最重要的一个功能是：在算数运算中会自动对齐不同索引的数据。&lt;/p&gt;

&lt;p&gt;Series对象本身及其索引都有一个 &lt;code&gt;name&lt;/code&gt; 属性，该属性跟Pandas其他的关键功能关系非常密切。&lt;/p&gt;

&lt;p&gt;Series的索引可以通过赋值的方式就地修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sdata + obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj.name = &#39;population&#39;
obj.index.name = &#39;state&#39;
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;obj.index = [&#39;Tibet&#39;, &#39;Beijing&#39;, &#39;Tianjin&#39;, &#39;Henan&#39;]
obj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Tibet          NaN
Beijing    35000.0
Tianjin    16000.0
Henan      71000.0
Name: population, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dataframe&#34;&gt;DataFrame&lt;/h2&gt;

&lt;p&gt;DataFrame是一个表格型的数据结构，含有一组有序的列，每列可以时不同的值类型（数值、字符串、布尔值等）。&lt;/p&gt;

&lt;p&gt;DataFrame既有行索引也有列索引，它可以被看成由Series组成的字典（共用同一个索引）。&lt;/p&gt;

&lt;p&gt;跟其他类似的数据结构相比（如R的 &lt;code&gt;data.frame&lt;/code&gt;），DataFrame中面向行和面向列的操作基本上时平衡的。&lt;/p&gt;

&lt;p&gt;构建DataFrame的办法有很多种，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典，DataFrame会自动加上索引，且所有列会被有序排列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = {&#39;state&#39;: [&#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Nevada&#39;, &#39;Nevada&#39;],
            &#39;year&#39;: [2000, 2001, 2002, 2001, 2002],
            &#39;pop&#39;: [1.5, 1.7, 3.6, 2.4, 2.9]}
frame = DataFrame(data)
frame
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列，如果传入的列在数据中找不到，则会产生NaN值。&lt;/p&gt;

&lt;p&gt;除了指定列序列，还可以指定行索引序列，而不是使用默认的数字索引。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2 = DataFrame(data, columns=[&#39;year&#39;, &#39;state&#39;, &#39;pop&#39;, &#39;debt&#39;],
                   index=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;])
frame2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;debt&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;one&lt;/th&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;two&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;three&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;four&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;five&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。&lt;/p&gt;

&lt;p&gt;返回的Series拥有原DataFrame相同的索引，而且其 &lt;code&gt;name&lt;/code&gt; 属性也已经被相应的设置好狼（抽取的列名）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2[&#39;state&#39;]  # or frame2.state
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
Name: state, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行也可以通过位置或名称的方式进行获取，比如用索引字段 &lt;code&gt;ix&lt;/code&gt; 获取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2.ix[&#39;three&#39;]  # or frame2.ix[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列可以通过赋值的方式进行修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用标量赋值会赋值给整列；&lt;/li&gt;
&lt;li&gt;使用列表或数组给某个列赋值时，其长度必须跟DataFrame的长度相匹配（如果不匹配，会抛出ValueError异常）；&lt;/li&gt;
&lt;li&gt;如果赋值的是一个Series，会精确匹配DataFrame的索引，所有空位都将被填上缺失值 &lt;code&gt;NaN&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;为不存在的列赋值会创建出一个新列；&lt;/li&gt;
&lt;li&gt;关键字 &lt;code&gt;del&lt;/code&gt; 用于删除列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，任何对返回的Series的就地修改全部会反应到源DataFrame上。通过Series的 &lt;code&gt;copy&lt;/code&gt; 方法可以显式的复制列。&lt;/p&gt;

&lt;p&gt;除了接受由数组组成的字典外，DataFrame还可以接受其他很多中数据输入：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;嵌套字典，如：{&amp;lsquo;Nevada&amp;rsquo;: {2001: 2.4, 2002: 2.9}, &amp;lsquo;Ohio&amp;rsquo;: {2000: 1.5, 2001: 1.7, 2002: 3.6}}&lt;/li&gt;
&lt;li&gt;二维ndarray：数据矩阵，还可以传入行标和列标&lt;/li&gt;
&lt;li&gt;由数组、列表或元组组成的字典：每个序列会变成DataFrame的一列，所有序列的长度必须相同&lt;/li&gt;
&lt;li&gt;NumPy的结构化／记录数组：类似于“由数组组成的字典”&lt;/li&gt;
&lt;li&gt;由Series组成的字典：每个Series会成为一列，如果没有显式指定索引，则各Series的索引会被合并成结果的行索引&lt;/li&gt;
&lt;li&gt;字典或Series的列表：各项将会成为DataFrame的一行，字典键或Series索引的并集将会成为DataFrame的列标&lt;/li&gt;
&lt;li&gt;由列表或元组组成的列表：类似于“二维ndarray“&lt;/li&gt;
&lt;li&gt;另一个DataFrame：该DataFrame的索引将会被沿用，除非显式的指定列其他索引&lt;/li&gt;
&lt;li&gt;NumPy的MaskedArray：类似于“二维ndarray”的情况，只是掩码值在结果DataFrame中会变成NA/缺失值&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;索引对象&#34;&gt;索引对象&lt;/h2&gt;

&lt;p&gt;Index对象是Pandas数据模型的重要组成部分。&lt;/p&gt;

&lt;p&gt;Pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index对象。&lt;/p&gt;

&lt;p&gt;Index对象是不可修改的（immutable），因此用户不能对其进行修改。Index对象的不可修改性非常重要，因为这样才能使Index对象在多个数据结构之间安全共享。&lt;/p&gt;

&lt;p&gt;Pandas库中内置了一些常用的Index类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Index：最泛化的Index对象，将轴标签表示为一个由Python对象组成的NumPy数组，&lt;/li&gt;
&lt;li&gt;Int64Index：针对整数的特殊Index，&lt;/li&gt;
&lt;li&gt;MultiIndex：“层次化”索引对象，表示单个轴上的多层索引，可以看作由元组组成的数组，&lt;/li&gt;
&lt;li&gt;DatetimeIndex：存储纳秒级的时间戳（用NumPy的 &lt;code&gt;datetime64&lt;/code&gt; 类型表示），&lt;/li&gt;
&lt;li&gt;PeriodIndex：针对Period数据（时间间隔）的特殊Index&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这些常用的Index类型，Index甚至还可以被继承从而实现特别的轴索引功能。&lt;/p&gt;

&lt;p&gt;Index对象长得很像数组，功能也很类似一个固定大小的集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;frame2.index.name = &#39;number&#39;
frame2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;pop&lt;/th&gt;
      &lt;th&gt;debt&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;number&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;one&lt;/th&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;two&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;1.7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;three&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Ohio&lt;/td&gt;
      &lt;td&gt;3.6&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;four&lt;/th&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.4&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;five&lt;/th&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;Nevada&lt;/td&gt;
      &lt;td&gt;2.9&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;state&#39; in frame2.columns or &#39;one&#39; in frame2.index
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。下面是一些比较常用的函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;append：连接另一个Index对象，产生一个新的 Index&lt;/li&gt;
&lt;li&gt;diff：计算差集，并得到一个新的 Index&lt;/li&gt;
&lt;li&gt;intersection：计算交集&lt;/li&gt;
&lt;li&gt;union：计算并集&lt;/li&gt;
&lt;li&gt;isin：计算一个指示各值是否都包含在参数集合中的布尔型数组&lt;/li&gt;
&lt;li&gt;delete：删除指定索引处的元素，并得到新的 Index&lt;/li&gt;
&lt;li&gt;drop：删除传入的值，并得到新的 Index&lt;/li&gt;
&lt;li&gt;insert：将元素插入到索引处，并得到新的 Index&lt;/li&gt;
&lt;li&gt;is_monotonic：当各元素均大于等于前一个元素时，返回 True&lt;/li&gt;
&lt;li&gt;is_unique：当Index没有重复值时，返回 True&lt;/li&gt;
&lt;li&gt;unique：计算Index中唯一值的数组&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pandas学习笔记（一）：CSV数据加载保存</title>
      <link>http://hshsh.me/post/2016-04-12-python-pandas-notes-01/</link>
      <pubDate>Tue, 12 Apr 2016 18:52:25 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-12-python-pandas-notes-01/</guid>
      <description>

&lt;h2 id=&#34;加载csv数据&#34;&gt;加载CSV数据&lt;/h2&gt;

&lt;p&gt;很多数据都存储在CSV文件中，Pandas 为读取提供了一个强大的 &lt;code&gt;read_csv&lt;/code&gt; 函数，这个函数接受很多可选参数，通过参数控制数据加载的方式，以及一些基本的清理工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.read_csv(filepath_or_buffer, sep=&#39;,&#39;, delimiter=None, header=&#39;infer&#39;,
    names=None, index_col=None, usecols=None, squeeze=False, prefix=None,
    mangle_dupe_cols=True, dtype=None, engine=None, converters=None,
    true_values=None, false_values=None, skipinitialspace=False,
    skiprows=None, skipfooter=None, nrows=None, na_values=None,
    keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True,
    parse_dates=False, infer_datetime_format=False, keep_date_col=False,
    date_parser=None, dayfirst=False, iterator=False, chunksize=None,
    compression=&#39;infer&#39;, thousands=None, decimal=&#39;.&#39;, lineterminator=None,
    quotechar=&#39;&amp;quot;&#39;, quoting=0, escapechar=None, comment=None, encoding=None,
    dialect=None, tupleize_cols=False, error_bad_lines=True,
    warn_bad_lines=True, skip_footer=0, doublequote=True,
    delim_whitespace=False, as_recarray=False, compact_ints=False,
    use_unsigned=False, low_memory=True, buffer_lines=None, memory_map=False,
    float_precision=None)

Returns
    result : DataFrame or TextParser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多参数都是非常有用的，简要记录一下（详细文档请参考 &lt;code&gt;help(pd.read_csv)&lt;/code&gt; 及官方文档）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;filepath_or_buffer&lt;/code&gt;：参数名字本身反映了功能

&lt;ul&gt;
&lt;li&gt;这里可以接受一个文件名，或者一个URL，&lt;/li&gt;
&lt;li&gt;也可以接受一个打开的文件句柄，&lt;/li&gt;
&lt;li&gt;或者其他任何提供了&lt;code&gt;read&lt;/code&gt;方法的对象，&lt;/li&gt;
&lt;li&gt;举个栗子：某个URL输出CSV，但是需要验证密码，那么就没法让 &lt;code&gt;read_csv&lt;/code&gt; 直接读取URL，但是可以使用 &lt;code&gt;urlopen&lt;/code&gt; 发送附带了验证信息的Request，并把返回的 Response 对象传给 &lt;code&gt;read_csv&lt;/code&gt; 函数，进而通过 Response 对象的 &lt;code&gt;read&lt;/code&gt; 方法加载数据；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sep&lt;/code&gt; 和 &lt;code&gt;delimiter&lt;/code&gt;：这两个参数是一个意思，&lt;code&gt;delimiter&lt;/code&gt;是&lt;code&gt;sep&lt;/code&gt;的别名；如果指定为 &lt;code&gt;\t&lt;/code&gt;（制表符）的话，就可以实现 &lt;code&gt;read_table&lt;/code&gt; 的默认功能；支持使用正则表达式来匹配某些不标准的CSV文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;names&lt;/code&gt;：配合使用指定加载后的列名；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse_dates&lt;/code&gt;：boolean or list of ints or names or list of lists or dict, default False. 这个参数指定对CSV文件中日期序列的处理方式：

&lt;ul&gt;
&lt;li&gt;默认为False，原样加载，不解析日期时间，&lt;/li&gt;
&lt;li&gt;可以为True，尝试解析日期索引，&lt;/li&gt;
&lt;li&gt;可以为数字或 &lt;code&gt;names&lt;/code&gt; 的列表，解析指定的列为时间序列，&lt;/li&gt;
&lt;li&gt;可以为以列表为元素的列表，解析每个子列表中的字段组合为时间序列，&lt;/li&gt;
&lt;li&gt;可以为值为列表的字典，解析每个列表中的字段组合为时间序列，并命名为字典中对应的键值；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date_parser&lt;/code&gt;：可以指定一个自定义函数解析日期；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keep_date_col&lt;/code&gt;：解析出日期序列后，是否保留原来的列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dayfirst&lt;/code&gt;：boolean, default False, DD/MM format dates, international and European format；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterator&lt;/code&gt;：boolean, default False，Return TextFileReader object for iteration or getting chunks with &lt;code&gt;get_chunk()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding&lt;/code&gt;：指定读取或写入CSV文件时使用的字符集，支持 &lt;a href=&#34;https://docs.python.org/3/library/codecs.html#standard-encodings&#34;&gt;codecs 包中的标准字符集&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index_col&lt;/code&gt;：数字、列名或列表，数字或列名指定某一列作为索引，列表制定某几列作为 DataFrame 的层次索引；&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;skip_initialspace&lt;/code&gt;, &lt;code&gt;skiprows&lt;/code&gt;, &lt;code&gt;skipfooter&lt;/code&gt;, &lt;code&gt;comment&lt;/code&gt;, &lt;code&gt;float_precision&lt;/code&gt;等参数做一些基本的清理动作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面举个例子来简单演示一下 &lt;code&gt;parse_dates&lt;/code&gt; 和 &lt;code&gt;data_parser&lt;/code&gt; 的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
from tempfile import TemporaryFile

mycsv = [&amp;quot;date,hour,A1,A2,A3,A4,A5,A6,date2,hour2&amp;quot;,
    &amp;quot;20150102,1,117,85,109,132,166,113,20160102,2&amp;quot;,
    &amp;quot;20150102,2,88,34,82,100,126,85,20160102,3&amp;quot;,
    &amp;quot;20150102,3,48,54,38,50,55,46,20160102,4&amp;quot;,
    &amp;quot;20150102,4,141,120,154,148,175,114,20160102,5&amp;quot;,
    &amp;quot;20150102,5,91,64,74,71,84,70,20160102,6&amp;quot;,
    &amp;quot;20150102,6,45,10,46,20,68,44,20160102,7&amp;quot;]

tmp_csv_file = TemporaryFile()
tmp_csv_file.write(&#39;\n&#39;.join(mycsv))
tmp_csv_file.flush()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;20150102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;从上面的示例中，可以看到使用默认参数时，&lt;code&gt;read_csv&lt;/code&gt; 函数不会尝试解析日期，这样可以提高文件的加载速度。&lt;/p&gt;

&lt;p&gt;但是第一列日期和第二列小时构成了我们需要的时间戳，加载了CSV后我们需要进行处理，那能不能在加载CSV的时候就直接解析出来呢？我们可以试一试 &lt;code&gt;parse_dates&lt;/code&gt; 参数，把第一列和第二列的索引组成一个列表传给 &lt;code&gt;parse_dates&lt;/code&gt; 参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, parse_dates=[0, 1])
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;2015-01-02&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;我们看到第一列被成功的解析成了日期数据，但是并没有按照我们想象的那样把第一列和第二列一起解析成一个日期时间对象。&lt;/p&gt;

&lt;p&gt;这是因为我们&lt;strong&gt;传递参数的姿势不对&lt;/strong&gt;，正确的应该是这样：&lt;code&gt;parse_dates=[[0, 1]]&lt;/code&gt;，再试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, parse_dates=[[0, 1]])
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;date_hour&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
      &lt;th&gt;date2&lt;/th&gt;
      &lt;th&gt;hour2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;20150102 1&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;20150102 2&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;20150102 3&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;20150102 4&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;20150102 5&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;20150102 6&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;20160102&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Opps！虽然第一列和第二列合并到一起了，但是并没有成功的解析成日期时间对象。因为这个格式真的没人看得懂是一个日期时间对象啊！！！&lt;/p&gt;

&lt;p&gt;那就没有办法在加载CSV的时候就解析时间序列的方法了吗？&lt;/p&gt;

&lt;p&gt;答案是有的。&lt;code&gt;read_csv&lt;/code&gt; 还有一个参数：&lt;code&gt;date_parser&lt;/code&gt;，我们可以自己写一个日期时间对象解析函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime

def my_date_parser(dt, hour):
    return datetime(int(dt[0:4]), int(dt[4:6]), int(dt[6:8]), int(hour))

tmp_csv_file.seek(0)
df = pd.read_csv(tmp_csv_file, date_parser=my_date_parser,
                 parse_dates={&#39;time&#39;: [0, 1], &#39;time2&#39;: [&#39;date2&#39;, &#39;hour2&#39;]},
                 index_col=&#39;time&#39;)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;time2&lt;/th&gt;
      &lt;th&gt;A1&lt;/th&gt;
      &lt;th&gt;A2&lt;/th&gt;
      &lt;th&gt;A3&lt;/th&gt;
      &lt;th&gt;A4&lt;/th&gt;
      &lt;th&gt;A5&lt;/th&gt;
      &lt;th&gt;A6&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;time&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 01:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 02:00:00&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 02:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 03:00:00&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;82&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 03:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 04:00:00&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 04:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 05:00:00&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;175&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 05:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 06:00:00&lt;/td&gt;
      &lt;td&gt;91&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;84&lt;/td&gt;
      &lt;td&gt;70&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2015-01-02 06:00:00&lt;/th&gt;
      &lt;td&gt;2016-01-02 07:00:00&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;68&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Bingo！是不是搞定了。这样加载并解析时间序列的效率也比加载后使用循环或列表解析处理的效率高的多了。&lt;/p&gt;

&lt;p&gt;上面这段示例代码中，还演示了解析多列时间序列，可以按照列的索引指定要解析的列，也可以按照列名来制定要解析的列，另外，还演示了使用 &lt;code&gt;index_col&lt;/code&gt; 参数指定 DataFrame 索引的用法。&lt;/p&gt;

&lt;h2 id=&#34;保存csv数据&#34;&gt;保存CSV数据&lt;/h2&gt;

&lt;p&gt;除了加载CSV数据很方便之外，Pandas 的 DataFrame 类一个很方便的 &lt;code&gt;to_csv&lt;/code&gt; 方法，可以把数据保存到CSV文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.DataFrame.to_csv(self, path_or_buf=None, sep=&#39;,&#39;, na_rep=&#39;&#39;,
    float_format=None, columns=None, header=True, index=True, index_label=None,
    mode=&#39;w&#39;, encoding=None, compression=None, quoting=None, quotechar=&#39;&amp;quot;&#39;, 
    line_terminator=&#39;\n&#39;, chunksize=None, tupleize_cols=False, date_format=None,
    doublequote=True, escapechar=None, decimal=&#39;.&#39;, **kwds)
    
unbound pandas.core.frame.DataFrame method:
    Write DataFrame to a comma-separated values (csv) file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，默认输出就是标准的逗号分割的CSV文件，跟 &lt;code&gt;read_csv&lt;/code&gt; 函数一样，这个函数同样有很多可选参数控制输出。&lt;/p&gt;

&lt;p&gt;除了输出到CSV外，DataFrame 还有很多输出到其他格式的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[meth for meth in dir(pd.DataFrame) if meth.startswith(&#39;to_&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;to_clipboard&#39;,
 &#39;to_csv&#39;,
 &#39;to_dense&#39;,
 &#39;to_dict&#39;,
 &#39;to_excel&#39;,
 &#39;to_gbq&#39;,
 &#39;to_hdf&#39;,
 &#39;to_html&#39;,
 &#39;to_json&#39;,
 &#39;to_latex&#39;,
 &#39;to_msgpack&#39;,
 &#39;to_panel&#39;,
 &#39;to_period&#39;,
 &#39;to_pickle&#39;,
 &#39;to_records&#39;,
 &#39;to_sparse&#39;,
 &#39;to_sql&#39;,
 &#39;to_stata&#39;,
 &#39;to_string&#39;,
 &#39;to_timestamp&#39;,
 &#39;to_wide&#39;,
 &#39;to_xarray&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路漫漫其修远兮～～我将慢慢去求索～～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python代理类两例</title>
      <link>http://hshsh.me/post/2016-04-10-python-proxy-class-examples/</link>
      <pubDate>Sun, 10 Apr 2016 23:30:00 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-10-python-proxy-class-examples/</guid>
      <description>

&lt;p&gt;最近遇到MySQL的连接断开，MySQLdb报&amp;rsquo;(2006, MySQL server has gone away.)&amp;lsquo;错误的问题。&lt;/p&gt;

&lt;p&gt;问题发生的环境是，客户端使用了长连接，程序启动的时候使用MySQLdb模块的connect方法建立一个数据库连接，程序运行期间一直使用这个连接。对于请求比较多的服务程序来说，这个方法不会出现问题，因为MySQL默认连接超时的时间设定是8小时，所以连接不会超时断开，也就不会报这个错误了。但是作为一个调试服务，请求频率可能低于8小时，就导致错误了。&lt;/p&gt;

&lt;p&gt;由于不想修改很多具体实现的代码，所以使用&lt;strong&gt;代理类&lt;/strong&gt;的方法对这个程序打了个补丁解决问题。&lt;/p&gt;

&lt;p&gt;另外 SQLAlchemy 中的 &lt;code&gt;scoped_session&lt;/code&gt; 也是一个代理类，实现也很有意思，这里一起分享一下这两个代理类。&lt;/p&gt;

&lt;h2 id=&#34;mysqldb-connection-代理类&#34;&gt;MySQLdb Connection 代理类&lt;/h2&gt;

&lt;p&gt;先看看出问题的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import MySQLdb
conn = MySQLdb.connect(host=&#39;host&#39;, port=&#39;port&#39;,
                       user=&#39;user&#39;, passwd=&#39;passwd&#39;, db=&#39;db&#39;)

def use_mysql():
    cursor = conn.cursor()
    cursor.execute(&#39;do something with mysql database;&#39;)
    cursor.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MySQLdb.connect&lt;/code&gt;函数返回的是一个&lt;code&gt;Connection&lt;/code&gt;对象，当操作频率大于8个小时的时候，MySQL服务器就会关闭连接，然后下一次执行 &lt;code&gt;cursor = conn.cursor()&lt;/code&gt; 的时候，就会报连接丢失的错误。为了既使用长连接，又能避免这个错误，我们可以封装一个&lt;code&gt;Connection&lt;/code&gt;类的代理类，重载 &lt;code&gt;cursor&lt;/code&gt; 方法，当有新的请求的时候，先检查连接是否还在，如果连接丢失的话，就重新连接数据库，然后再调用 &lt;code&gt;Connection&lt;/code&gt; 类的 &lt;code&gt;cursor&lt;/code&gt; 方法并返回结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import MySQLdb
from MySQLdb.connections import Connection

class ProxyConnection(Connection):
    def __init__(self, *args, **kwargs):
        # 保存数据库连接参数以备丢失时候重新连接
        self._proxy_args = args
        self._proxy_kwargs = kwargs
        super(ProxyConnection, self).__init__(*args, **kwargs)

    def cursor(self, cursorclass=None):
        try:
            self.ping()
        except MySQLdb.OperationalError:
            super(ProxyConnection, self).__init__(*self._proxy_args, **self._proxy_kwargs)
        return super(ProxyConnection, self).cursor(cursorclass)

conn = ProxyConnection(host=&#39;host&#39;, port=&#39;port&#39;,
                       user=&#39;user&#39;, passwd=&#39;passwd&#39;, db=&#39;db&#39;)

def use_mysql():
    cursor = conn.cursor()
    cursor.execute(&#39;do something with mysql database;&#39;)
    cursor.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代理类，只重载 &lt;code&gt;cursor()&lt;/code&gt; 这一个方法，其他方法直接继承自父类 &lt;code&gt;Connection&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样就解决了MySQL数据库连接丢失的问题。但是这个方法并不是完美的，主要的缺点是每次处理新的请求时，都要 &lt;code&gt;ping()&lt;/code&gt; 一下，当请求比较多的时候，会增加不必要的开支。不过如果真的请求多的话，也就不会出现这个问题了。作为低请求频次服务的解决方法，这个代理类用起来还是很方便的。&lt;/p&gt;

&lt;p&gt;相对于这种粗糙的方法，SQLAlchemy中 &lt;code&gt;scoped_session&lt;/code&gt; 类对 Session 类的代理实现就精巧的多了，而且它并没有从被代理的 &lt;code&gt;session&lt;/code&gt; 类继承，而是一个完全独立的类（实际上&lt;code&gt;scoped_session&lt;/code&gt;是一种 &lt;a href=&#34;http://martinfowler.com/eaaCatalog/registry.html&#34;&gt;Registry 设计模式&lt;/a&gt;，实现了一些高级功能，不过这里暂时只看它的代理作用）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2016-05-20更新：&lt;/p&gt;

&lt;p&gt;除了每次调用cursor方法获取游标时，都ping一下之外，还可以给MySQL的连接代理类增加一个超时机制，只有超时的时候才触发ping动作，这样可以兼顾道效率。&lt;/p&gt;

&lt;p&gt;下面是实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MySQLConnection(MySQLdb.connections.Connection):
    def __init__(self, *args, **kwargs):
        # set timeout to avoid (2006, &#39;MySQL server has gone away&#39;) problem
        # mysql close connection after 8 hours without activity by default
        self._recycle = kwargs.pop(&#39;recycle&#39;, None) or 7.5 * 3600
        self._last_time = time.time()
        # store connection parameters to reconnect
        self._proxy_args = args
        self._proxy_kwargs = kwargs
        super(MySQL, self).__init__(*args, **kwargs)

    def cursor(self, cursorclass=None):
        if time.time() - self._last_time &amp;gt; self._recycle:
            try:
                self.ping()
            except MySQLdb.OperationalError:
                super(MySQLConnection, self).__init__(*self._proxy_args, **self._proxy_kwargs)
        self._last_time = time.time()
        return super(MySQL, self).cursor(cursorclass)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;sqlalchemy-代理类-scoped-session&#34;&gt;SQLAlchemy 代理类 &lt;code&gt;scoped_session&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 的 Session 类是 SQLAlchemy ORM 模型对数据库操作的主要接口，定义了&lt;code&gt;query&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;, &lt;code&gt;refresh&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;等方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-pyhton&#34;&gt;# file: sqlalchemy/orm/session.py

class Session(_SessionClassMethods):
    &amp;quot;&amp;quot;&amp;quot;Manages persistence operations for ORM-mapped objects.

    The Session&#39;s usage paradigm is described at :doc:`/orm/session`.
    &amp;quot;&amp;quot;&amp;quot;

    public_methods = (
        &#39;__contains__&#39;, &#39;__iter__&#39;, &#39;add&#39;, &#39;add_all&#39;, &#39;begin&#39;, &#39;begin_nested&#39;,
        &#39;close&#39;, &#39;commit&#39;, &#39;connection&#39;, &#39;delete&#39;, &#39;execute&#39;, &#39;expire&#39;,
        &#39;expire_all&#39;, &#39;expunge&#39;, &#39;expunge_all&#39;, &#39;flush&#39;, &#39;get_bind&#39;,
        &#39;is_modified&#39;, &#39;bulk_save_objects&#39;, &#39;bulk_insert_mappings&#39;,
        &#39;bulk_update_mappings&#39;,
        &#39;merge&#39;, &#39;query&#39;, &#39;refresh&#39;, &#39;rollback&#39;,
        &#39;scalar&#39;)

    # def __init__(...):
    #     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Session类的对象可以通过 &lt;code&gt;sessionmaker(bind=engine)()&lt;/code&gt; 建立，由使用数据库的模块建立、使用，并自行管理。&lt;code&gt;scoped_session&lt;/code&gt; 类给 Session 对象提供了一层透明代理，既可以像使用 Session 对象一样使用，又可以对 Session 对象进行统一管理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类的实现代码并不复杂，而且相当的精巧，下面是全部代码（为方便阅读，已删除文档字符串）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file: sqlalchemy/orm/scoping.py

class scoped_session(object):
    session_factory = None

    def __init__(self, session_factory, scopefunc=None):
        self.session_factory = session_factory
        if scopefunc:
            self.registry = ScopedRegistry(session_factory, scopefunc)
        else:
            self.registry = ThreadLocalRegistry(session_factory)

    def __call__(self, **kw):
        if kw:
            scope = kw.pop(&#39;scope&#39;, False)
            if scope is not None:
                if self.registry.has():
                    raise sa_exc.InvalidRequestError(
                        &amp;quot;Scoped session is already present; &amp;quot;
                        &amp;quot;no new arguments may be specified.&amp;quot;)
                else:
                    sess = self.session_factory(**kw)
                    self.registry.set(sess)
                    return sess
            else:
                return self.session_factory(**kw)
        else:
            return self.registry()

    def remove(self):
        if self.registry.has():
            self.registry().close()
        self.registry.clear()

    def configure(self, **kwargs):
        if self.registry.has():
            warn(&#39;At least one scoped session is already present. &#39;
                 &#39; configure() can not affect sessions that have &#39;
                 &#39;already been created.&#39;)

        self.session_factory.configure(**kwargs)

    def query_property(self, query_cls=None):
        class query(object):
            def __get__(s, instance, owner):
                try:
                    mapper = class_mapper(owner)
                    if mapper:
                        if query_cls:
                            # custom query class
                            return query_cls(mapper, session=self.registry())
                        else:
                            # session&#39;s configured query class
                            return self.registry().query(mapper)
                except orm_exc.UnmappedClassError:
                    return None
        return query()

&amp;quot;&amp;quot;&amp;quot;Old name for backwards compatibility.&amp;quot;&amp;quot;&amp;quot;
ScopedSession = scoped_session


def instrument(name):
    def do(self, *args, **kwargs):
        return getattr(self.registry(), name)(*args, **kwargs)
    return do

for meth in Session.public_methods:
    setattr(scoped_session, meth, instrument(meth))


def makeprop(name):
    def set(self, attr):
        setattr(self.registry(), name, attr)

    def get(self):
        return getattr(self.registry(), name)

    return property(get, set)

for prop in (&#39;bind&#39;, &#39;dirty&#39;, &#39;deleted&#39;, &#39;new&#39;, &#39;identity_map&#39;,
             &#39;is_active&#39;, &#39;autoflush&#39;, &#39;no_autoflush&#39;, &#39;info&#39;):
    setattr(scoped_session, prop, makeprop(prop))


def clslevel(name):
    def do(cls, *args, **kwargs):
        return getattr(Session, name)(*args, **kwargs)
    return classmethod(do)

for prop in (&#39;close_all&#39;, &#39;object_session&#39;, &#39;identity_key&#39;):
    setattr(scoped_session, prop, clslevel(prop))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;撇开复杂的部分不说，暂时之看这个类的透明代理性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当程序需要连接数据库的时候，可以使用 &lt;code&gt;scoped_session&lt;/code&gt;，像使用&lt;code&gt;Session&lt;/code&gt;类一样，&lt;code&gt;Session&lt;/code&gt;支持的方法都支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类通过 &lt;code&gt;instrument&lt;/code&gt;, &lt;code&gt;makeprop&lt;/code&gt;, &lt;code&gt;clslevel&lt;/code&gt; 这几个函数把 &lt;code&gt;Session&lt;/code&gt; 类的方法属性“挂接”到自己身上，实现了对 &lt;code&gt;Session&lt;/code&gt; 类的透明代理&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_session&lt;/code&gt; 类通过维护 Registry 来实现程序的不同部分可以共用 Session，既节省资源，又方便不同部分共享数据（不知道这样理解对不对？）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_session&lt;/code&gt; 对象的作用域是线程局部的，类内部通过以 &lt;code&gt;threading.local()&lt;/code&gt; 作为 Registry 的键值，来区分不同线程中的对象，不同的线程不共享Session对象，这样就实现了线程安全，写程序的时候只需要使用 &lt;code&gt;scoped_session&lt;/code&gt; 来操作就好了，而不需要再关注线程相关的东西了。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;有时候，代理类用着还是很方便的。我是一个初学者，如果本文中有谬误，请不吝指正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[转载] Python类引入机制</title>
      <link>http://hshsh.me/post/2016-04-08-python-import-schema/</link>
      <pubDate>Fri, 08 Apr 2016 09:27:54 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-08-python-import-schema/</guid>
      <description>

&lt;p&gt;本文转载自&lt;a href=&#34;http://liuchang0812.com&#34;&gt;刘畅的博客&lt;/a&gt;，原文地址：&lt;a href=&#34;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&#34;&gt;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&lt;/a&gt;。本文所涉及到的代码在&lt;a href=&#34;https://github.com/Liuchang0812/slides/tree/master/pycon2015cn&#34;&gt;github&lt;/a&gt;上。&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Python 是一门优美简单、功能强大的动态语言。在刚刚接触这门语言时，我们会被其优美的格式、简洁的语法和无穷无尽的类库所震撼。在真正的将python应用到实际的项目中，你会遇到一些无法避免的问题。最让人困惑不解的问题有二类，一个 编码问题，另一个则是引用问题。&lt;/p&gt;

&lt;p&gt;本文主要讨论关于Python中import的机制与实现、以及介绍一些有意思的Python Hooks。&lt;/p&gt;

&lt;h2 id=&#34;python-类库引入机制&#34;&gt;Python 类库引入机制&lt;/h2&gt;

&lt;p&gt;首先，看一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
目录结构如下：
├── __init__.py
├── main.py
└── string.py
&amp;quot;&amp;quot;&amp;quot;
# main.py 内容如下
import string
print string.a
# string.py 内容如下
a = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，考虑一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当我们执行main.py的时候，会发生什么事情？&lt;/li&gt;
&lt;li&gt;在main.py文件执行到&lt;code&gt;import string&lt;/code&gt;的时候，解释器导入的string类库是当前文件夹下的string.py还是系统标准库的string.py呢？&lt;/li&gt;
&lt;li&gt;如果明确的指明自己要引用的类库？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了搞清楚上面的问题，我们需要了解关于Python类库引入的机制。&lt;/p&gt;

&lt;h2 id=&#34;python的两种引入机制&#34;&gt;Python的两种引入机制&lt;/h2&gt;

&lt;p&gt;Python 提供了二种引入机制：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;relative import&lt;/li&gt;
&lt;li&gt;absolute import&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;relative-import&#34;&gt;relative import&lt;/h3&gt;

&lt;p&gt;relative import 也叫作相对引入，在Python2.5及之前是默认的引入方法。它的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from .string import a
from ..string import a
from ...string import a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种引入方式使用一个点号来标识引入类库的精确位置。与linux的相对路径表示相似，一个点表示当前目录，每多一个点号则代表向上一层目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
├── __init__.py
├── foo.py
└── main.py
&amp;quot;&amp;quot;&amp;quot;
# foo.py
a = 2
# main.py
print __name__
from .foo import a
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对引入，那么我们需要知道相对什么来引入。相对引入使用被引入文件的&lt;code&gt;__name__&lt;/code&gt;属性来决定该文件在整个包结构的位置。那么如果文件的&lt;code&gt;__name__&lt;/code&gt;没有包含任何包的信息，例如&lt;code&gt;__name__&lt;/code&gt;被设置为了&lt;code&gt;__main__&lt;/code&gt;，则认为其为‘top level script&amp;rsquo;，而不管该文件的位置，这个时候相对引入就没有引入的参考物。如上面的程序所示，当我们执行&lt;code&gt;python main.py&lt;/code&gt;时，Python解释器会抛出 ValueError: Attempted relative import in non-package 的异常。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，&lt;a href=&#34;https://www.python.org/dev/peps/pep-0366/&#34;&gt;PEP 0366 &amp;ndash; Main module explicit relative imports&lt;/a&gt;提出了一个解决方案。允许用户使用&lt;code&gt;python -m ex2.main&lt;/code&gt;的方式,来执行该文件。在这个方案下，引入了一个新的属性&lt;code&gt;__package__&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
╭─liuchang@localhost  ~/Codes/pycon
╰─$ cat ex2/main.py
print __name__
print __package__
from .foo import a
print a
╭─liuchang@localhost  ~/Codes/pycon
╰─$ python -m ex2.main
__main__
ex2
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;absolute-import&#34;&gt;absolute import&lt;/h3&gt;

&lt;p&gt;absolute import 也叫作完全引入，非常类似于Java的引入进制，在Python2.5被完全实现，但是是需要通过&lt;code&gt;from __future__ import absolute_import&lt;/code&gt;来打开该引入进制。在Python2.6之后以及Python3，完全引用成为Python的默认的引入机制。它的使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from pkg import foo
from pkg.moduleA import foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，需要从包目录最顶层目录依次写下，而不能从中间开始。&lt;/p&gt;

&lt;p&gt;在使用该引入方式时，我们碰到比较多的问题就是因为位置原因，Python找不到相应的库文件，抛出ImportError的异常。让我们看一个完全引用的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
ex3
├── __init__.py
├── foo.py
└── main.py
&amp;quot;&amp;quot;&amp;quot;
# foo.py
a = 2

# main.py
print __name__
print __package__
from ex2.foo import a
print a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们尝试着去运行main.py文件，Python解释器会抛出ImportError。那么我们如何解决这个问题呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╰─$ python ex3/main.py
__main__
None
Traceback (most recent call last):
  File &amp;quot;ex3/main.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    from ex2.foo import a
ImportError: No module named ex2.foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，我们也可以使用前文所述的module的方式去运行程序，通过-m参数来告诉解释器&lt;code&gt;__package__&lt;/code&gt;属性。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ python -m ex3.main
__main__
ex3
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们还有一个办法可以解决该问题，在描述之前，我们介绍一个关于Python的非常有用的小知识：&lt;strong&gt;Python解释器会自动将当前工作目录添加到PYTHONPATH&lt;/strong&gt;。如下所示，可以看到我们打印出的&lt;code&gt;sys.path&lt;/code&gt;已经包含了当前工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon/ex4
╰─$ cat main.py
import sys
print sys.path
╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon/ex4
╰─$ python main.py
[&#39;/Users/liuchang/Codes/pycon/ex4&#39;,
&#39;/Library/Python/2.7/site-packages/pip-7.1.0-py2.7.egg&#39;,
&#39;/Library/Python/2.7/site-packages/mesos-_PACKAGE_VERSION_-py2.7.egg&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload&#39;,
&#39;/Users/liuchang/Library/Python/2.7/lib/python/site-packages&#39;,
&#39;/usr/local/lib/python2.7/site-packages&#39;,
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC&#39;,
&#39;/Library/Python/2.7/site-packages&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;了解了Python解释器的这个特性后，我们就可以解决完全引用的找不到类库的问题：执行的时候，让解释器自动的将类库的目录添加到PYTHONPATH中。&lt;/p&gt;

&lt;p&gt;我们可以在顶层目录中添加一个run_ex3.py的文件，文件内容和运行结果如下，可以看到Python解释器正确的执行了ex3.main文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ cat run_ex3.py
from ex3 import main
╭─liuchang@liuchangdeMacBook-Pro  ~/Codes/pycon
╰─$ python run_ex3.py
ex3.main
None
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一些实践经验&#34;&gt;一些实践经验&lt;/h2&gt;

&lt;h3 id=&#34;相对引用还是绝对引用&#34;&gt;相对引用还是绝对引用？&lt;/h3&gt;

&lt;p&gt;上面介绍了Python的两种引用方式，都可以解决引入歧义的问题。那我们应该使用哪一种呢？&lt;/p&gt;

&lt;p&gt;先说明一下Python的默认引用方式，在Python2.4及之前，Python只有相对引用这一种方式，在Python2.5中实现了绝对引用，但默认没有打开，需要用户自己指定使用该引用方式。在之后的版本和Python3版本，绝对引用已经成为默认的引用方式。&lt;/p&gt;

&lt;p&gt;其次，二种引用方式各有利弊。绝对引用代码更加清晰明了，可以清楚的看到引入的包名和层次，但是，当包名修改的时候，我们需要手动修改所有的引用代码。相对引用则比较精简，不会被包名修改所影响，但是可读性较差，不如完全引用清晰。&lt;/p&gt;

&lt;p&gt;最后，对于两种引用的方式选择，还是有争论的。在PEP8中，Python官方推荐的是绝对引用,详细理由可以参考&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/#imports&#34;&gt;这儿&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Absolute imports are recommended, as they are usually more readable and tend to be better behaved (or at least give better error messages) if the import system is incorrectly configured (such as when a directory inside a package ends up on sys.path ):&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;However, explicit relative imports are an acceptable alternative to absolute imports, especially when dealing with complex package layouts where using absolute imports would be unnecessarily verbose:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import sibling
from .sibling import example
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Standard library code should avoid complex package layouts and always use absolute imports.
Implicit relative imports should never be used and have been removed in Python 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;规范打包发布&#34;&gt;规范打包发布&lt;/h3&gt;

&lt;p&gt;为了别人使用自己代码的方便，应该尽量使用规范的包分发机制。为自己的Python包编写正确的setup.py文件，添加相应的README.md文件。对于提供一些可执行命令的包，则可以使用 console_entrypoint 的机制来提供。因为打包和分发不是本文重点，不再详细叙述，大家可以查看官方文档。&lt;/p&gt;

&lt;h3 id=&#34;使用virtualenv管理包依赖&#34;&gt;使用virtualenv管理包依赖&lt;/h3&gt;

&lt;p&gt;在使用Python的时候，尽量使用virtualenv来管理项目，所有的项目从编写到运行都在特定的virtualenv中。并且为自己的项目生成正确的依赖描述文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于virtualenv的用法，可以参考我之前的一篇文章&lt;a href=&#34;http://lcblog-wordpress.stor.sinaapp.com/uploads/2015/10/virtualenv教程.pdf&#34;&gt;virtualenv教程&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;python-import实现&#34;&gt;Python import实现&lt;/h2&gt;

&lt;p&gt;Python 提供了 import 语句来实现类库的引用，下面我们详细介绍当执行了 import 语句的时候，内部究竟做了些什么事情。&lt;/p&gt;

&lt;p&gt;当我们执行一行 &lt;code&gt;from package import module as mymodule&lt;/code&gt;命令时，Python解释器会查找package这个包的module模块，并将该模块作为mymodule引入到当前的工作空间。所以import语句主要是做了二件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查找相应的module&lt;/li&gt;
&lt;li&gt;加载module到local namespace&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们详细了解python是如何查找模块的。&lt;/p&gt;

&lt;h3 id=&#34;查找module的过程&#34;&gt;查找module的过程&lt;/h3&gt;

&lt;p&gt;在import的第一个阶段，主要是完成了查找要引入模块的功能，这个查找的过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查 sys.modules (保存了之前import的类库的缓存），如果module被找到，则⾛到第二步。&lt;/li&gt;
&lt;li&gt;检查 sys.meta_path。meta_path 是一个 list，⾥面保存着一些 finder 对象，如果找到该module的话，就会返回一个finder对象。&lt;/li&gt;
&lt;li&gt;检查⼀些隐式的finder对象，不同的python实现有不同的隐式finder，但是都会有 sys.path_hooks, sys.path_importer_cache 以及sys.path。&lt;/li&gt;
&lt;li&gt;抛出 ImportError。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;sys-modules&#34;&gt;sys.modules&lt;/h3&gt;

&lt;p&gt;对于第一步中sys.modules，我们可以打开Python来实际的查看一下其内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python 2.7.10 (default, Aug 22 2015, 20:33:39)
[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.1)] on darwin
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.modules
{&#39;copy_reg&#39;: &amp;lt;module &#39;copy_reg&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/copy_reg.pyc&#39;&amp;gt;,
&#39;sre_compile&#39;: &amp;lt;module &#39;sre_compile&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_compile.pyc&#39;&amp;gt;,
&#39;_sre&#39;: &amp;lt;module &#39;_sre&#39; (built-in)&amp;gt;,
&#39;encodings&#39;: &amp;lt;module &#39;encodings&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/__init__.pyc&#39;&amp;gt;,
&#39;site&#39;: &amp;lt;module &#39;site&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site.pyc&#39;&amp;gt;,
&#39;__builtin__&#39;: &amp;lt;module &#39;__builtin__&#39; (built-in)&amp;gt;,
&#39;sysconfig&#39;: &amp;lt;module &#39;sysconfig&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sysconfig.pyc&#39;&amp;gt;,
&#39;encodings.encodings&#39;: None,
&#39;__main__&#39;: &amp;lt;module &#39;__main__&#39; (built-in)&amp;gt;,
&#39;supervisor&#39;: &amp;lt;module &#39;supervisor&#39; (built-in)&amp;gt;,
&#39;abc&#39;: &amp;lt;module &#39;abc&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/abc.pyc&#39;&amp;gt;,
&#39;posixpath&#39;: &amp;lt;module &#39;posixpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/posixpath.pyc&#39;&amp;gt;,
&#39;_weakrefset&#39;: &amp;lt;module &#39;_weakrefset&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_weakrefset.pyc&#39;&amp;gt;,
&#39;errno&#39;: &amp;lt;module &#39;errno&#39; (built-in)&amp;gt;,
&#39;encodings.codecs&#39;: None,
&#39;sre_constants&#39;: &amp;lt;module &#39;sre_constants&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_constants.pyc&#39;&amp;gt;,
&#39;re&#39;: &amp;lt;module &#39;re&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/re.pyc&#39;&amp;gt;,
&#39;_abcoll&#39;: &amp;lt;module &#39;_abcoll&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_abcoll.pyc&#39;&amp;gt;,
&#39;types&#39;: &amp;lt;module &#39;types&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/types.pyc&#39;&amp;gt;,
&#39;_codecs&#39;: &amp;lt;module &#39;_codecs&#39; (built-in)&amp;gt;,
&#39;encodings.__builtin__&#39;: None,
&#39;_warnings&#39;: &amp;lt;module &#39;_warnings&#39; (built-in)&amp;gt;,
&#39;genericpath&#39;: &amp;lt;module &#39;genericpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/genericpath.pyc&#39;&amp;gt;,
&#39;stat&#39;: &amp;lt;module &#39;stat&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/stat.pyc&#39;&amp;gt;,
&#39;zipimport&#39;: &amp;lt;module &#39;zipimport&#39; (built-in)&amp;gt;,
&#39;_sysconfigdata&#39;: &amp;lt;module &#39;_sysconfigdata&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_sysconfigdata.pyc&#39;&amp;gt;,
&#39;mpl_toolkits&#39;: &amp;lt;module &#39;mpl_toolkits&#39; (built-in)&amp;gt;,
&#39;warnings&#39;: &amp;lt;module &#39;warnings&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/warnings.pyc&#39;&amp;gt;,
&#39;UserDict&#39;: &amp;lt;module &#39;UserDict&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/UserDict.pyc&#39;&amp;gt;,
&#39;encodings.utf_8&#39;: &amp;lt;module &#39;encodings.utf_8&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/utf_8.pyc&#39;&amp;gt;,
&#39;sys&#39;: &amp;lt;module &#39;sys&#39; (built-in)&amp;gt;,
&#39;_osx_support&#39;: &amp;lt;module &#39;_osx_support&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_osx_support.pyc&#39;&amp;gt;,
&#39;codecs&#39;: &amp;lt;module &#39;codecs&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.pyc&#39;&amp;gt;,
&#39;readline&#39;: &amp;lt;module &#39;readline&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/readline.so&#39;&amp;gt;,
&#39;os.path&#39;: &amp;lt;module &#39;posixpath&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/posixpath.pyc&#39;&amp;gt;,
&#39;_locale&#39;: &amp;lt;module &#39;_locale&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/_locale.so&#39;&amp;gt;,
&#39;signal&#39;: &amp;lt;module &#39;signal&#39; (built-in)&amp;gt;,
&#39;traceback&#39;: &amp;lt;module &#39;traceback&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/traceback.pyc&#39;&amp;gt;,
&#39;linecache&#39;: &amp;lt;module &#39;linecache&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/linecache.pyc&#39;&amp;gt;,
&#39;posix&#39;: &amp;lt;module &#39;posix&#39; (built-in)&amp;gt;,
&#39;encodings.aliases&#39;: &amp;lt;module &#39;encodings.aliases&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/aliases.pyc&#39;&amp;gt;,
&#39;exceptions&#39;: &amp;lt;module &#39;exceptions&#39; (built-in)&amp;gt;,
&#39;sre_parse&#39;: &amp;lt;module &#39;sre_parse&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/sre_parse.pyc&#39;&amp;gt;,
&#39;os&#39;: &amp;lt;module &#39;os&#39; from &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.pyc&#39;&amp;gt;,
&#39;_weakref&#39;: &amp;lt;module &#39;_weakref&#39; (built-in)&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; sys.modules[&#39;zlib&#39;].__file__
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload/zlib.so&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到sys.modules已经保存了一些包的信息，由这些信息，我们就可以直接知道要查找的包的位置等信息。&lt;/p&gt;

&lt;h3 id=&#34;finder-loader和importer&#34;&gt;finder、loader和importer&lt;/h3&gt;

&lt;p&gt;在上文中，我们提到了sys.meta_path中保证了一些finder对象。在python中，不仅定义了finder的概念，还定义了loader和importor的概念。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;finder的任务是决定自己是否根据名字找到相应的模块，在py2中，finder对象必须实现find_module()方法，在py3中必须要实现find_module()或者find_loader（)方法。如果finder可以查找到模块，则会返回一个loader对象(在py3.4中，修改为返回一个module specs)。&lt;/li&gt;
&lt;li&gt;loader则是负责加载模块，它必须实现一个load_module()的方法。&lt;/li&gt;
&lt;li&gt;importer 则指一个对象，实现了finder和loader的方法。因为Python是duck type，只要实现了方法，就可以认为是该类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sys-meta-path&#34;&gt;sys.meta_path&lt;/h3&gt;

&lt;p&gt;在Python查找的时候，如果在sys.modules没有查找到，就会依次调用sys.meta_path中的finder对象。默认的情况下，sys.meta_path是一个空列表，并没有任何finder对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In [6]: sys.meta_path
Out[6]: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以向sys.meta_path中添加一些定义的finder，来实现对Python加载模块的修改。比如下例，我们实现了一个会将每次加载包的信息打印出来的finder。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import sys

class Watcher(object):
    @classmethod
    def find_module(cls, name, path, target=None):
        print(&amp;quot;Importing&amp;quot;, name, path, target)
        return None

sys.meta_path.insert(0, Watcher)

import socket
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们执行的时候，就可以看到系统加载socket包时所发生的事情。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; ╭─liuchang@localhost  ~/Codes/pycon/ex5_meta_path
 ╰─$ python finder1.py
 Importing socket None None
 Importing _socket None None
 Importing functools None None
 Importing _functools None None
 Importing _ssl None None
 Importing cStringIO None None
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sys-path-hook&#34;&gt;sys.path hook&lt;/h3&gt;

&lt;p&gt;Python import的hook分为二类，一类是上一章节已经描述的meta hook，另一类是 path hook。&lt;/p&gt;

&lt;p&gt;当处理sys.path（或者package.&lt;strong&gt;path&lt;/strong&gt;)时，就会调用对应的一部分的 Pack hook。Path Hook是通过向sys.path_hooks 中添加一个importer生成器来注册的。&lt;/p&gt;

&lt;p&gt;sys.path_hooks 是由可被调用的对象组成，它会顺序的检查以决定他们是否可以处理给定的sys.path的一项。每个对象会使用sys.path项的路径来作为参数被调用。如果它不能处理该路径，就必须抛出ImportError，如果可以，则会返回一个importer对象。之后，不会再尝试其它的sys.path_hooks对象，即使前一个importer出错了。&lt;/p&gt;

&lt;p&gt;详细可以参考&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302/#specification-part-2-registering-hooks&#34;&gt;registering-hooks&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;python-import-hooks&#34;&gt;python import hooks&lt;/h2&gt;

&lt;p&gt;在介绍完Python的引用机制与一些实现方法后，接下来我们介绍一些关于如何根据自己的需求来扩展Python的引用机制。&lt;/p&gt;

&lt;p&gt;在开始详细介绍前，给大家展示一个实用性不高，但是很有意思的例子：&lt;strong&gt;让Python在执行代码的时候自动安装缺失的类库&lt;/strong&gt;。我们会实现一个autoinstall的模块，只要import了该模块，就可以打开该功能。如下所示，我们尝试引入tornado库的时候，iPython会提示我们没有安装。然后，我们引入了autoinstall，再尝试引入tornado，iPython就会自动的安装tornado库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;In [1]: import tornado
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
&amp;lt;ipython-input-1-3eac10687b7e&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 import tornado

ImportError: No module named tornado

In [2]: import autoinstall

In [3]: import tornado
Installing tornado

Collecting tornado
  Downloading tornado-4.2.1.tar.gz (434kB)
Collecting backports.ssl-match-hostname (from tornado)
  Downloading http://182.92.2.186:7002/packages/backports.ssl_match_hostname-3.4.0.2-py2-none-any.whl
Collecting certifi (from tornado)
  Downloading certifi-2015.9.6.2-py2.py3-none-any.whl (371kB)
Installing collected packages: backports.ssl-match-hostname, certifi, tornado
  Running setup.py install for tornado
Successfully installed backports.ssl-match-hostname-3.4.0.2 certifi-2015.9.6.2 tornado-4.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个功能的实现其实很简单，利用了sys.meta_path。autoinstall的全部代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import sys
import subprocess


class AutoInstall(object):
    _loaded = set()

    @classmethod
    def find_module(cls, name, path, target=None):
        if path is None and name not in cls._loaded:
            cls._loaded.add(name)
            print(&amp;quot;Installing&amp;quot;, name)
            try:
                out = subprocess.check_output(
                    [&#39;sudo&#39;, sys.executable, &#39;-m&#39;, &#39;pip&#39;, &#39;install&#39;, name])
                print(out)
            except Exception as e:
                print(&amp;quot;Failed&amp;quot; + e.message)
        return None

sys.meta_path.append(AutoInstall)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;import-hook的重要性&#34;&gt;import hook的重要性&lt;/h3&gt;

&lt;p&gt;我们为什么需要Python import的hook呢？使用import的hook可以让我们做到很多事情，比如说当我们的Python包存储在一个非标准的文件中，或者Python程序存储在网络数据库中，或者像py2exe一样将Python程序打包成了一个文件，我们需要一种方法来正确的解析它们。&lt;/p&gt;

&lt;p&gt;其次，我们希望在Python加载类库的时候，可以额外的做一些事情，比如上传审计信息，比如延迟加载，比如自动解决上例的依赖未安装的问题。&lt;/p&gt;

&lt;p&gt;所以，import系统的Hook技术是值的花时间学习的。&lt;/p&gt;

&lt;h3 id=&#34;如何实现import-hooks&#34;&gt;如何实现import hooks&lt;/h3&gt;

&lt;p&gt;Python提供了一些方法，让我们可以在代码中动态的调用import。主要有如下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;__import__ : Python的内置函数&lt;/li&gt;
&lt;li&gt;imputil        : Python的import工具库，在py2.6被声明废弃，py3中彻底移除。&lt;/li&gt;
&lt;li&gt;imp            : Python2 的一个import库，py3中移除&lt;/li&gt;
&lt;li&gt;importlib      : Python3 中最新添加，backport到py2.7，但只有很小的子集（只有一个函数）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python2 所有关于import的库的列表参见&lt;a href=&#34;https://docs.python.org/2/library/modules.html&#34;&gt;Importing Modules&lt;/a&gt;。Python3 的可以参考&lt;a href=&#34;https://docs.python.org/3/library/modules.html&#34;&gt;Importing Modules&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302&#34;&gt;PEP 0302 &amp;ndash; New Import Hooks&lt;/a&gt; 提案详细的描述了importlib的目的、用法。&lt;/p&gt;

&lt;h3 id=&#34;一些hook示例&#34;&gt;一些Hook示例&lt;/h3&gt;

&lt;h3 id=&#34;lazy化库引入&#34;&gt;Lazy化库引入&lt;/h3&gt;

&lt;p&gt;使用Import Hook，我们可以达到Lazy Import的效果，当我们执行import的时候，实际上并没引入该库，只有真正的使用这个库的时候，才会将其引入到当前工作空间。
具体的代码可以参考&lt;a href=&#34;https://github.com/noahmorrison/limp&#34;&gt;github&lt;/a&gt;。
实现的效果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python

import limp  # Lazy imports begin now

import json
import sys

print(&#39;json&#39; in sys.modules)  # False
print(&#39;, &#39;.join(json.loads(&#39;[&amp;quot;Hello&amp;quot;, &amp;quot;World!&amp;quot;]&#39;)))
print(&#39;json&#39; in sys.modules)  # True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的实现也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import imp

_lazy_modules = {}

class LazyModule():
    def __init__(self, name):
        self.name = name

    def __getattr__(self, attr):
        path = _lazy_modules[self.name]
        f, pathname, desc = imp.find_module(self.name, path)

        lf = sys.meta_path.pop()
        imp.load_module(self.name, f, pathname, desc)
        sys.meta_path.append(lf)


        self.__dict__ = sys.modules[self.name].__dict__
        return self.__dict__[attr]

class LazyFinder(object):

    def find_module(self, name, path):
        _lazy_modules[name] = path
        return self

    def load_module(self, name):
        return LazyModule(name)

sys.meta_path.append(LazyFinder())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flask-插件库统一入口&#34;&gt;Flask 插件库统一入口&lt;/h3&gt;

&lt;p&gt;使用过Flask的同学都知道，Flask的对于插件提供了统一的入口。比如说我们安装了Flask_API这个库，然后我们可以直接&lt;code&gt;import flask_api&lt;/code&gt;来使用这个库，同时Flask还允许我们采用&lt;code&gt;import flask.ext.api&lt;/code&gt;的方式来引用该库。&lt;/p&gt;

&lt;p&gt;这里Flask就是使用了import 的hook，当引入flask.ext的包时，就自动的引用相应的库。Flask实现了一个叫ExtensionImporter的类，这个类实现了find_module和load_module代码实现如下&lt;a href=&#34;https://github.com/mitsuhiko/flask/blob/master/flask/exthook.py#L27&#34;&gt;github&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ExtensionImporter(object):
    &amp;quot;&amp;quot;&amp;quot;This importer redirects imports from this submodule to other locations.
    This makes it possible to transition from the old flaskext.name to the
    newer flask_name without people having a hard time.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, module_choices, wrapper_module):
        self.module_choices = module_choices
        self.wrapper_module = wrapper_module
        self.prefix = wrapper_module + &#39;.&#39;
        self.prefix_cutoff = wrapper_module.count(&#39;.&#39;) + 1

    def __eq__(self, other):
        return self.__class__.__module__ == other.__class__.__module__ and \
               self.__class__.__name__ == other.__class__.__name__ and \
               self.wrapper_module == other.wrapper_module and \
               self.module_choices == other.module_choices

    def __ne__(self, other):
        return not self.__eq__(other)

    def install(self):
        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]

    def find_module(self, fullname, path=None):
        if fullname.startswith(self.prefix):
            return self

    def load_module(self, fullname):
        if fullname in sys.modules:
            return sys.modules[fullname]
        modname = fullname.split(&#39;.&#39;, self.prefix_cutoff)[self.prefix_cutoff]
        for path in self.module_choices:
            realname = path % modname
            try:
                __import__(realname)
            except ImportError:
                exc_type, exc_value, tb = sys.exc_info()
                # since we only establish the entry in sys.modules at the
                # very this seems to be redundant, but if recursive imports
                # happen we will call into the move import a second time.
                # On the second invocation we still don&#39;t have an entry for
                # fullname in sys.modules, but we will end up with the same
                # fake module name and that import will succeed since this
                # one already has a temporary entry in the modules dict.
                # Since this one &amp;quot;succeeded&amp;quot; temporarily that second
                # invocation now will have created a fullname entry in
                # sys.modules which we have to kill.
                sys.modules.pop(fullname, None)

                # If it&#39;s an important traceback we reraise it, otherwise
                # we swallow it and try the next choice.  The skipped frame
                # is the one from __import__ above which we don&#39;t care about
                if self.is_important_traceback(realname, tb):
                    reraise(exc_type, exc_value, tb.tb_next)
                continue
            module = sys.modules[fullname] = sys.modules[realname]
            if &#39;.&#39; not in modname:
                setattr(sys.modules[self.wrapper_module], modname, module)
            return module
        raise ImportError(&#39;No module named %s&#39; % fullname)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在Flask的ext目录下的__init__.py文件中，初始化了该Importer。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def setup():
    from ..exthook import ExtensionImporter
    importer = ExtensionImporter([&#39;flask_%s&#39;, &#39;flaskext.%s&#39;], __name__)
    importer.install()
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;希望坚持阅读到本处的你，能明白Python import的用法、实现和改造方法。准备仓促，难免会有错误，欢迎大家指正和PR。&lt;/p&gt;

&lt;p&gt;本文使用CC-BY-SA协议。&lt;/p&gt;

&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0302/&#34;&gt;https://www.python.org/dev/peps/pep-0302/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0338/&#34;&gt;https://www.python.org/dev/peps/pep-0338/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0328/&#34;&gt;https://www.python.org/dev/peps/pep-0328/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0366/&#34;&gt;https://www.python.org/dev/peps/pep-0366/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/noahmorrison/limp&#34;&gt;https://github.com/noahmorrison/limp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mitsuhiko/flask&#34;&gt;https://github.com/mitsuhiko/flask&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy学习笔记（一）</title>
      <link>http://hshsh.me/post/2016-04-04-sqlalchemy-study-notes-01/</link>
      <pubDate>Mon, 04 Apr 2016 19:18:09 +0800</pubDate>
      
      <guid>http://hshsh.me/post/2016-04-04-sqlalchemy-study-notes-01/</guid>
      <description>

&lt;p&gt;这篇笔记部分内容来自网络&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fn-copyright&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fn-copyright&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，部分来自对《Essential SQLAlchemy》的学习和使用经验。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;是 Python 编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，使用MIT许可证发行。&lt;/p&gt;

&lt;p&gt;SQLAlchemy“采用简单的Python语言，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型”。&lt;/p&gt;

&lt;p&gt;SQLAlchemy的理念是，SQL数据库的量级和性能重要于对象集合；而对象集合的抽象又重要于表和行。因此，SQLAlchmey 采用了类似于Java里 Hibernate 的数据映射模型，而不是其他ORM框架采用的 Active Record 模型。不过，Elixir 和 declarative 等可选插件可以让用户使用声明语法。&lt;/p&gt;

&lt;p&gt;SQLAlchemy首次发行于2006年2月，并迅速地在Python社区中最广泛使用的ORM工具之一，不亚于Django的ORM框架。&lt;/p&gt;

&lt;p&gt;以上摘自&lt;a href=&#34;https://zh.wikipedia.org/wiki/SQLAlchemy&#34;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;使用&lt;code&gt;SQLAlchemy&lt;/code&gt;有三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 Raw SQL&lt;/li&gt;
&lt;li&gt;使用 SQL Expression&lt;/li&gt;
&lt;li&gt;使用 ORM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两种方式可以统称为 core 方式。&lt;/p&gt;

&lt;p&gt;对于绝大多数应用，推荐使用 &lt;code&gt;SQLAlchemy&lt;/code&gt;，即使是使用 Raw SQL，也可以带来如下好处。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内建数据库连接池。&lt;strong&gt;注意：&lt;/strong&gt;如果是 SQLAlchemy + cx_oracle 的话，需要禁用 Connection Pool，否则会有异常。方法是设置&lt;code&gt;sqlalchemy.poolclass&lt;/code&gt;为&lt;code&gt;sqlalchemy.pool.NullPool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;强大的日志功能（log）&lt;/li&gt;
&lt;li&gt;数据库无关的写法，包括：SQL参数写法、LIMIT语法等&lt;/li&gt;
&lt;li&gt;特别提一下，WHERE 条件的 &lt;code&gt;== value&lt;/code&gt; 写法，如果&lt;code&gt;value&lt;/code&gt;等于&lt;code&gt;None&lt;/code&gt;，真正的SQL会转为 &lt;code&gt;IS NULL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SQLAlchemy 的 Raw SQL 和 SQL Expression 比较：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SQL Expression 的写法是纯 Python 代码，阅读性更好，尤其是在使用 &lt;code&gt;insert()&lt;/code&gt; 方法时，字段名和取值成对出现。&lt;/li&gt;
&lt;li&gt;Raw SQL 比 SQL Expression 更灵活，如果 SQL/DDL 很复杂，Raw SQL 就更有优势了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;常用数据库连接字符串&#34;&gt;常用数据库连接字符串&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy import create_engine

# file database
# sqlite = create_engine(&#39;sqlite:////absolute/path/to/database.db&#39;)
# in-memory database, two ways
# sqlite = create_engine(&#39;sqlite://&#39;)
sqlite = create_engine(&#39;sqlite:///:memory:&#39;)
# postgresql
pgsql = create_engine(&#39;postgres://user:passwd@host:port/database&#39;)
# mysql
mysql = create_engine(&#39;mysql://user:passwd@host:port/database&#39;)
# oracle
oracle = create_engine(&#39;oracle://user:passwd@host:port/sidname&#39;)
# oracle via TNS name
oracle_tns = create_engine(&#39;oracle://user:passwd@tnsname&#39;)
# ms sql server using ODBC datasource names.
PyODBC is the default driver
# mssql = create_engine(&#39;mssql://mydsn&#39;)
mssql = create_engine(&#39;mssql://user:passwd@mydsn&#39;)
# firebird
firebird = create_engine(&#39;firebird://user:passwd@host/some.gdm&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;connection-less-执行和-connection-执行&#34;&gt;Connection less 执行和 Connection 执行&lt;/h2&gt;

&lt;p&gt;直接使用 &lt;code&gt;engine&lt;/code&gt; 执行SQL的方式，叫做 connection less 执行。&lt;/p&gt;

&lt;p&gt;先使用 &lt;code&gt;engine.connect()&lt;/code&gt; 获取连接对象 &lt;code&gt;conn&lt;/code&gt;，然后通过 &lt;code&gt;conn&lt;/code&gt; 执行SQL的方式，叫做 connection 执行。&lt;/p&gt;

&lt;p&gt;如果要在 transaction 模式下执行，推荐使用 connection 方式；如果不涉及 transaction，两种方法效果是一样的。&lt;/p&gt;

&lt;h2 id=&#34;使用-text-函数封装sql字符串&#34;&gt;使用&lt;code&gt;text()&lt;/code&gt;函数封装SQL字符串&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;text()&lt;/code&gt; 函数有很多好处：&lt;/p&gt;

&lt;p&gt;1). 不同数据库，可以使用统一的SQL参数传递写法，参数需以“冒号”引出，在调用 &lt;code&gt;execute()&lt;/code&gt; 的时候，使用 dict 结构将实参传进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import text

result = db.execute(
   text(&#39;select * from table where id &amp;lt; :id and typeName = :type&#39;),
   {&#39;id&#39;: 2, &#39;type&#39;: &#39;USER_TABLE&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2). 如果不指定参数的类型，默认为字符串类型；如果要传递日期参数，需要使用 &lt;code&gt;text()&lt;/code&gt; 的 &lt;code&gt;bindparams&lt;/code&gt; 参数来声明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime, timedelta
from sqlalchemy import DateTime, bindparam

# ten days ago
date_param = datetime.today() + timedelta(days=-1*10)
sql = &#39;delete from caw_job_alarm_log where alarm_time &amp;lt; :alarm_time_param&#39;
t = text(sql, bindparams=[
        bindparam(&#39;alarm_time_param&#39;, type_=DateTime, required=True)])
db.execute(t, {&#39;alarm_time_param&#39;: date_param})
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参数 &lt;code&gt;bindparam&lt;/code&gt; 可以使用 &lt;code&gt;type_&lt;/code&gt; 来制定参数的类型，也可以使用 initial 值来指定参数的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;bindparam(&#39;alart_time_param&#39;, type_=DateTime)  # or
bindparam(&#39;alart_time_param&#39;, DateTime())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3). 如果要转换查询结果中的数据类型，可以通过 &lt;code&gt;text()&lt;/code&gt; 的参数 &lt;code&gt;typemap&lt;/code&gt; 参数指定。这点比 mybatis 还灵活：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import Integer, Unicode

t = text(&#39;select id, name from users&#39;,
         typemap={&#39;id&#39;: Integer, &#39;name&#39;: Unicode})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4). 其他好处，详见 sqlalchemy/sql/expression.py 中的 docstring。&lt;/p&gt;

&lt;h2 id=&#34;sqlalchemy-访问数据库&#34;&gt;SQLAlchemy 访问数据库&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;create_engine&lt;/code&gt; 函数返回一个 &lt;code&gt;Engine&lt;/code&gt; 对象。通过 &lt;code&gt;Engine&lt;/code&gt; 对象的 &lt;code&gt;execute&lt;/code&gt; 方法可以执行数据库操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;execute&lt;/code&gt; 方法返回一个 &lt;code&gt;ResultProxy&lt;/code&gt; 对象，&lt;code&gt;ResultProxy&lt;/code&gt; 类是对 &lt;code&gt;Cursor&lt;/code&gt; 类的封装，其中的 &lt;code&gt;cursor&lt;/code&gt; 属性对应原来的 &lt;code&gt;cursor&lt;/code&gt;，这个类有很多方法对应着 &lt;code&gt;Cursor&lt;/code&gt; 类的方法，另外又扩展了一些属性和方法。&lt;/p&gt;

&lt;p&gt;对 &lt;code&gt;ResultProxy&lt;/code&gt; 对象进行遍历时，得到的每一行都是一个 &lt;code&gt;RowProxy&lt;/code&gt; 对象，获取字段的方法非常灵活，索引、字段名，甚至属性都行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;row_proxy[0] == row_proxy[&#39;id&#39;] == row_proxy.id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看得出来，&lt;code&gt;RowProxy&lt;/code&gt; 跟Java的 POJO 类有相似的特性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import create_engine

db = create_engine(&#39;sqlite:///:memory:&#39;, echo=True)

# DDL
db.execute(&#39;create table users(userid char(10), username char(50))&#39;)

# DML
result = db.execute(
    &amp;quot;insert into users (userid, username) values (&#39;user1&#39;, &#39;tony&#39;)&amp;quot;)
# get rows affected by an UPDATE or DELETE statement,
# it is not intended to provide the number of rows present from SELECT
result.rowcount
# True if this ResultProxy returns rows.
result.returns_rows

# Query
result = db.execute(&amp;quot;select * from users&amp;quot;)
result.scalar()  # 可以返回一个标量查询的值
result.fetchall()   # 取回所有的行
result.fetchmany()  # 取回多行
result.fetchone()   # 取回一行，并判断有且只有一行，若超出一行则报错
result.first()      # 取回第一行
result.close()  # result 用完之后，需要关闭
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLAlchemy 支持事务，甚至可以嵌套事务。&lt;/p&gt;

&lt;p&gt;缺省情况下事务自动提交，即执行一条SQL就自动提交。&lt;/p&gt;

&lt;p&gt;如果要更精准的控制事务，最简单的方法是使用 &lt;code&gt;connection&lt;/code&gt;，然后通过 &lt;code&gt;connection&lt;/code&gt; 获取 &lt;code&gt;transaction&lt;/code&gt; 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# transaction
connection = db.connect()
trans = connection.begin()
try:
    do_something_with(connection)
    trans.commit()
except:
    trans.rollback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方式是在创建 &lt;code&gt;engine&lt;/code&gt; 对象时指定 &lt;code&gt;strategy=&#39;threadlocal&#39;&lt;/code&gt; 参数，这样会自动创建一个线程局部的连接，对于后续的无连接的执行都会自动使用这个连接，这样在处理事务时，只要使用 &lt;code&gt;engine&lt;/code&gt; 对象来操作事务就行了。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;db = create_engine(connection, strategy=&#39;threadlocal&#39;)
db.begin()
try:
    do_something()
except:
    db.rollback()
else:
    db.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果希望手动提交事务，也可以在 &lt;code&gt;connection&lt;/code&gt; 和 &lt;code&gt;statement&lt;/code&gt; 上通过 &lt;code&gt;execute_options()&lt;/code&gt; 方法修改为手动提交模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;conn.execute_options(autocommit=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置为手动提交模式后，要提交事务，需要调用 &lt;code&gt;conn.commit()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h2 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 默认的连接池算法选用规则为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接内存中的 SQLite，默认的连接池算法为 &lt;code&gt;SingletonThreadPool&lt;/code&gt; 类，即两个线程允许一个连接；&lt;/li&gt;
&lt;li&gt;连接基于文件的 SQLite，默认的i连接池算法为 &lt;code&gt;NullPool&lt;/code&gt; 类，即不使用连接池；&lt;/li&gt;
&lt;li&gt;对于其他情况，默认的连接池算法为 &lt;code&gt;QueuePool&lt;/code&gt; 类。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们也可以实现自己的连接池算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db = create_engine(&#39;sqlite:///file.db&#39;, poolclass=YourPoolClass)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;create_engine()&lt;/code&gt; 函数和连接池相关的参数有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pool_recycle: 默认为-1，推荐设置为7200，即如果 &lt;code&gt;connection&lt;/code&gt; 空闲了 7200秒 = 2小时，自动重新获取，以防止 &lt;code&gt;connection&lt;/code&gt; 被数据库服务器关闭；&lt;/li&gt;
&lt;li&gt;pool_size: 保持连接数，默认为5，正式环境下该数值偏小，需根据实际情况调整；&lt;/li&gt;
&lt;li&gt;max_overflow: 超出 &lt;code&gt;pool_size&lt;/code&gt; 后允许的最大连接数，默认为10，这10个连接在使用过后，不放在连接池中，而是被真正关闭的。&lt;/li&gt;
&lt;li&gt;pool_timeout: 获取连接的超时阀值，默认为30秒。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;国内的云服务平台 &lt;a href=&#34;http://sae.sina.com.cn&#34;&gt;SAE&lt;/a&gt; 中的共享型 MySQL 服务不支持连接池，如果在其上部署应用，需要禁用连接池，也就是使用 &lt;code&gt;NullPool&lt;/code&gt; 类，否则会报 &amp;lsquo;(2006, MySQL server has gone away)&amp;rsquo; 错误。&lt;/p&gt;

&lt;h2 id=&#34;日志输出&#34;&gt;日志输出&lt;/h2&gt;

&lt;p&gt;SQLAlchemy 默认输出日志到 &lt;code&gt;sys.stdout&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果要输出到文件，log 文件不具备 rotate 功能，不推荐在生产环境中使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import logging
logging.getLogger(&#39;sqlalchemy.engine&#39;).setLevel(logging.INFO)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;create_engine()&lt;/code&gt; 函数时，可选传递一个参数 &lt;code&gt;echo=True&lt;/code&gt; 来打开详细信息输出，这个功能信息量非常大，只适合调试使用，不建议生产环境中使用。&lt;/p&gt;

&lt;h2 id=&#34;最佳实践与使用心得&#34;&gt;最佳实践与使用心得&lt;/h2&gt;

&lt;p&gt;使用 ORM 方式构建复杂查询比较困难，使用 Raw SQL 和 SQL Expression 会比较合适一些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;declarative&lt;/code&gt; 是 SQLAlchemy 的一个新的扩展功能 ，只能用在 ORM 方式中，不适用在 Raw SQL 和 SQL Expression 方式。&lt;/p&gt;

&lt;p&gt;如果使用 ORM 方式，表必须有主键，使用 Raw SQL 和 SQL Express 方式没有这个约束。&lt;/p&gt;

&lt;p&gt;查询有简单的也有复杂的，使用 Raw SQL 会比较方便。&lt;/p&gt;

&lt;p&gt;增、删、改，多是单表操作，使用 SQL Expression 就足够了。具体讲，比如一个 &lt;code&gt;User&lt;/code&gt; 类，&lt;strong&gt;可以包含一个固定的 &lt;code&gt;_table&lt;/code&gt; 成员&lt;/strong&gt;，增删改直接使用 &lt;code&gt;_table&lt;/code&gt; 对象来完成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_table = Table(&#39;users&#39;, metadata, autoload=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;批量的 insert/update/delete 操作，可以将每行数据组成一个 dict，在将这些 dict 组成一个 list，和 _table.insert()/update()/delete() 一起作为参数传给 `conn.execute()&amp;lsquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sqlalchemy import Table

# _table member object
_table = Table(&#39;users&#39;, metadata, autoload=True)
# insert
_table.insert().values(f1=value1, f2=value2)
# update
_table.update().values(f1=new_value1, f2=new_value2).where(
    _table.c.f1 == value1).where(_table.c.f2 == value2)
# delete
_table.delete().where(_table.c.f1 == value1).where(
    _table.c.f2 == value2)

# batch opration
conn.execute(_table.insert(), [
        {&#39;user_id&#39;: 1, &#39;email_address&#39;: &#39;jack@yahoo.com&#39;},
        {&#39;user_id&#39;: 1, &#39;email_address&#39;: &#39;jack@msn.com&#39;},
        {&#39;user_id&#39;: 2, &#39;email_address&#39;: &#39;susan@example.com&#39;},
        {&#39;user_id&#39;: 2, &#39;email_address&#39;: &#39;susan@example.org&#39;}
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL Expression 也可以像 Raw SQL 的 &lt;code&gt;text()&lt;/code&gt; 函数一样使用 &lt;code&gt;bindparam&lt;/code&gt;，方法是在调用 insert()/update()/delete() 时声明参数，然后在 &lt;code&gt;conn.execute()&lt;/code&gt; 执行时候，将参数传递进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = _table.delete().where(_table.c.hire_date &amp;lt;= bindparam(
    &#39;hire_day&#39;, DateTime(), required=True))
conn.execute(d, {&#39;hire_day&#39;: datetime.today()})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;where()&lt;/code&gt; 和 ORM 中的 &lt;code&gt;filter()&lt;/code&gt; 接受一样的参数，各种SQL条件都支持：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# equals, not equals
where(_table.c.name == &#39;ed&#39;)
where(_table.c.name != &#39;ed&#39;)
# like
where(_table.c.name.like(&#39;%ed%&#39;))
# in, not in
where(_table.c.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))
where(~_table.c.name.in_([&#39;ed&#39;, &#39;wendy&#39;, &#39;jack&#39;]))
# is null, is not null
where(_table.c.name == None)
where(_table.c.name != None)

# and, or
from sqlalchemy import and_, or_
where(and_(_table.c.name == &#39;ed&#39;, _table.c.fullname == &#39;Ed Jones&#39;))
where(or_(_table.c.name == &#39;ed&#39;, _table.c.name == &#39;wendy&#39;))
# and can also be written with multiple where clause
where(_table.c.name == &#39;ed&#39;).where(_table.c.fullname == &#39;Ed Jones&#39;)

# match: contents of the match parameter are database backend specific
where(_table.c.name.match(&#39;wendy&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fn-copyright&#34;&gt;出处已不可考，如有侵权请联系我。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fn-copyright&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>